var Gf = Object.defineProperty;
var zf = (n, e, t) => e in n ? Gf(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var Th = (n, e, t) => (zf(n, typeof e != "symbol" ? e + "" : e, t), t);
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Fr = globalThis, el = Fr.ShadowRoot && (Fr.ShadyCSS === void 0 || Fr.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, Qc = Symbol(), Rh = /* @__PURE__ */ new WeakMap();
let $f = class {
  constructor(e, t, i) {
    if (this._$cssResult$ = !0, i !== Qc)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = e, this.t = t;
  }
  get styleSheet() {
    let e = this.o;
    const t = this.t;
    if (el && e === void 0) {
      const i = t !== void 0 && t.length === 1;
      i && (e = Rh.get(t)), e === void 0 && ((this.o = e = new CSSStyleSheet()).replaceSync(this.cssText), i && Rh.set(t, e));
    }
    return e;
  }
  toString() {
    return this.cssText;
  }
};
const Uf = (n) => new $f(typeof n == "string" ? n : n + "", void 0, Qc), Vf = (n, e) => {
  if (el)
    n.adoptedStyleSheets = e.map((t) => t instanceof CSSStyleSheet ? t : t.styleSheet);
  else
    for (const t of e) {
      const i = document.createElement("style"), s = Fr.litNonce;
      s !== void 0 && i.setAttribute("nonce", s), i.textContent = t.cssText, n.appendChild(i);
    }
}, Ih = el ? (n) => n : (n) => n instanceof CSSStyleSheet ? ((e) => {
  let t = "";
  for (const i of e.cssRules)
    t += i.cssText;
  return Uf(t);
})(n) : n;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: jf, defineProperty: Yf, getOwnPropertyDescriptor: Xf, getOwnPropertyNames: Bf, getOwnPropertySymbols: Wf, getPrototypeOf: Kf } = Object, Pi = globalThis, Ph = Pi.trustedTypes, Zf = Ph ? Ph.emptyScript : "", jo = Pi.reactiveElementPolyfillSupport, xs = (n, e) => n, Dr = { toAttribute(n, e) {
  switch (e) {
    case Boolean:
      n = n ? Zf : null;
      break;
    case Object:
    case Array:
      n = n == null ? n : JSON.stringify(n);
  }
  return n;
}, fromAttribute(n, e) {
  let t = n;
  switch (e) {
    case Boolean:
      t = n !== null;
      break;
    case Number:
      t = n === null ? null : Number(n);
      break;
    case Object:
    case Array:
      try {
        t = JSON.parse(n);
      } catch {
        t = null;
      }
  }
  return t;
} }, tl = (n, e) => !jf(n, e), Lh = { attribute: !0, type: String, converter: Dr, reflect: !1, hasChanged: tl };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), Pi.litPropertyMetadata ?? (Pi.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
class xn extends HTMLElement {
  static addInitializer(e) {
    this._$Ei(), (this.l ?? (this.l = [])).push(e);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(e, t = Lh) {
    if (t.state && (t.attribute = !1), this._$Ei(), this.elementProperties.set(e, t), !t.noAccessor) {
      const i = Symbol(), s = this.getPropertyDescriptor(e, i, t);
      s !== void 0 && Yf(this.prototype, e, s);
    }
  }
  static getPropertyDescriptor(e, t, i) {
    const { get: s, set: r } = Xf(this.prototype, e) ?? { get() {
      return this[t];
    }, set(o) {
      this[t] = o;
    } };
    return { get() {
      return s == null ? void 0 : s.call(this);
    }, set(o) {
      const a = s == null ? void 0 : s.call(this);
      r.call(this, o), this.requestUpdate(e, a, i);
    }, configurable: !0, enumerable: !0 };
  }
  static getPropertyOptions(e) {
    return this.elementProperties.get(e) ?? Lh;
  }
  static _$Ei() {
    if (this.hasOwnProperty(xs("elementProperties")))
      return;
    const e = Kf(this);
    e.finalize(), e.l !== void 0 && (this.l = [...e.l]), this.elementProperties = new Map(e.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(xs("finalized")))
      return;
    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(xs("properties"))) {
      const t = this.properties, i = [...Bf(t), ...Wf(t)];
      for (const s of i)
        this.createProperty(s, t[s]);
    }
    const e = this[Symbol.metadata];
    if (e !== null) {
      const t = litPropertyMetadata.get(e);
      if (t !== void 0)
        for (const [i, s] of t)
          this.elementProperties.set(i, s);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t, i] of this.elementProperties) {
      const s = this._$Eu(t, i);
      s !== void 0 && this._$Eh.set(s, t);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(e) {
    const t = [];
    if (Array.isArray(e)) {
      const i = new Set(e.flat(1 / 0).reverse());
      for (const s of i)
        t.unshift(Ih(s));
    } else
      e !== void 0 && t.push(Ih(e));
    return t;
  }
  static _$Eu(e, t) {
    const i = t.attribute;
    return i === !1 ? void 0 : typeof i == "string" ? i : typeof e == "string" ? e.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var e;
    this._$ES = new Promise((t) => this.enableUpdating = t), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (e = this.constructor.l) == null || e.forEach((t) => t(this));
  }
  addController(e) {
    var t;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(e), this.renderRoot !== void 0 && this.isConnected && ((t = e.hostConnected) == null || t.call(e));
  }
  removeController(e) {
    var t;
    (t = this._$EO) == null || t.delete(e);
  }
  _$E_() {
    const e = /* @__PURE__ */ new Map(), t = this.constructor.elementProperties;
    for (const i of t.keys())
      this.hasOwnProperty(i) && (e.set(i, this[i]), delete this[i]);
    e.size > 0 && (this._$Ep = e);
  }
  createRenderRoot() {
    const e = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return Vf(e, this.constructor.elementStyles), e;
  }
  connectedCallback() {
    var e;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), (e = this._$EO) == null || e.forEach((t) => {
      var i;
      return (i = t.hostConnected) == null ? void 0 : i.call(t);
    });
  }
  enableUpdating(e) {
  }
  disconnectedCallback() {
    var e;
    (e = this._$EO) == null || e.forEach((t) => {
      var i;
      return (i = t.hostDisconnected) == null ? void 0 : i.call(t);
    });
  }
  attributeChangedCallback(e, t, i) {
    this._$AK(e, i);
  }
  _$EC(e, t) {
    var r;
    const i = this.constructor.elementProperties.get(e), s = this.constructor._$Eu(e, i);
    if (s !== void 0 && i.reflect === !0) {
      const o = (((r = i.converter) == null ? void 0 : r.toAttribute) !== void 0 ? i.converter : Dr).toAttribute(t, i.type);
      this._$Em = e, o == null ? this.removeAttribute(s) : this.setAttribute(s, o), this._$Em = null;
    }
  }
  _$AK(e, t) {
    var r;
    const i = this.constructor, s = i._$Eh.get(e);
    if (s !== void 0 && this._$Em !== s) {
      const o = i.getPropertyOptions(s), a = typeof o.converter == "function" ? { fromAttribute: o.converter } : ((r = o.converter) == null ? void 0 : r.fromAttribute) !== void 0 ? o.converter : Dr;
      this._$Em = s, this[s] = a.fromAttribute(t, o.type), this._$Em = null;
    }
  }
  requestUpdate(e, t, i) {
    if (e !== void 0) {
      if (i ?? (i = this.constructor.getPropertyOptions(e)), !(i.hasChanged ?? tl)(this[e], t))
        return;
      this.P(e, t, i);
    }
    this.isUpdatePending === !1 && (this._$ES = this._$ET());
  }
  P(e, t, i) {
    this._$AL.has(e) || this._$AL.set(e, t), i.reflect === !0 && this._$Em !== e && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(e);
  }
  async _$ET() {
    this.isUpdatePending = !0;
    try {
      await this._$ES;
    } catch (t) {
      Promise.reject(t);
    }
    const e = this.scheduleUpdate();
    return e != null && await e, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var i;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [r, o] of this._$Ep)
          this[r] = o;
        this._$Ep = void 0;
      }
      const s = this.constructor.elementProperties;
      if (s.size > 0)
        for (const [r, o] of s)
          o.wrapped !== !0 || this._$AL.has(r) || this[r] === void 0 || this.P(r, this[r], o);
    }
    let e = !1;
    const t = this._$AL;
    try {
      e = this.shouldUpdate(t), e ? (this.willUpdate(t), (i = this._$EO) == null || i.forEach((s) => {
        var r;
        return (r = s.hostUpdate) == null ? void 0 : r.call(s);
      }), this.update(t)) : this._$EU();
    } catch (s) {
      throw e = !1, this._$EU(), s;
    }
    e && this._$AE(t);
  }
  willUpdate(e) {
  }
  _$AE(e) {
    var t;
    (t = this._$EO) == null || t.forEach((i) => {
      var s;
      return (s = i.hostUpdated) == null ? void 0 : s.call(i);
    }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(e)), this.updated(e);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = !1;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(e) {
    return !0;
  }
  update(e) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((t) => this._$EC(t, this[t]))), this._$EU();
  }
  updated(e) {
  }
  firstUpdated(e) {
  }
}
xn.elementStyles = [], xn.shadowRootOptions = { mode: "open" }, xn[xs("elementProperties")] = /* @__PURE__ */ new Map(), xn[xs("finalized")] = /* @__PURE__ */ new Map(), jo == null || jo({ ReactiveElement: xn }), (Pi.reactiveElementVersions ?? (Pi.reactiveElementVersions = [])).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const Es = globalThis, Nr = Es.trustedTypes, bh = Nr ? Nr.createPolicy("lit-html", { createHTML: (n) => n }) : void 0, eu = "$lit$", pi = `lit$${(Math.random() + "").slice(9)}$`, tu = "?" + pi, Hf = `<${tu}>`, qi = document, Ls = () => qi.createComment(""), bs = (n) => n === null || typeof n != "object" && typeof n != "function", iu = Array.isArray, qf = (n) => iu(n) || typeof (n == null ? void 0 : n[Symbol.iterator]) == "function", Yo = `[ 	
\f\r]`, hs = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, Ah = /-->/g, Fh = />/g, $i = RegExp(`>|${Yo}(?:([^\\s"'>=/]+)(${Yo}*=${Yo}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), Mh = /'/g, Oh = /"/g, nu = /^(?:script|style|textarea|title)$/i, Jf = (n) => (e, ...t) => ({ _$litType$: n, strings: e, values: t }), Pn = Jf(1), Dn = Symbol.for("lit-noChange"), Ie = Symbol.for("lit-nothing"), Dh = /* @__PURE__ */ new WeakMap(), Yi = qi.createTreeWalker(qi, 129);
function su(n, e) {
  if (!Array.isArray(n) || !n.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return bh !== void 0 ? bh.createHTML(e) : e;
}
const Qf = (n, e) => {
  const t = n.length - 1, i = [];
  let s, r = e === 2 ? "<svg>" : "", o = hs;
  for (let a = 0; a < t; a++) {
    const l = n[a];
    let h, c, u = -1, d = 0;
    for (; d < l.length && (o.lastIndex = d, c = o.exec(l), c !== null); )
      d = o.lastIndex, o === hs ? c[1] === "!--" ? o = Ah : c[1] !== void 0 ? o = Fh : c[2] !== void 0 ? (nu.test(c[2]) && (s = RegExp("</" + c[2], "g")), o = $i) : c[3] !== void 0 && (o = $i) : o === $i ? c[0] === ">" ? (o = s ?? hs, u = -1) : c[1] === void 0 ? u = -2 : (u = o.lastIndex - c[2].length, h = c[1], o = c[3] === void 0 ? $i : c[3] === '"' ? Oh : Mh) : o === Oh || o === Mh ? o = $i : o === Ah || o === Fh ? o = hs : (o = $i, s = void 0);
    const f = o === $i && n[a + 1].startsWith("/>") ? " " : "";
    r += o === hs ? l + Hf : u >= 0 ? (i.push(h), l.slice(0, u) + eu + l.slice(u) + pi + f) : l + pi + (u === -2 ? a : f);
  }
  return [su(n, r + (n[t] || "<?>") + (e === 2 ? "</svg>" : "")), i];
};
class As {
  constructor({ strings: e, _$litType$: t }, i) {
    let s;
    this.parts = [];
    let r = 0, o = 0;
    const a = e.length - 1, l = this.parts, [h, c] = Qf(e, t);
    if (this.el = As.createElement(h, i), Yi.currentNode = this.el.content, t === 2) {
      const u = this.el.content.firstChild;
      u.replaceWith(...u.childNodes);
    }
    for (; (s = Yi.nextNode()) !== null && l.length < a; ) {
      if (s.nodeType === 1) {
        if (s.hasAttributes())
          for (const u of s.getAttributeNames())
            if (u.endsWith(eu)) {
              const d = c[o++], f = s.getAttribute(u).split(pi), g = /([.?@])?(.*)/.exec(d);
              l.push({ type: 1, index: r, name: g[2], strings: f, ctor: g[1] === "." ? tg : g[1] === "?" ? ig : g[1] === "@" ? ng : uo }), s.removeAttribute(u);
            } else
              u.startsWith(pi) && (l.push({ type: 6, index: r }), s.removeAttribute(u));
        if (nu.test(s.tagName)) {
          const u = s.textContent.split(pi), d = u.length - 1;
          if (d > 0) {
            s.textContent = Nr ? Nr.emptyScript : "";
            for (let f = 0; f < d; f++)
              s.append(u[f], Ls()), Yi.nextNode(), l.push({ type: 2, index: ++r });
            s.append(u[d], Ls());
          }
        }
      } else if (s.nodeType === 8)
        if (s.data === tu)
          l.push({ type: 2, index: r });
        else {
          let u = -1;
          for (; (u = s.data.indexOf(pi, u + 1)) !== -1; )
            l.push({ type: 7, index: r }), u += pi.length - 1;
        }
      r++;
    }
  }
  static createElement(e, t) {
    const i = qi.createElement("template");
    return i.innerHTML = e, i;
  }
}
function Nn(n, e, t = n, i) {
  var o, a;
  if (e === Dn)
    return e;
  let s = i !== void 0 ? (o = t._$Co) == null ? void 0 : o[i] : t._$Cl;
  const r = bs(e) ? void 0 : e._$litDirective$;
  return (s == null ? void 0 : s.constructor) !== r && ((a = s == null ? void 0 : s._$AO) == null || a.call(s, !1), r === void 0 ? s = void 0 : (s = new r(n), s._$AT(n, t, i)), i !== void 0 ? (t._$Co ?? (t._$Co = []))[i] = s : t._$Cl = s), s !== void 0 && (e = Nn(n, s._$AS(n, e.values), s, i)), e;
}
class eg {
  constructor(e, t) {
    this._$AV = [], this._$AN = void 0, this._$AD = e, this._$AM = t;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(e) {
    const { el: { content: t }, parts: i } = this._$AD, s = ((e == null ? void 0 : e.creationScope) ?? qi).importNode(t, !0);
    Yi.currentNode = s;
    let r = Yi.nextNode(), o = 0, a = 0, l = i[0];
    for (; l !== void 0; ) {
      if (o === l.index) {
        let h;
        l.type === 2 ? h = new Bs(r, r.nextSibling, this, e) : l.type === 1 ? h = new l.ctor(r, l.name, l.strings, this, e) : l.type === 6 && (h = new sg(r, this, e)), this._$AV.push(h), l = i[++a];
      }
      o !== (l == null ? void 0 : l.index) && (r = Yi.nextNode(), o++);
    }
    return Yi.currentNode = qi, s;
  }
  p(e) {
    let t = 0;
    for (const i of this._$AV)
      i !== void 0 && (i.strings !== void 0 ? (i._$AI(e, i, t), t += i.strings.length - 2) : i._$AI(e[t])), t++;
  }
}
class Bs {
  get _$AU() {
    var e;
    return ((e = this._$AM) == null ? void 0 : e._$AU) ?? this._$Cv;
  }
  constructor(e, t, i, s) {
    this.type = 2, this._$AH = Ie, this._$AN = void 0, this._$AA = e, this._$AB = t, this._$AM = i, this.options = s, this._$Cv = (s == null ? void 0 : s.isConnected) ?? !0;
  }
  get parentNode() {
    let e = this._$AA.parentNode;
    const t = this._$AM;
    return t !== void 0 && (e == null ? void 0 : e.nodeType) === 11 && (e = t.parentNode), e;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(e, t = this) {
    e = Nn(this, e, t), bs(e) ? e === Ie || e == null || e === "" ? (this._$AH !== Ie && this._$AR(), this._$AH = Ie) : e !== this._$AH && e !== Dn && this._(e) : e._$litType$ !== void 0 ? this.$(e) : e.nodeType !== void 0 ? this.T(e) : qf(e) ? this.k(e) : this._(e);
  }
  S(e) {
    return this._$AA.parentNode.insertBefore(e, this._$AB);
  }
  T(e) {
    this._$AH !== e && (this._$AR(), this._$AH = this.S(e));
  }
  _(e) {
    this._$AH !== Ie && bs(this._$AH) ? this._$AA.nextSibling.data = e : this.T(qi.createTextNode(e)), this._$AH = e;
  }
  $(e) {
    var r;
    const { values: t, _$litType$: i } = e, s = typeof i == "number" ? this._$AC(e) : (i.el === void 0 && (i.el = As.createElement(su(i.h, i.h[0]), this.options)), i);
    if (((r = this._$AH) == null ? void 0 : r._$AD) === s)
      this._$AH.p(t);
    else {
      const o = new eg(s, this), a = o.u(this.options);
      o.p(t), this.T(a), this._$AH = o;
    }
  }
  _$AC(e) {
    let t = Dh.get(e.strings);
    return t === void 0 && Dh.set(e.strings, t = new As(e)), t;
  }
  k(e) {
    iu(this._$AH) || (this._$AH = [], this._$AR());
    const t = this._$AH;
    let i, s = 0;
    for (const r of e)
      s === t.length ? t.push(i = new Bs(this.S(Ls()), this.S(Ls()), this, this.options)) : i = t[s], i._$AI(r), s++;
    s < t.length && (this._$AR(i && i._$AB.nextSibling, s), t.length = s);
  }
  _$AR(e = this._$AA.nextSibling, t) {
    var i;
    for ((i = this._$AP) == null ? void 0 : i.call(this, !1, !0, t); e && e !== this._$AB; ) {
      const s = e.nextSibling;
      e.remove(), e = s;
    }
  }
  setConnected(e) {
    var t;
    this._$AM === void 0 && (this._$Cv = e, (t = this._$AP) == null || t.call(this, e));
  }
}
class uo {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(e, t, i, s, r) {
    this.type = 1, this._$AH = Ie, this._$AN = void 0, this.element = e, this.name = t, this._$AM = s, this.options = r, i.length > 2 || i[0] !== "" || i[1] !== "" ? (this._$AH = Array(i.length - 1).fill(new String()), this.strings = i) : this._$AH = Ie;
  }
  _$AI(e, t = this, i, s) {
    const r = this.strings;
    let o = !1;
    if (r === void 0)
      e = Nn(this, e, t, 0), o = !bs(e) || e !== this._$AH && e !== Dn, o && (this._$AH = e);
    else {
      const a = e;
      let l, h;
      for (e = r[0], l = 0; l < r.length - 1; l++)
        h = Nn(this, a[i + l], t, l), h === Dn && (h = this._$AH[l]), o || (o = !bs(h) || h !== this._$AH[l]), h === Ie ? e = Ie : e !== Ie && (e += (h ?? "") + r[l + 1]), this._$AH[l] = h;
    }
    o && !s && this.j(e);
  }
  j(e) {
    e === Ie ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, e ?? "");
  }
}
class tg extends uo {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(e) {
    this.element[this.name] = e === Ie ? void 0 : e;
  }
}
class ig extends uo {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(e) {
    this.element.toggleAttribute(this.name, !!e && e !== Ie);
  }
}
class ng extends uo {
  constructor(e, t, i, s, r) {
    super(e, t, i, s, r), this.type = 5;
  }
  _$AI(e, t = this) {
    if ((e = Nn(this, e, t, 0) ?? Ie) === Dn)
      return;
    const i = this._$AH, s = e === Ie && i !== Ie || e.capture !== i.capture || e.once !== i.once || e.passive !== i.passive, r = e !== Ie && (i === Ie || s);
    s && this.element.removeEventListener(this.name, this, i), r && this.element.addEventListener(this.name, this, e), this._$AH = e;
  }
  handleEvent(e) {
    var t;
    typeof this._$AH == "function" ? this._$AH.call(((t = this.options) == null ? void 0 : t.host) ?? this.element, e) : this._$AH.handleEvent(e);
  }
}
class sg {
  constructor(e, t, i) {
    this.element = e, this.type = 6, this._$AN = void 0, this._$AM = t, this.options = i;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(e) {
    Nn(this, e);
  }
}
const Xo = Es.litHtmlPolyfillSupport;
Xo == null || Xo(As, Bs), (Es.litHtmlVersions ?? (Es.litHtmlVersions = [])).push("3.1.2");
const ru = (n, e, t) => {
  const i = (t == null ? void 0 : t.renderBefore) ?? e;
  let s = i._$litPart$;
  if (s === void 0) {
    const r = (t == null ? void 0 : t.renderBefore) ?? null;
    i._$litPart$ = s = new Bs(e.insertBefore(Ls(), r), r, void 0, t ?? {});
  }
  return s._$AI(n), s;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
class Ln extends xn {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var t;
    const e = super.createRenderRoot();
    return (t = this.renderOptions).renderBefore ?? (t.renderBefore = e.firstChild), e;
  }
  update(e) {
    const t = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(e), this._$Do = ru(t, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var e;
    super.connectedCallback(), (e = this._$Do) == null || e.setConnected(!0);
  }
  disconnectedCallback() {
    var e;
    super.disconnectedCallback(), (e = this._$Do) == null || e.setConnected(!1);
  }
  render() {
    return Dn;
  }
}
var Jc;
Ln._$litElement$ = !0, Ln.finalized = !0, (Jc = globalThis.litElementHydrateSupport) == null || Jc.call(globalThis, { LitElement: Ln });
const Bo = globalThis.litElementPolyfillSupport;
Bo == null || Bo({ LitElement: Ln });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const rg = (n) => (e, t) => {
  t !== void 0 ? t.addInitializer(() => {
    customElements.define(n, e);
  }) : customElements.define(n, e);
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const og = { attribute: !0, type: String, converter: Dr, reflect: !1, hasChanged: tl }, ag = (n = og, e, t) => {
  const { kind: i, metadata: s } = t;
  let r = globalThis.litPropertyMetadata.get(s);
  if (r === void 0 && globalThis.litPropertyMetadata.set(s, r = /* @__PURE__ */ new Map()), r.set(t.name, n), i === "accessor") {
    const { name: o } = t;
    return { set(a) {
      const l = e.get.call(this);
      e.set.call(this, a), this.requestUpdate(o, l, n);
    }, init(a) {
      return a !== void 0 && this.P(o, void 0, n), a;
    } };
  }
  if (i === "setter") {
    const { name: o } = t;
    return function(a) {
      const l = this[o];
      e.call(this, a), this.requestUpdate(o, l, n);
    };
  }
  throw Error("Unsupported decorator location: " + i);
};
function si(n) {
  return (e, t) => typeof t == "object" ? ag(n, e, t) : ((i, s, r) => {
    const o = s.hasOwnProperty(r);
    return s.constructor.createProperty(r, o ? { ...i, wrapped: !0 } : i), o ? Object.getOwnPropertyDescriptor(s, r) : void 0;
  })(n, e, t);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function fo(n) {
  return si({ ...n, state: !0, attribute: !1 });
}
class lg {
  /**
   * @param {string} type Type.
   */
  constructor(e) {
    this.propagationStopped, this.defaultPrevented, this.type = e, this.target = null;
  }
  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */
  preventDefault() {
    this.defaultPrevented = !0;
  }
  /**
   * Stop event propagation.
   * @api
   */
  stopPropagation() {
    this.propagationStopped = !0;
  }
}
function hg(n) {
  n.stopPropagation();
}
const dt = lg, Ji = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: "propertychange"
};
class cg {
  constructor() {
    this.disposed = !1;
  }
  /**
   * Clean up.
   */
  dispose() {
    this.disposed || (this.disposed = !0, this.disposeInternal());
  }
  /**
   * Extension point for disposable objects.
   * @protected
   */
  disposeInternal() {
  }
}
const il = cg;
function ug(n, e, t) {
  let i, s;
  t = t || ti;
  let r = 0, o = n.length, a = !1;
  for (; r < o; )
    i = r + (o - r >> 1), s = +t(n[i], e), s < 0 ? r = i + 1 : (o = i, a = !s);
  return a ? r : ~r;
}
function ti(n, e) {
  return n > e ? 1 : n < e ? -1 : 0;
}
function go(n, e, t) {
  if (n[0] <= e)
    return 0;
  const i = n.length;
  if (e <= n[i - 1])
    return i - 1;
  if (typeof t == "function") {
    for (let s = 1; s < i; ++s) {
      const r = n[s];
      if (r === e)
        return s;
      if (r < e)
        return t(e, n[s - 1], r) > 0 ? s - 1 : s;
    }
    return i - 1;
  }
  if (t > 0) {
    for (let s = 1; s < i; ++s)
      if (n[s] < e)
        return s - 1;
    return i - 1;
  }
  if (t < 0) {
    for (let s = 1; s < i; ++s)
      if (n[s] <= e)
        return s;
    return i - 1;
  }
  for (let s = 1; s < i; ++s) {
    if (n[s] == e)
      return s;
    if (n[s] < e)
      return n[s - 1] - e < e - n[s] ? s - 1 : s;
  }
  return i - 1;
}
function dg(n, e, t) {
  for (; e < t; ) {
    const i = n[e];
    n[e] = n[t], n[t] = i, ++e, --t;
  }
}
function se(n, e) {
  const t = Array.isArray(e) ? e : [e], i = t.length;
  for (let s = 0; s < i; s++)
    n[n.length] = t[s];
}
function ri(n, e) {
  const t = n.length;
  if (t !== e.length)
    return !1;
  for (let i = 0; i < t; i++)
    if (n[i] !== e[i])
      return !1;
  return !0;
}
function fg(n, e, t) {
  const i = e || ti;
  return n.every(function(s, r) {
    if (r === 0)
      return !0;
    const o = i(n[r - 1], s);
    return !(o > 0 || t && o === 0);
  });
}
function kn() {
  return !0;
}
function Hn() {
  return !1;
}
function Gn() {
}
function ou(n) {
  let e = !1, t, i, s;
  return function() {
    const r = Array.prototype.slice.call(arguments);
    return (!e || this !== s || !ri(r, i)) && (e = !0, s = this, i = r, t = n.apply(this, arguments)), t;
  };
}
function gg(n) {
  function e() {
    let t;
    try {
      t = n();
    } catch (i) {
      return Promise.reject(i);
    }
    return t instanceof Promise ? t : Promise.resolve(t);
  }
  return e();
}
function Ws(n) {
  for (const e in n)
    delete n[e];
}
function Fi(n) {
  let e;
  for (e in n)
    return !1;
  return !e;
}
class _g extends il {
  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  constructor(e) {
    super(), this.eventTarget_ = e, this.pendingRemovals_ = null, this.dispatching_ = null, this.listeners_ = null;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  addEventListener(e, t) {
    if (!e || !t)
      return;
    const i = this.listeners_ || (this.listeners_ = {}), s = i[e] || (i[e] = []);
    s.includes(t) || s.push(t);
  }
  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  dispatchEvent(e) {
    const t = typeof e == "string", i = t ? e : e.type, s = this.listeners_ && this.listeners_[i];
    if (!s)
      return;
    const r = t ? new dt(e) : (
      /** @type {Event} */
      e
    );
    r.target || (r.target = this.eventTarget_ || this);
    const o = this.dispatching_ || (this.dispatching_ = {}), a = this.pendingRemovals_ || (this.pendingRemovals_ = {});
    i in o || (o[i] = 0, a[i] = 0), ++o[i];
    let l;
    for (let h = 0, c = s.length; h < c; ++h)
      if ("handleEvent" in s[h] ? l = /** @type {import("../events.js").ListenerObject} */
      s[h].handleEvent(r) : l = /** @type {import("../events.js").ListenerFunction} */
      s[h].call(this, r), l === !1 || r.propagationStopped) {
        l = !1;
        break;
      }
    if (--o[i] === 0) {
      let h = a[i];
      for (delete a[i]; h--; )
        this.removeEventListener(i, Gn);
      delete o[i];
    }
    return l;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.listeners_ && Ws(this.listeners_);
  }
  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */
  getListeners(e) {
    return this.listeners_ && this.listeners_[e] || void 0;
  }
  /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  hasListener(e) {
    return this.listeners_ ? e ? e in this.listeners_ : Object.keys(this.listeners_).length > 0 : !1;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  removeEventListener(e, t) {
    if (!this.listeners_)
      return;
    const i = this.listeners_[e];
    if (!i)
      return;
    const s = i.indexOf(t);
    s !== -1 && (this.pendingRemovals_ && e in this.pendingRemovals_ ? (i[s] = Gn, ++this.pendingRemovals_[e]) : (i.splice(s, 1), i.length === 0 && delete this.listeners_[e]));
  }
}
const Ks = _g, G = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: "change",
  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: "error",
  BLUR: "blur",
  CLEAR: "clear",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  DRAGENTER: "dragenter",
  DRAGOVER: "dragover",
  DROP: "drop",
  FOCUS: "focus",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  RESIZE: "resize",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};
function Z(n, e, t, i, s) {
  if (i && i !== n && (t = t.bind(i)), s) {
    const o = t;
    t = function() {
      n.removeEventListener(e, t), o.apply(this, arguments);
    };
  }
  const r = {
    target: n,
    type: e,
    listener: t
  };
  return n.addEventListener(e, t), r;
}
function Fs(n, e, t, i) {
  return Z(n, e, t, i, !0);
}
function he(n) {
  n && n.target && (n.target.removeEventListener(n.type, n.listener), Ws(n));
}
class _o extends Ks {
  constructor() {
    super(), this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onInternal, this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onceInternal, this.un = /** @type {ObservableOnSignature<void>} */
    this.unInternal, this.revision_ = 0;
  }
  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  changed() {
    ++this.revision_, this.dispatchEvent(G.CHANGE);
  }
  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  getRevision() {
    return this.revision_;
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onInternal(e, t) {
    if (Array.isArray(e)) {
      const i = e.length, s = new Array(i);
      for (let r = 0; r < i; ++r)
        s[r] = Z(this, e[r], t);
      return s;
    }
    return Z(
      this,
      /** @type {string} */
      e,
      t
    );
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onceInternal(e, t) {
    let i;
    if (Array.isArray(e)) {
      const s = e.length;
      i = new Array(s);
      for (let r = 0; r < s; ++r)
        i[r] = Fs(this, e[r], t);
    } else
      i = Fs(
        this,
        /** @type {string} */
        e,
        t
      );
    return t.ol_key = i, i;
  }
  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */
  unInternal(e, t) {
    const i = (
      /** @type {Object} */
      t.ol_key
    );
    if (i)
      mg(i);
    else if (Array.isArray(e))
      for (let s = 0, r = e.length; s < r; ++s)
        this.removeEventListener(e[s], t);
    else
      this.removeEventListener(e, t);
  }
}
_o.prototype.on;
_o.prototype.once;
_o.prototype.un;
function mg(n) {
  if (Array.isArray(n))
    for (let e = 0, t = n.length; e < t; ++e)
      he(n[e]);
  else
    he(
      /** @type {import("./events.js").EventsKey} */
      n
    );
}
const au = _o;
function B() {
  throw new Error("Unimplemented abstract method.");
}
let pg = 0;
function j(n) {
  return n.ol_uid || (n.ol_uid = String(++pg));
}
class Nh extends dt {
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  constructor(e, t, i) {
    super(e), this.key = t, this.oldValue = i;
  }
}
class yg extends au {
  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, j(this), this.values_ = null, e !== void 0 && this.setProperties(e);
  }
  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  get(e) {
    let t;
    return this.values_ && this.values_.hasOwnProperty(e) && (t = this.values_[e]), t;
  }
  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  getKeys() {
    return this.values_ && Object.keys(this.values_) || [];
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  getProperties() {
    return this.values_ && Object.assign({}, this.values_) || {};
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.values_;
  }
  /**
   * @return {boolean} The object has properties.
   */
  hasProperties() {
    return !!this.values_;
  }
  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  notify(e, t) {
    let i;
    i = `change:${e}`, this.hasListener(i) && this.dispatchEvent(new Nh(i, e, t)), i = Ji.PROPERTYCHANGE, this.hasListener(i) && this.dispatchEvent(new Nh(i, e, t));
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  addChangeListener(e, t) {
    this.addEventListener(`change:${e}`, t);
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  removeChangeListener(e, t) {
    this.removeEventListener(`change:${e}`, t);
  }
  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  set(e, t, i) {
    const s = this.values_ || (this.values_ = {});
    if (i)
      s[e] = t;
    else {
      const r = s[e];
      s[e] = t, r !== t && this.notify(e, r);
    }
  }
  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  setProperties(e, t) {
    for (const i in e)
      this.set(i, e[i], t);
  }
  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */
  applyProperties(e) {
    e.values_ && Object.assign(this.values_ || (this.values_ = {}), e.values_);
  }
  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */
  unset(e, t) {
    if (this.values_ && e in this.values_) {
      const i = this.values_[e];
      delete this.values_[e], Fi(this.values_) && (this.values_ = null), t || this.notify(e, i);
    }
  }
}
const vt = yg, Fe = {
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: "add",
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: "remove"
}, kh = {
  LENGTH: "length"
};
class fr extends dt {
  /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */
  constructor(e, t, i) {
    super(e), this.element = t, this.index = i;
  }
}
class xg extends vt {
  /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */
  constructor(e, t) {
    if (super(), this.on, this.once, this.un, t = t || {}, this.unique_ = !!t.unique, this.array_ = e || [], this.unique_)
      for (let i = 0, s = this.array_.length; i < s; ++i)
        this.assertUnique_(this.array_[i], i);
    this.updateLength_();
  }
  /**
   * Remove all elements from the collection.
   * @api
   */
  clear() {
    for (; this.getLength() > 0; )
      this.pop();
  }
  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */
  extend(e) {
    for (let t = 0, i = e.length; t < i; ++t)
      this.push(e[t]);
    return this;
  }
  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */
  forEach(e) {
    const t = this.array_;
    for (let i = 0, s = t.length; i < s; ++i)
      e(t[i], i, t);
  }
  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */
  getArray() {
    return this.array_;
  }
  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */
  item(e) {
    return this.array_[e];
  }
  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */
  getLength() {
    return this.get(kh.LENGTH);
  }
  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  insertAt(e, t) {
    if (e < 0 || e > this.getLength())
      throw new Error("Index out of bounds: " + e);
    this.unique_ && this.assertUnique_(t), this.array_.splice(e, 0, t), this.updateLength_(), this.dispatchEvent(
      new fr(Fe.ADD, t, e)
    );
  }
  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */
  pop() {
    return this.removeAt(this.getLength() - 1);
  }
  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */
  push(e) {
    this.unique_ && this.assertUnique_(e);
    const t = this.getLength();
    return this.insertAt(t, e), this.getLength();
  }
  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */
  remove(e) {
    const t = this.array_;
    for (let i = 0, s = t.length; i < s; ++i)
      if (t[i] === e)
        return this.removeAt(i);
  }
  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */
  removeAt(e) {
    if (e < 0 || e >= this.getLength())
      return;
    const t = this.array_[e];
    return this.array_.splice(e, 1), this.updateLength_(), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new fr(Fe.REMOVE, t, e)
    ), t;
  }
  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  setAt(e, t) {
    const i = this.getLength();
    if (e >= i) {
      this.insertAt(e, t);
      return;
    }
    if (e < 0)
      throw new Error("Index out of bounds: " + e);
    this.unique_ && this.assertUnique_(t, e);
    const s = this.array_[e];
    this.array_[e] = t, this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new fr(Fe.REMOVE, s, e)
    ), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new fr(Fe.ADD, t, e)
    );
  }
  /**
   * @private
   */
  updateLength_() {
    this.set(kh.LENGTH, this.array_.length);
  }
  /**
   * @private
   * @param {T} elem Element.
   * @param {number} [except] Optional index to ignore.
   */
  assertUnique_(e, t) {
    for (let i = 0, s = this.array_.length; i < s; ++i)
      if (this.array_[i] === e && i !== t)
        throw new Error("Duplicate item added to a unique collection");
  }
}
const ze = xg, le = {
  OPACITY: "opacity",
  VISIBLE: "visible",
  EXTENT: "extent",
  Z_INDEX: "zIndex",
  MAX_RESOLUTION: "maxResolution",
  MIN_RESOLUTION: "minResolution",
  MAX_ZOOM: "maxZoom",
  MIN_ZOOM: "minZoom",
  SOURCE: "source",
  MAP: "map"
};
function Q(n, e) {
  if (!n)
    throw new Error(e);
}
function _e(n, e, t) {
  return Math.min(Math.max(n, e), t);
}
function Eg(n, e, t, i, s, r) {
  const o = s - t, a = r - i;
  if (o !== 0 || a !== 0) {
    const l = ((n - t) * o + (e - i) * a) / (o * o + a * a);
    l > 1 ? (t = s, i = r) : l > 0 && (t += o * l, i += a * l);
  }
  return Ht(n, e, t, i);
}
function Ht(n, e, t, i) {
  const s = t - n, r = i - e;
  return s * s + r * r;
}
function Cg(n) {
  const e = n.length;
  for (let i = 0; i < e; i++) {
    let s = i, r = Math.abs(n[i][i]);
    for (let a = i + 1; a < e; a++) {
      const l = Math.abs(n[a][i]);
      l > r && (r = l, s = a);
    }
    if (r === 0)
      return null;
    const o = n[s];
    n[s] = n[i], n[i] = o;
    for (let a = i + 1; a < e; a++) {
      const l = -n[a][i] / n[i][i];
      for (let h = i; h < e + 1; h++)
        i == h ? n[a][h] = 0 : n[a][h] += l * n[i][h];
    }
  }
  const t = new Array(e);
  for (let i = e - 1; i >= 0; i--) {
    t[i] = n[i][e] / n[i][i];
    for (let s = i - 1; s >= 0; s--)
      n[s][e] -= n[s][i] * t[i];
  }
  return t;
}
function Li(n) {
  return n * Math.PI / 180;
}
function Hi(n, e) {
  const t = n % e;
  return t * e < 0 ? t + e : t;
}
function He(n, e, t) {
  return n + t * (e - n);
}
function Zs(n, e) {
  const t = Math.pow(10, e);
  return Math.round(n * t) / t;
}
function Gh(n, e) {
  return Math.round(Zs(n, e));
}
function vn(n, e) {
  return Math.floor(Zs(n, e));
}
function xi(n, e) {
  return Math.ceil(Zs(n, e));
}
class wg extends vt {
  /**
   * @param {Options} options Layer options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, this.background_ = e.background;
    const t = Object.assign({}, e);
    typeof e.properties == "object" && (delete t.properties, Object.assign(t, e.properties)), t[le.OPACITY] = e.opacity !== void 0 ? e.opacity : 1, Q(
      typeof t[le.OPACITY] == "number",
      "Layer opacity must be a number"
    ), t[le.VISIBLE] = e.visible !== void 0 ? e.visible : !0, t[le.Z_INDEX] = e.zIndex, t[le.MAX_RESOLUTION] = e.maxResolution !== void 0 ? e.maxResolution : 1 / 0, t[le.MIN_RESOLUTION] = e.minResolution !== void 0 ? e.minResolution : 0, t[le.MIN_ZOOM] = e.minZoom !== void 0 ? e.minZoom : -1 / 0, t[le.MAX_ZOOM] = e.maxZoom !== void 0 ? e.maxZoom : 1 / 0, this.className_ = t.className !== void 0 ? t.className : "ol-layer", delete t.className, this.setProperties(t), this.state_ = null;
  }
  /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */
  getBackground() {
    return this.background_;
  }
  /**
   * @return {string} CSS class name.
   */
  getClassName() {
    return this.className_;
  }
  /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */
  getLayerState(e) {
    const t = this.state_ || /** @type {?} */
    {
      layer: this,
      managed: e === void 0 ? !0 : e
    }, i = this.getZIndex();
    return t.opacity = _e(Math.round(this.getOpacity() * 100) / 100, 0, 1), t.visible = this.getVisible(), t.extent = this.getExtent(), t.zIndex = i === void 0 && !t.managed ? 1 / 0 : i, t.maxResolution = this.getMaxResolution(), t.minResolution = Math.max(this.getMinResolution(), 0), t.minZoom = this.getMinZoom(), t.maxZoom = this.getMaxZoom(), this.state_ = t, t;
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(e) {
    return B();
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(e) {
    return B();
  }
  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */
  getExtent() {
    return (
      /** @type {import("../extent.js").Extent|undefined} */
      this.get(le.EXTENT)
    );
  }
  /**
   * Return the maximum resolution of the layer. Returns Infinity if
   * the layer has no maximum resolution set.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */
  getMaxResolution() {
    return (
      /** @type {number} */
      this.get(le.MAX_RESOLUTION)
    );
  }
  /**
   * Return the minimum resolution of the layer. Returns 0 if
   * the layer has no minimum resolution set.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */
  getMinResolution() {
    return (
      /** @type {number} */
      this.get(le.MIN_RESOLUTION)
    );
  }
  /**
   * Return the minimum zoom level of the layer. Returns -Infinity if
   * the layer has no minimum zoom set.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.get(le.MIN_ZOOM)
    );
  }
  /**
   * Return the maximum zoom level of the layer. Returns Infinity if
   * the layer has no maximum zoom set.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.get(le.MAX_ZOOM)
    );
  }
  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */
  getOpacity() {
    return (
      /** @type {number} */
      this.get(le.OPACITY)
    );
  }
  /**
   * @abstract
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return B();
  }
  /**
   * Return the value of this layer's `visible` property. To find out whether the layer
   * is visible on a map, use `isVisible()` instead.
   * @return {boolean} The value of the `visible` property of the layer.
   * @observable
   * @api
   */
  getVisible() {
    return (
      /** @type {boolean} */
      this.get(le.VISIBLE)
    );
  }
  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. Returns undefined if the layer is unmanaged.
   * @return {number|undefined} The Z-index of the layer.
   * @observable
   * @api
   */
  getZIndex() {
    return (
      /** @type {number|undefined} */
      this.get(le.Z_INDEX)
    );
  }
  /**
   * Sets the background color.
   * @param {BackgroundColor} [background] Background color.
   */
  setBackground(e) {
    this.background_ = e, this.changed();
  }
  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */
  setExtent(e) {
    this.set(le.EXTENT, e);
  }
  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */
  setMaxResolution(e) {
    this.set(le.MAX_RESOLUTION, e);
  }
  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */
  setMinResolution(e) {
    this.set(le.MIN_RESOLUTION, e);
  }
  /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */
  setMaxZoom(e) {
    this.set(le.MAX_ZOOM, e);
  }
  /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */
  setMinZoom(e) {
    this.set(le.MIN_ZOOM, e);
  }
  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */
  setOpacity(e) {
    Q(typeof e == "number", "Layer opacity must be a number"), this.set(le.OPACITY, e);
  }
  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */
  setVisible(e) {
    this.set(le.VISIBLE, e);
  }
  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */
  setZIndex(e) {
    this.set(le.Z_INDEX, e);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.state_ && (this.state_.layer = null, this.state_ = null), super.disposeInternal();
  }
}
const lu = wg, st = {
  /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: "prerender",
  /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: "precompose",
  /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: "postcompose",
  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: "rendercomplete"
}, de = {
  ANIMATING: 0,
  INTERACTING: 1
}, Ke = {
  CENTER: "center",
  RESOLUTION: "resolution",
  ROTATION: "rotation"
}, hu = 42, nl = 256, zn = {
  // use the radius of the Normal sphere
  radians: 6370997 / (2 * Math.PI),
  degrees: 2 * Math.PI * 6370997 / 360,
  ft: 0.3048,
  m: 1,
  "us-ft": 1200 / 3937
};
class Sg {
  /**
   * @param {Options} options Projection options.
   */
  constructor(e) {
    this.code_ = e.code, this.units_ = /** @type {import("./Units.js").Units} */
    e.units, this.extent_ = e.extent !== void 0 ? e.extent : null, this.worldExtent_ = e.worldExtent !== void 0 ? e.worldExtent : null, this.axisOrientation_ = e.axisOrientation !== void 0 ? e.axisOrientation : "enu", this.global_ = e.global !== void 0 ? e.global : !1, this.canWrapX_ = !!(this.global_ && this.extent_), this.getPointResolutionFunc_ = e.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = e.metersPerUnit;
  }
  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */
  canWrapX() {
    return this.canWrapX_;
  }
  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */
  getCode() {
    return this.code_;
  }
  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */
  getUnits() {
    return this.units_;
  }
  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */
  getMetersPerUnit() {
    return this.metersPerUnit_ || zn[this.units_];
  }
  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getWorldExtent() {
    return this.worldExtent_;
  }
  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */
  getAxisOrientation() {
    return this.axisOrientation_;
  }
  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */
  isGlobal() {
    return this.global_;
  }
  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */
  setGlobal(e) {
    this.global_ = e, this.canWrapX_ = !!(e && this.extent_);
  }
  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }
  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */
  setDefaultTileGrid(e) {
    this.defaultTileGrid_ = e;
  }
  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  setExtent(e) {
    this.extent_ = e, this.canWrapX_ = !!(this.global_ && e);
  }
  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */
  setWorldExtent(e) {
    this.worldExtent_ = e;
  }
  /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */
  setGetPointResolution(e) {
    this.getPointResolutionFunc_ = e;
  }
  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
   * resolution function (if set).
   */
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
}
const sl = Sg, Hs = 6378137, Tn = Math.PI * Hs, vg = [-Tn, -Tn, Tn, Tn], Tg = [-180, -85, 180, 85], gr = Hs * Math.log(Math.tan(Math.PI / 2));
class dn extends sl {
  /**
   * @param {string} code Code.
   */
  constructor(e) {
    super({
      code: e,
      units: "m",
      extent: vg,
      global: !0,
      worldExtent: Tg,
      getPointResolution: function(t, i) {
        return t / Math.cosh(i[1] / Hs);
      }
    });
  }
}
const zh = [
  new dn("EPSG:3857"),
  new dn("EPSG:102100"),
  new dn("EPSG:102113"),
  new dn("EPSG:900913"),
  new dn("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new dn("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function Rg(n, e, t) {
  const i = n.length;
  t = t > 1 ? t : 2, e === void 0 && (t > 2 ? e = n.slice() : e = new Array(i));
  for (let s = 0; s < i; s += t) {
    e[s] = Tn * n[s] / 180;
    let r = Hs * Math.log(Math.tan(Math.PI * (+n[s + 1] + 90) / 360));
    r > gr ? r = gr : r < -gr && (r = -gr), e[s + 1] = r;
  }
  return e;
}
function Ig(n, e, t) {
  const i = n.length;
  t = t > 1 ? t : 2, e === void 0 && (t > 2 ? e = n.slice() : e = new Array(i));
  for (let s = 0; s < i; s += t)
    e[s] = 180 * n[s] / Tn, e[s + 1] = 360 * Math.atan(Math.exp(n[s + 1] / Hs)) / Math.PI - 90;
  return e;
}
const Pg = 6378137, $h = [-180, -90, 180, 90], Lg = Math.PI * Pg / 180;
class Ui extends sl {
  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  constructor(e, t) {
    super({
      code: e,
      units: "degrees",
      extent: $h,
      axisOrientation: t,
      global: !0,
      metersPerUnit: Lg,
      worldExtent: $h
    });
  }
}
const Uh = [
  new Ui("CRS:84"),
  new Ui("EPSG:4326", "neu"),
  new Ui("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new Ui("urn:ogc:def:crs:OGC:2:84"),
  new Ui("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new Ui("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new Ui("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];
let Ra = {};
function bg(n) {
  return Ra[n] || Ra[n.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function Ag(n, e) {
  Ra[n] = e;
}
let bn = {};
function kr(n, e, t) {
  const i = n.getCode(), s = e.getCode();
  i in bn || (bn[i] = {}), bn[i][s] = t;
}
function Fg(n, e) {
  let t;
  return n in bn && e in bn[n] && (t = bn[n][e]), t;
}
const Re = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
function je(n) {
  const e = Je();
  for (let t = 0, i = n.length; t < i; ++t)
    ws(e, n[t]);
  return e;
}
function ot(n, e, t) {
  return t ? (t[0] = n[0] - e, t[1] = n[1] - e, t[2] = n[2] + e, t[3] = n[3] + e, t) : [
    n[0] - e,
    n[1] - e,
    n[2] + e,
    n[3] + e
  ];
}
function cu(n, e) {
  return e ? (e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e) : n.slice();
}
function tn(n, e, t) {
  let i, s;
  return e < n[0] ? i = n[0] - e : n[2] < e ? i = e - n[2] : i = 0, t < n[1] ? s = n[1] - t : n[3] < t ? s = t - n[3] : s = 0, i * i + s * s;
}
function Qi(n, e) {
  return rl(n, e[0], e[1]);
}
function rt(n, e) {
  return n[0] <= e[0] && e[2] <= n[2] && n[1] <= e[1] && e[3] <= n[3];
}
function rl(n, e, t) {
  return n[0] <= e && e <= n[2] && n[1] <= t && t <= n[3];
}
function Ia(n, e) {
  const t = n[0], i = n[1], s = n[2], r = n[3], o = e[0], a = e[1];
  let l = Re.UNKNOWN;
  return o < t ? l = l | Re.LEFT : o > s && (l = l | Re.RIGHT), a < i ? l = l | Re.BELOW : a > r && (l = l | Re.ABOVE), l === Re.UNKNOWN && (l = Re.INTERSECTING), l;
}
function Je() {
  return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
}
function ii(n, e, t, i, s) {
  return s ? (s[0] = n, s[1] = e, s[2] = t, s[3] = i, s) : [n, e, t, i];
}
function qs(n) {
  return ii(1 / 0, 1 / 0, -1 / 0, -1 / 0, n);
}
function Cs(n, e) {
  const t = n[0], i = n[1];
  return ii(t, i, t, i, e);
}
function ol(n, e, t, i, s) {
  const r = qs(s);
  return du(r, n, e, t, i);
}
function Mi(n, e) {
  return n[0] == e[0] && n[2] == e[2] && n[1] == e[1] && n[3] == e[3];
}
function uu(n, e) {
  return e[0] < n[0] && (n[0] = e[0]), e[2] > n[2] && (n[2] = e[2]), e[1] < n[1] && (n[1] = e[1]), e[3] > n[3] && (n[3] = e[3]), n;
}
function ws(n, e) {
  e[0] < n[0] && (n[0] = e[0]), e[0] > n[2] && (n[2] = e[0]), e[1] < n[1] && (n[1] = e[1]), e[1] > n[3] && (n[3] = e[1]);
}
function du(n, e, t, i, s) {
  for (; t < i; t += s)
    Mg(n, e[t], e[t + 1]);
  return n;
}
function Mg(n, e, t) {
  n[0] = Math.min(n[0], e), n[1] = Math.min(n[1], t), n[2] = Math.max(n[2], e), n[3] = Math.max(n[3], t);
}
function al(n, e) {
  let t;
  return t = e($n(n)), t || (t = e(qn(n)), t) || (t = e(Js(n)), t) || (t = e(kt(n)), t) ? t : !1;
}
function Pa(n) {
  let e = 0;
  return Jn(n) || (e = ie(n) * Te(n)), e;
}
function $n(n) {
  return [n[0], n[1]];
}
function qn(n) {
  return [n[2], n[1]];
}
function Ot(n) {
  return [(n[0] + n[2]) / 2, (n[1] + n[3]) / 2];
}
function Og(n, e) {
  let t;
  if (e === "bottom-left")
    t = $n(n);
  else if (e === "bottom-right")
    t = qn(n);
  else if (e === "top-left")
    t = kt(n);
  else if (e === "top-right")
    t = Js(n);
  else
    throw new Error("Invalid corner");
  return t;
}
function Ms(n, e, t, i, s) {
  const [r, o, a, l, h, c, u, d] = La(
    n,
    e,
    t,
    i
  );
  return ii(
    Math.min(r, a, h, u),
    Math.min(o, l, c, d),
    Math.max(r, a, h, u),
    Math.max(o, l, c, d),
    s
  );
}
function La(n, e, t, i) {
  const s = e * i[0] / 2, r = e * i[1] / 2, o = Math.cos(t), a = Math.sin(t), l = s * o, h = s * a, c = r * o, u = r * a, d = n[0], f = n[1];
  return [
    d - l + u,
    f - h - c,
    d - l - u,
    f - h + c,
    d + l - u,
    f + h + c,
    d + l + u,
    f + h - c,
    d - l + u,
    f - h - c
  ];
}
function Te(n) {
  return n[3] - n[1];
}
function qt(n, e, t) {
  const i = t || Je();
  return ye(n, e) ? (n[0] > e[0] ? i[0] = n[0] : i[0] = e[0], n[1] > e[1] ? i[1] = n[1] : i[1] = e[1], n[2] < e[2] ? i[2] = n[2] : i[2] = e[2], n[3] < e[3] ? i[3] = n[3] : i[3] = e[3]) : qs(i), i;
}
function kt(n) {
  return [n[0], n[3]];
}
function Js(n) {
  return [n[2], n[3]];
}
function ie(n) {
  return n[2] - n[0];
}
function ye(n, e) {
  return n[0] <= e[2] && n[2] >= e[0] && n[1] <= e[3] && n[3] >= e[1];
}
function Jn(n) {
  return n[2] < n[0] || n[3] < n[1];
}
function Dg(n, e) {
  return e ? (e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e) : n;
}
function Ng(n, e) {
  const t = (n[2] - n[0]) / 2 * (e - 1), i = (n[3] - n[1]) / 2 * (e - 1);
  n[0] -= t, n[2] += t, n[1] -= i, n[3] += i;
}
function kg(n, e, t) {
  let i = !1;
  const s = Ia(n, e), r = Ia(n, t);
  if (s === Re.INTERSECTING || r === Re.INTERSECTING)
    i = !0;
  else {
    const o = n[0], a = n[1], l = n[2], h = n[3], c = e[0], u = e[1], d = t[0], f = t[1], g = (f - u) / (d - c);
    let _, m;
    r & Re.ABOVE && !(s & Re.ABOVE) && (_ = d - (f - h) / g, i = _ >= o && _ <= l), !i && r & Re.RIGHT && !(s & Re.RIGHT) && (m = f - (d - l) * g, i = m >= a && m <= h), !i && r & Re.BELOW && !(s & Re.BELOW) && (_ = d - (f - a) / g, i = _ >= o && _ <= l), !i && r & Re.LEFT && !(s & Re.LEFT) && (m = f - (d - o) * g, i = m >= a && m <= h);
  }
  return i;
}
function fu(n, e) {
  const t = e.getExtent(), i = Ot(n);
  if (e.canWrapX() && (i[0] < t[0] || i[0] >= t[2])) {
    const s = ie(t), o = Math.floor(
      (i[0] - t[0]) / s
    ) * s;
    n[0] -= o, n[2] -= o;
  }
  return n;
}
function Gg(n, e) {
  if (e.canWrapX()) {
    const t = e.getExtent();
    if (!isFinite(n[0]) || !isFinite(n[2]))
      return [[t[0], n[1], t[2], n[3]]];
    fu(n, e);
    const i = ie(t);
    if (ie(n) > i)
      return [[t[0], n[1], t[2], n[3]]];
    if (n[0] < t[0])
      return [
        [n[0] + i, n[1], t[2], n[3]],
        [t[0], n[1], n[2], n[3]]
      ];
    if (n[2] > t[2])
      return [
        [n[0], n[1], t[2], n[3]],
        [t[0], n[1], n[2] - i, n[3]]
      ];
  }
  return [n];
}
function ll(n, e) {
  const t = ("" + n).split("."), i = ("" + e).split(".");
  for (let s = 0; s < Math.max(t.length, i.length); s++) {
    const r = parseInt(t[s] || "0", 10), o = parseInt(i[s] || "0", 10);
    if (r > o)
      return 1;
    if (o > r)
      return -1;
  }
  return 0;
}
function zg(n, e) {
  return n[0] += +e[0], n[1] += +e[1], n;
}
function gu(n, e) {
  const t = n[0], i = n[1], s = e[0], r = e[1], o = s[0], a = s[1], l = r[0], h = r[1], c = l - o, u = h - a, d = c === 0 && u === 0 ? 0 : (c * (t - o) + u * (i - a)) / (c * c + u * u || 0);
  let f, g;
  return d <= 0 ? (f = o, g = a) : d >= 1 ? (f = l, g = h) : (f = o + d * c, g = a + d * u), [f, g];
}
function nt(n, e) {
  let t = !0;
  for (let i = n.length - 1; i >= 0; --i)
    if (n[i] != e[i]) {
      t = !1;
      break;
    }
  return t;
}
function hl(n, e) {
  const t = Math.cos(e), i = Math.sin(e), s = n[0] * t - n[1] * i, r = n[1] * t + n[0] * i;
  return n[0] = s, n[1] = r, n;
}
function $g(n, e) {
  return n[0] *= e, n[1] *= e, n;
}
function Un(n, e) {
  const t = n[0] - e[0], i = n[1] - e[1];
  return t * t + i * i;
}
function Gr(n, e) {
  return Math.sqrt(Un(n, e));
}
function Ug(n, e) {
  return Un(n, gu(n, e));
}
function mo(n, e) {
  if (e.canWrapX()) {
    const t = ie(e.getExtent()), i = Vg(n, e, t);
    i && (n[0] -= i * t);
  }
  return n;
}
function Vg(n, e, t) {
  const i = e.getExtent();
  let s = 0;
  return e.canWrapX() && (n[0] < i[0] || n[0] > i[2]) && (t = t || ie(i), s = Math.floor(
    (n[0] - i[0]) / t
  )), s;
}
const cl = 63710088e-1;
function ba(n, e, t) {
  t = t || cl;
  const i = Li(n[1]), s = Li(e[1]), r = (s - i) / 2, o = Li(e[0] - n[0]) / 2, a = Math.sin(r) * Math.sin(r) + Math.sin(o) * Math.sin(o) * Math.cos(i) * Math.cos(s);
  return 2 * t * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
function Wo(n, e) {
  let t = 0;
  for (let i = 0, s = n.length; i < s - 1; ++i)
    t += ba(n[i], n[i + 1], e);
  return t;
}
function _u(n, e) {
  e = e || {};
  const t = e.radius || cl, i = e.projection || "EPSG:3857", s = n.getType();
  s !== "GeometryCollection" && (n = n.clone().transform(i, "EPSG:4326"));
  let r = 0, o, a, l, h, c, u;
  switch (s) {
    case "Point":
    case "MultiPoint":
      break;
    case "LineString":
    case "LinearRing": {
      o = /** @type {import("./geom/SimpleGeometry.js").default} */
      n.getCoordinates(), r = Wo(o, t);
      break;
    }
    case "MultiLineString":
    case "Polygon": {
      for (o = /** @type {import("./geom/SimpleGeometry.js").default} */
      n.getCoordinates(), l = 0, h = o.length; l < h; ++l)
        r += Wo(o[l], t);
      break;
    }
    case "MultiPolygon": {
      for (o = /** @type {import("./geom/SimpleGeometry.js").default} */
      n.getCoordinates(), l = 0, h = o.length; l < h; ++l)
        for (a = o[l], c = 0, u = a.length; c < u; ++c)
          r += Wo(a[c], t);
      break;
    }
    case "GeometryCollection": {
      const d = (
        /** @type {import("./geom/GeometryCollection.js").default} */
        n.getGeometries()
      );
      for (l = 0, h = d.length; l < h; ++l)
        r += _u(d[l], e);
      break;
    }
    default:
      throw new Error("Unsupported geometry type: " + s);
  }
  return r;
}
function _r(n, e) {
  let t = 0;
  const i = n.length;
  let s = n[i - 1][0], r = n[i - 1][1];
  for (let o = 0; o < i; o++) {
    const a = n[o][0], l = n[o][1];
    t += Li(a - s) * (2 + Math.sin(Li(r)) + Math.sin(Li(l))), s = a, r = l;
  }
  return t * e * e / 2;
}
function mu(n, e) {
  e = e || {};
  const t = e.radius || cl, i = e.projection || "EPSG:3857", s = n.getType();
  s !== "GeometryCollection" && (n = n.clone().transform(i, "EPSG:4326"));
  let r = 0, o, a, l, h, c, u;
  switch (s) {
    case "Point":
    case "MultiPoint":
    case "LineString":
    case "MultiLineString":
    case "LinearRing":
      break;
    case "Polygon": {
      for (o = /** @type {import("./geom/Polygon.js").default} */
      n.getCoordinates(), r = Math.abs(_r(o[0], t)), l = 1, h = o.length; l < h; ++l)
        r -= Math.abs(_r(o[l], t));
      break;
    }
    case "MultiPolygon": {
      for (o = /** @type {import("./geom/SimpleGeometry.js").default} */
      n.getCoordinates(), l = 0, h = o.length; l < h; ++l)
        for (a = o[l], r += Math.abs(_r(a[0], t)), c = 1, u = a.length; c < u; ++c)
          r -= Math.abs(_r(a[c], t));
      break;
    }
    case "GeometryCollection": {
      const d = (
        /** @type {import("./geom/GeometryCollection.js").default} */
        n.getGeometries()
      );
      for (l = 0, h = d.length; l < h; ++l)
        r += mu(d[l], e);
      break;
    }
    default:
      throw new Error("Unsupported geometry type: " + s);
  }
  return r;
}
const pu = {
  info: 1,
  warn: 2,
  error: 3,
  none: 4
};
let jg = pu.info;
function yu(...n) {
  jg > pu.warn || console.warn(...n);
}
let Aa = !0;
function xu(n) {
  Aa = !(n === void 0 ? !0 : n);
}
function ul(n, e) {
  if (e !== void 0) {
    for (let t = 0, i = n.length; t < i; ++t)
      e[t] = n[t];
    e = e;
  } else
    e = n.slice();
  return e;
}
function dl(n, e) {
  if (e !== void 0 && n !== e) {
    for (let t = 0, i = n.length; t < i; ++t)
      e[t] = n[t];
    n = e;
  }
  return n;
}
function Yg(n) {
  Ag(n.getCode(), n), kr(n, n, ul);
}
function Xg(n) {
  n.forEach(Yg);
}
function ce(n) {
  return typeof n == "string" ? bg(
    /** @type {string} */
    n
  ) : (
    /** @type {Projection} */
    n || null
  );
}
function zr(n, e, t, i) {
  n = ce(n);
  let s;
  const r = n.getPointResolutionFunc();
  if (r) {
    if (s = r(e, t), i && i !== n.getUnits()) {
      const o = n.getMetersPerUnit();
      o && (s = s * o / zn[i]);
    }
  } else {
    const o = n.getUnits();
    if (o == "degrees" && !i || i == "degrees")
      s = e;
    else {
      const a = Qs(
        n,
        ce("EPSG:4326")
      );
      if (a === dl && o !== "degrees")
        s = e * n.getMetersPerUnit();
      else {
        let h = [
          t[0] - e / 2,
          t[1],
          t[0] + e / 2,
          t[1],
          t[0],
          t[1] - e / 2,
          t[0],
          t[1] + e / 2
        ];
        h = a(h, h, 2);
        const c = ba(h.slice(0, 2), h.slice(2, 4)), u = ba(h.slice(4, 6), h.slice(6, 8));
        s = (c + u) / 2;
      }
      const l = i ? zn[i] : n.getMetersPerUnit();
      l !== void 0 && (s /= l);
    }
  }
  return s;
}
function Vh(n) {
  Xg(n), n.forEach(function(e) {
    n.forEach(function(t) {
      e !== t && kr(e, t, ul);
    });
  });
}
function Bg(n, e, t, i) {
  n.forEach(function(s) {
    e.forEach(function(r) {
      kr(s, r, t), kr(r, s, i);
    });
  });
}
function fl(n, e) {
  return n ? typeof n == "string" ? ce(n) : (
    /** @type {Projection} */
    n
  ) : ce(e);
}
function Wg(n, e) {
  return xu(), po(
    n,
    "EPSG:4326",
    e !== void 0 ? e : "EPSG:3857"
  );
}
function Zt(n, e) {
  if (n === e)
    return !0;
  const t = n.getUnits() === e.getUnits();
  return (n.getCode() === e.getCode() || Qs(n, e) === ul) && t;
}
function Qs(n, e) {
  const t = n.getCode(), i = e.getCode();
  let s = Fg(t, i);
  return s || (s = dl), s;
}
function Os(n, e) {
  const t = ce(n), i = ce(e);
  return Qs(t, i);
}
function po(n, e, t) {
  return Os(e, t)(n, void 0, n.length);
}
let Kg = null;
function Zg() {
  return Kg;
}
function Vn(n, e) {
  return n;
}
function pe(n, e) {
  return Aa && !nt(n, [0, 0]) && n[0] >= -180 && n[0] <= 180 && n[1] >= -90 && n[1] <= 90 && (Aa = !1, yu(
    "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
  )), n;
}
function yo(n, e) {
  return n;
}
function Et(n, e) {
  return n;
}
function Hg() {
  Vh(zh), Vh(Uh), Bg(
    Uh,
    zh,
    Rg,
    Ig
  );
}
Hg();
function jh(n, e, t) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function(i, s, r, o, a) {
      if (!i)
        return;
      if (!s && !e)
        return i;
      const l = e ? 0 : r[0] * s, h = e ? 0 : r[1] * s, c = a ? a[0] : 0, u = a ? a[1] : 0;
      let d = n[0] + l / 2 + c, f = n[2] - l / 2 + c, g = n[1] + h / 2 + u, _ = n[3] - h / 2 + u;
      d > f && (d = (f + d) / 2, f = d), g > _ && (g = (_ + g) / 2, _ = g);
      let m = _e(i[0], d, f), p = _e(i[1], g, _);
      if (o && t && s) {
        const y = 30 * s;
        m += -y * Math.log(1 + Math.max(0, d - i[0]) / y) + y * Math.log(1 + Math.max(0, i[0] - f) / y), p += -y * Math.log(1 + Math.max(0, g - i[1]) / y) + y * Math.log(1 + Math.max(0, i[1] - _) / y);
      }
      return [m, p];
    }
  );
}
function qg(n) {
  return n;
}
function gl(n, e, t, i) {
  const s = ie(e) / t[0], r = Te(e) / t[1];
  return i ? Math.min(n, Math.max(s, r)) : Math.min(n, Math.min(s, r));
}
function _l(n, e, t) {
  let i = Math.min(n, e);
  const s = 50;
  return i *= Math.log(1 + s * Math.max(0, n / e - 1)) / s + 1, t && (i = Math.max(i, t), i /= Math.log(1 + s * Math.max(0, t / n - 1)) / s + 1), _e(i, t / 2, e * 2);
}
function Jg(n, e, t, i) {
  return e = e !== void 0 ? e : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(s, r, o, a) {
    if (s !== void 0) {
      const l = n[0], h = n[n.length - 1], c = t ? gl(
        l,
        t,
        o,
        i
      ) : l;
      if (a)
        return e ? _l(
          s,
          c,
          h
        ) : _e(s, h, c);
      const u = Math.min(c, s), d = Math.floor(go(n, u, r));
      return n[d] > c && d < n.length - 1 ? n[d + 1] : n[d];
    }
  };
}
function Qg(n, e, t, i, s, r) {
  return i = i !== void 0 ? i : !0, t = t !== void 0 ? t : 0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(o, a, l, h) {
    if (o !== void 0) {
      const c = s ? gl(
        e,
        s,
        l,
        r
      ) : e;
      if (h)
        return i ? _l(
          o,
          c,
          t
        ) : _e(o, t, c);
      const u = 1e-9, d = Math.ceil(
        Math.log(e / c) / Math.log(n) - u
      ), f = -a * (0.5 - u) + 0.5, g = Math.min(c, o), _ = Math.floor(
        Math.log(e / g) / Math.log(n) + f
      ), m = Math.max(d, _), p = e / Math.pow(n, m);
      return _e(p, t, c);
    }
  };
}
function Yh(n, e, t, i, s) {
  return t = t !== void 0 ? t : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(r, o, a, l) {
    if (r !== void 0) {
      const h = i ? gl(
        n,
        i,
        a,
        s
      ) : n;
      return !t || !l ? _e(r, e, h) : _l(
        r,
        h,
        e
      );
    }
  };
}
function ml(n) {
  if (n !== void 0)
    return 0;
}
function Xh(n) {
  if (n !== void 0)
    return n;
}
function e_(n) {
  const e = 2 * Math.PI / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(t, i) {
      if (i)
        return t;
      if (t !== void 0)
        return t = Math.floor(t / e + 0.5) * e, t;
    }
  );
}
function t_(n) {
  const e = n === void 0 ? Li(5) : n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(t, i) {
      return i || t === void 0 ? t : Math.abs(t) <= e ? 0 : t;
    }
  );
}
function Eu(n) {
  return Math.pow(n, 3);
}
function nn(n) {
  return 1 - Eu(1 - n);
}
function i_(n) {
  return 3 * n * n - 2 * n * n * n;
}
function n_(n) {
  return n;
}
const Cu = new Array(6);
function at() {
  return [1, 0, 0, 1, 0, 0];
}
function Bh(n) {
  return xo(n, 1, 0, 0, 1, 0, 0);
}
function pl(n, e) {
  const t = n[0], i = n[1], s = n[2], r = n[3], o = n[4], a = n[5], l = e[0], h = e[1], c = e[2], u = e[3], d = e[4], f = e[5];
  return n[0] = t * l + s * h, n[1] = i * l + r * h, n[2] = t * c + s * u, n[3] = i * c + r * u, n[4] = t * d + s * f + o, n[5] = i * d + r * f + a, n;
}
function xo(n, e, t, i, s, r, o) {
  return n[0] = e, n[1] = t, n[2] = i, n[3] = s, n[4] = r, n[5] = o, n;
}
function s_(n, e) {
  return n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[4] = e[4], n[5] = e[5], n;
}
function Se(n, e) {
  const t = e[0], i = e[1];
  return e[0] = n[0] * t + n[2] * i + n[4], e[1] = n[1] * t + n[3] * i + n[5], e;
}
function Ko(n, e, t) {
  return pl(n, xo(Cu, e, 0, 0, t, 0, 0));
}
function r_(n, e, t) {
  return xo(n, e, 0, 0, t, 0, 0);
}
function o_(n, e, t) {
  return pl(n, xo(Cu, 1, 0, 0, 1, e, t));
}
function wt(n, e, t, i, s, r, o, a) {
  const l = Math.sin(r), h = Math.cos(r);
  return n[0] = i * h, n[1] = s * l, n[2] = -i * l, n[3] = s * h, n[4] = o * i * h - a * i * l + e, n[5] = o * s * l + a * s * h + t, n;
}
function Eo(n, e) {
  const t = a_(e);
  Q(t !== 0, "Transformation matrix cannot be inverted");
  const i = e[0], s = e[1], r = e[2], o = e[3], a = e[4], l = e[5];
  return n[0] = o / t, n[1] = -s / t, n[2] = -r / t, n[3] = i / t, n[4] = (r * l - o * a) / t, n[5] = -(i * l - s * a) / t, n;
}
function a_(n) {
  return n[0] * n[3] - n[1] * n[2];
}
const Wh = [1e6, 1e6, 1e6, 1e6, 2, 2];
function yl(n) {
  return "matrix(" + n.map(
    (t, i) => Math.round(t * Wh[i]) / Wh[i]
  ).join(", ") + ")";
}
function bi(n, e, t, i, s, r) {
  r = r || [];
  let o = 0;
  for (let a = e; a < t; a += i) {
    const l = n[a], h = n[a + 1];
    r[o++] = s[0] * l + s[2] * h + s[4], r[o++] = s[1] * l + s[3] * h + s[5];
  }
  return r && r.length != o && (r.length = o), r;
}
function xl(n, e, t, i, s, r, o) {
  o = o || [];
  const a = Math.cos(s), l = Math.sin(s), h = r[0], c = r[1];
  let u = 0;
  for (let d = e; d < t; d += i) {
    const f = n[d] - h, g = n[d + 1] - c;
    o[u++] = h + f * a - g * l, o[u++] = c + f * l + g * a;
    for (let _ = d + 2; _ < d + i; ++_)
      o[u++] = n[_];
  }
  return o && o.length != u && (o.length = u), o;
}
function l_(n, e, t, i, s, r, o, a) {
  a = a || [];
  const l = o[0], h = o[1];
  let c = 0;
  for (let u = e; u < t; u += i) {
    const d = n[u] - l, f = n[u + 1] - h;
    a[c++] = l + s * d, a[c++] = h + r * f;
    for (let g = u + 2; g < u + i; ++g)
      a[c++] = n[g];
  }
  return a && a.length != c && (a.length = c), a;
}
function h_(n, e, t, i, s, r, o) {
  o = o || [];
  let a = 0;
  for (let l = e; l < t; l += i) {
    o[a++] = n[l] + s, o[a++] = n[l + 1] + r;
    for (let h = l + 2; h < l + i; ++h)
      o[a++] = n[h];
  }
  return o && o.length != a && (o.length = a), o;
}
const Kh = at();
class c_ extends vt {
  constructor() {
    super(), this.extent_ = Je(), this.extentRevision_ = -1, this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = 0, this.simplifyTransformedInternal = ou(
      (e, t, i) => {
        if (!i)
          return this.getSimplifiedGeometry(t);
        const s = this.clone();
        return s.applyTransform(i), s.getSimplifiedGeometry(t);
      }
    );
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */
  simplifyTransformed(e, t) {
    return this.simplifyTransformedInternal(
      this.getRevision(),
      e,
      t
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */
  clone() {
    return B();
  }
  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, i, s) {
    return B();
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    const i = this.getClosestPoint([e, t]);
    return i[0] === e && i[1] === t;
  }
  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */
  getClosestPoint(e, t) {
    return t = t || [NaN, NaN], this.closestPointXY(e[0], e[1], t, 1 / 0), t;
  }
  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  intersectsCoordinate(e) {
    return this.containsXY(e[0], e[1]);
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    return B();
  }
  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */
  getExtent(e) {
    if (this.extentRevision_ != this.getRevision()) {
      const t = this.computeExtent(this.extent_);
      (isNaN(t[0]) || isNaN(t[1])) && qs(t), this.extentRevision_ = this.getRevision();
    }
    return Dg(this.extent_, e);
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, t) {
    B();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(e, t, i) {
    B();
  }
  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */
  simplify(e) {
    return this.getSimplifiedGeometry(e * e);
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */
  getSimplifiedGeometry(e) {
    return B();
  }
  /**
   * Get the type of this geometry.
   * @abstract
   * @return {Type} Geometry type.
   */
  getType() {
    return B();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */
  applyTransform(e) {
    B();
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  intersectsExtent(e) {
    return B();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(e, t) {
    B();
  }
  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {this} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  transform(e, t) {
    const i = ce(e), s = i.getUnits() == "tile-pixels" ? function(r, o, a) {
      const l = i.getExtent(), h = i.getWorldExtent(), c = Te(h) / Te(l);
      return wt(
        Kh,
        h[0],
        h[3],
        c,
        -c,
        0,
        0,
        0
      ), bi(
        r,
        0,
        r.length,
        a,
        Kh,
        o
      ), Os(i, t)(
        r,
        o,
        a
      );
    } : Os(i, t);
    return this.applyTransform(s), this;
  }
}
const wu = c_;
class ki extends wu {
  constructor() {
    super(), this.layout = "XY", this.stride = 2, this.flatCoordinates;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    return ol(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e
    );
  }
  /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */
  getCoordinates() {
    return B();
  }
  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */
  getFirstCoordinate() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getFlatCoordinates() {
    return this.flatCoordinates;
  }
  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */
  getLastCoordinate() {
    return this.flatCoordinates.slice(
      this.flatCoordinates.length - this.stride
    );
  }
  /**
   * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
   * @return {import("./Geometry.js").GeometryLayout} Layout.
   * @api
   */
  getLayout() {
    return this.layout;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   */
  getSimplifiedGeometry(e) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), e < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && e <= this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const t = this.getSimplifiedGeometryInternal(e);
    return t.getFlatCoordinates().length < this.flatCoordinates.length ? t : (this.simplifiedGeometryMaxMinSquaredTolerance = e, this);
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    return this;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride;
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */
  setFlatCoordinates(e, t) {
    this.stride = $r(e), this.layout = e, this.flatCoordinates = t;
  }
  /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  setCoordinates(e, t) {
    B();
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  setLayout(e, t, i) {
    let s;
    if (e)
      s = $r(e);
    else {
      for (let r = 0; r < i; ++r) {
        if (t.length === 0) {
          this.layout = "XY", this.stride = 2;
          return;
        }
        t = /** @type {Array<unknown>} */
        t[0];
      }
      s = t.length, e = sn(s);
    }
    this.layout = e, this.stride = s;
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */
  applyTransform(e) {
    this.flatCoordinates && (e(this.flatCoordinates, this.flatCoordinates, this.stride), this.changed());
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, t) {
    const i = this.getFlatCoordinates();
    if (i) {
      const s = this.getStride();
      xl(
        i,
        0,
        i.length,
        s,
        e,
        t,
        i
      ), this.changed();
    }
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(e, t, i) {
    t === void 0 && (t = e), i || (i = Ot(this.getExtent()));
    const s = this.getFlatCoordinates();
    if (s) {
      const r = this.getStride();
      l_(
        s,
        0,
        s.length,
        r,
        e,
        t,
        i,
        s
      ), this.changed();
    }
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(e, t) {
    const i = this.getFlatCoordinates();
    if (i) {
      const s = this.getStride();
      h_(
        i,
        0,
        i.length,
        s,
        e,
        t,
        i
      ), this.changed();
    }
  }
}
function sn(n) {
  let e;
  return n == 2 ? e = "XY" : n == 3 ? e = "XYZ" : n == 4 && (e = "XYZM"), /** @type {import("./Geometry.js").GeometryLayout} */
  e;
}
function $r(n) {
  let e;
  return n == "XY" ? e = 2 : n == "XYZ" || n == "XYM" ? e = 3 : n == "XYZM" && (e = 4), /** @type {number} */
  e;
}
function u_(n, e, t) {
  const i = n.getFlatCoordinates();
  if (!i)
    return null;
  const s = n.getStride();
  return bi(
    i,
    0,
    i.length,
    s,
    e,
    t
  );
}
function Zh(n, e, t, i, s, r, o) {
  const a = n[e], l = n[e + 1], h = n[t] - a, c = n[t + 1] - l;
  let u;
  if (h === 0 && c === 0)
    u = e;
  else {
    const d = ((s - a) * h + (r - l) * c) / (h * h + c * c);
    if (d > 1)
      u = t;
    else if (d > 0) {
      for (let f = 0; f < i; ++f)
        o[f] = He(
          n[e + f],
          n[t + f],
          d
        );
      o.length = i;
      return;
    } else
      u = e;
  }
  for (let d = 0; d < i; ++d)
    o[d] = n[u + d];
  o.length = i;
}
function El(n, e, t, i, s) {
  let r = n[e], o = n[e + 1];
  for (e += i; e < t; e += i) {
    const a = n[e], l = n[e + 1], h = Ht(r, o, a, l);
    h > s && (s = h), r = a, o = l;
  }
  return s;
}
function Cl(n, e, t, i, s) {
  for (let r = 0, o = t.length; r < o; ++r) {
    const a = t[r];
    s = El(n, e, a, i, s), e = a;
  }
  return s;
}
function d_(n, e, t, i, s) {
  for (let r = 0, o = t.length; r < o; ++r) {
    const a = t[r];
    s = Cl(n, e, a, i, s), e = a[a.length - 1];
  }
  return s;
}
function wl(n, e, t, i, s, r, o, a, l, h, c) {
  if (e == t)
    return h;
  let u, d;
  if (s === 0) {
    if (d = Ht(
      o,
      a,
      n[e],
      n[e + 1]
    ), d < h) {
      for (u = 0; u < i; ++u)
        l[u] = n[e + u];
      return l.length = i, d;
    }
    return h;
  }
  c = c || [NaN, NaN];
  let f = e + i;
  for (; f < t; )
    if (Zh(
      n,
      f - i,
      f,
      i,
      o,
      a,
      c
    ), d = Ht(o, a, c[0], c[1]), d < h) {
      for (h = d, u = 0; u < i; ++u)
        l[u] = c[u];
      l.length = i, f += i;
    } else
      f += i * Math.max(
        (Math.sqrt(d) - Math.sqrt(h)) / s | 0,
        1
      );
  if (r && (Zh(
    n,
    t - i,
    e,
    i,
    o,
    a,
    c
  ), d = Ht(o, a, c[0], c[1]), d < h)) {
    for (h = d, u = 0; u < i; ++u)
      l[u] = c[u];
    l.length = i;
  }
  return h;
}
function Sl(n, e, t, i, s, r, o, a, l, h, c) {
  c = c || [NaN, NaN];
  for (let u = 0, d = t.length; u < d; ++u) {
    const f = t[u];
    h = wl(
      n,
      e,
      f,
      i,
      s,
      r,
      o,
      a,
      l,
      h,
      c
    ), e = f;
  }
  return h;
}
function f_(n, e, t, i, s, r, o, a, l, h, c) {
  c = c || [NaN, NaN];
  for (let u = 0, d = t.length; u < d; ++u) {
    const f = t[u];
    h = Sl(
      n,
      e,
      f,
      i,
      s,
      r,
      o,
      a,
      l,
      h,
      c
    ), e = f[f.length - 1];
  }
  return h;
}
function Su(n, e, t, i) {
  for (let s = 0, r = t.length; s < r; ++s)
    n[e++] = t[s];
  return e;
}
function Co(n, e, t, i) {
  for (let s = 0, r = t.length; s < r; ++s) {
    const o = t[s];
    for (let a = 0; a < i; ++a)
      n[e++] = o[a];
  }
  return e;
}
function er(n, e, t, i, s) {
  s = s || [];
  let r = 0;
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = Co(
      n,
      e,
      t[o],
      i
    );
    s[r++] = l, e = l;
  }
  return s.length = r, s;
}
function vu(n, e, t, i, s) {
  s = s || [];
  let r = 0;
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = er(
      n,
      e,
      t[o],
      i,
      s[r]
    );
    l.length === 0 && (l[0] = e), s[r++] = l, e = l[l.length - 1];
  }
  return s.length = r, s;
}
function wo(n, e, t, i, s, r, o) {
  const a = (t - e) / i;
  if (a < 3) {
    for (; e < t; e += i)
      r[o++] = n[e], r[o++] = n[e + 1];
    return o;
  }
  const l = new Array(a);
  l[0] = 1, l[a - 1] = 1;
  const h = [e, t - i];
  let c = 0;
  for (; h.length > 0; ) {
    const u = h.pop(), d = h.pop();
    let f = 0;
    const g = n[d], _ = n[d + 1], m = n[u], p = n[u + 1];
    for (let y = d + i; y < u; y += i) {
      const x = n[y], E = n[y + 1], C = Eg(x, E, g, _, m, p);
      C > f && (c = y, f = C);
    }
    f > s && (l[(c - e) / i] = 1, d + i < c && h.push(d, c), c + i < u && h.push(c, u));
  }
  for (let u = 0; u < a; ++u)
    l[u] && (r[o++] = n[e + u * i], r[o++] = n[e + u * i + 1]);
  return o;
}
function Tu(n, e, t, i, s, r, o, a) {
  for (let l = 0, h = t.length; l < h; ++l) {
    const c = t[l];
    o = wo(
      n,
      e,
      c,
      i,
      s,
      r,
      o
    ), a.push(o), e = c;
  }
  return o;
}
function ji(n, e) {
  return e * Math.round(n / e);
}
function g_(n, e, t, i, s, r, o) {
  if (e == t)
    return o;
  let a = ji(n[e], s), l = ji(n[e + 1], s);
  e += i, r[o++] = a, r[o++] = l;
  let h, c;
  do
    if (h = ji(n[e], s), c = ji(n[e + 1], s), e += i, e == t)
      return r[o++] = h, r[o++] = c, o;
  while (h == a && c == l);
  for (; e < t; ) {
    const u = ji(n[e], s), d = ji(n[e + 1], s);
    if (e += i, u == h && d == c)
      continue;
    const f = h - a, g = c - l, _ = u - a, m = d - l;
    if (f * m == g * _ && (f < 0 && _ < f || f == _ || f > 0 && _ > f) && (g < 0 && m < g || g == m || g > 0 && m > g)) {
      h = u, c = d;
      continue;
    }
    r[o++] = h, r[o++] = c, a = h, l = c, h = u, c = d;
  }
  return r[o++] = h, r[o++] = c, o;
}
function vl(n, e, t, i, s, r, o, a) {
  for (let l = 0, h = t.length; l < h; ++l) {
    const c = t[l];
    o = g_(
      n,
      e,
      c,
      i,
      s,
      r,
      o
    ), a.push(o), e = c;
  }
  return o;
}
function __(n, e, t, i, s, r, o, a) {
  for (let l = 0, h = t.length; l < h; ++l) {
    const c = t[l], u = [];
    o = vl(
      n,
      e,
      c,
      i,
      s,
      r,
      o,
      u
    ), a.push(u), e = c[c.length - 1];
  }
  return o;
}
function Ei(n, e, t, i, s) {
  s = s !== void 0 ? s : [];
  let r = 0;
  for (let o = e; o < t; o += i)
    s[r++] = n.slice(o, o + i);
  return s.length = r, s;
}
function Ds(n, e, t, i, s) {
  s = s !== void 0 ? s : [];
  let r = 0;
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = t[o];
    s[r++] = Ei(
      n,
      e,
      l,
      i,
      s[r]
    ), e = l;
  }
  return s.length = r, s;
}
function Fa(n, e, t, i, s) {
  s = s !== void 0 ? s : [];
  let r = 0;
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = t[o];
    s[r++] = l.length === 1 && l[0] === e ? [] : Ds(
      n,
      e,
      l,
      i,
      s[r]
    ), e = l[l.length - 1];
  }
  return s.length = r, s;
}
function Ru(n, e, t, i) {
  let s = 0, r = n[t - i], o = n[t - i + 1];
  for (; e < t; e += i) {
    const a = n[e], l = n[e + 1];
    s += o * a - r * l, r = a, o = l;
  }
  return s / 2;
}
function Iu(n, e, t, i) {
  let s = 0;
  for (let r = 0, o = t.length; r < o; ++r) {
    const a = t[r];
    s += Ru(n, e, a, i), e = a;
  }
  return s;
}
function m_(n, e, t, i) {
  let s = 0;
  for (let r = 0, o = t.length; r < o; ++r) {
    const a = t[r];
    s += Iu(n, e, a, i), e = a[a.length - 1];
  }
  return s;
}
class Ur extends ki {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, t !== void 0 && !Array.isArray(e[0]) ? this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      e,
      t
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   */
  clone() {
    return new Ur(this.flatCoordinates.slice(), this.layout);
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, i, s) {
    return s < tn(this.getExtent(), e, t) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      El(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), wl(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !0,
      e,
      t,
      i,
      s
    ));
  }
  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return Ru(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return Ei(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [];
    return t.length = wo(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t,
      0
    ), new Ur(t, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "LinearRing";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return !1;
  }
  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Co(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
}
const Hh = Ur;
class Tl extends ki {
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), this.setCoordinates(e, t);
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   */
  clone() {
    const e = new Tl(this.flatCoordinates.slice(), this.layout);
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, i, s) {
    const r = this.flatCoordinates, o = Ht(
      e,
      t,
      r[0],
      r[1]
    );
    if (o < s) {
      const a = this.stride;
      for (let l = 0; l < a; ++l)
        i[l] = r[l];
      return i.length = a, o;
    }
    return s;
  }
  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   */
  getCoordinates() {
    return this.flatCoordinates.slice();
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    return Cs(this.flatCoordinates, e);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Point";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return rl(e, this.flatCoordinates[0], this.flatCoordinates[1]);
  }
  /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Su(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
}
const lt = Tl;
function p_(n, e, t, i, s) {
  return !al(
    s,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(o) {
      return !Xi(
        n,
        e,
        t,
        i,
        o[0],
        o[1]
      );
    }
  );
}
function Xi(n, e, t, i, s, r) {
  let o = 0, a = n[t - i], l = n[t - i + 1];
  for (; e < t; e += i) {
    const h = n[e], c = n[e + 1];
    l <= r ? c > r && (h - a) * (r - l) - (s - a) * (c - l) > 0 && o++ : c <= r && (h - a) * (r - l) - (s - a) * (c - l) < 0 && o--, a = h, l = c;
  }
  return o !== 0;
}
function Rl(n, e, t, i, s, r) {
  if (t.length === 0 || !Xi(n, e, t[0], i, s, r))
    return !1;
  for (let o = 1, a = t.length; o < a; ++o)
    if (Xi(n, t[o - 1], t[o], i, s, r))
      return !1;
  return !0;
}
function y_(n, e, t, i, s, r) {
  if (t.length === 0)
    return !1;
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = t[o];
    if (Rl(n, e, l, i, s, r))
      return !0;
    e = l[l.length - 1];
  }
  return !1;
}
function Il(n, e, t, i, s, r, o) {
  let a, l, h, c, u, d, f;
  const g = s[r + 1], _ = [];
  for (let y = 0, x = t.length; y < x; ++y) {
    const E = t[y];
    for (c = n[E - i], d = n[E - i + 1], a = e; a < E; a += i)
      u = n[a], f = n[a + 1], (g <= d && f <= g || d <= g && g <= f) && (h = (g - d) / (f - d) * (u - c) + c, _.push(h)), c = u, d = f;
  }
  let m = NaN, p = -1 / 0;
  for (_.sort(ti), c = _[0], a = 1, l = _.length; a < l; ++a) {
    u = _[a];
    const y = Math.abs(u - c);
    y > p && (h = (c + u) / 2, Rl(n, e, t, i, h, g) && (m = h, p = y)), c = u;
  }
  return isNaN(m) && (m = s[r]), o ? (o.push(m, g, p), o) : [m, g, p];
}
function Pu(n, e, t, i, s) {
  let r = [];
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = t[o];
    r = Il(
      n,
      e,
      l,
      i,
      s,
      2 * o,
      r
    ), e = l[l.length - 1];
  }
  return r;
}
function Lu(n, e, t, i, s) {
  let r;
  for (e += i; e < t; e += i)
    if (r = s(
      n.slice(e - i, e),
      n.slice(e, e + i)
    ), r)
      return r;
  return !1;
}
function So(n, e, t, i, s) {
  const r = du(
    Je(),
    n,
    e,
    t,
    i
  );
  return ye(s, r) ? rt(s, r) || r[0] >= s[0] && r[2] <= s[2] || r[1] >= s[1] && r[3] <= s[3] ? !0 : Lu(
    n,
    e,
    t,
    i,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(o, a) {
      return kg(s, o, a);
    }
  ) : !1;
}
function x_(n, e, t, i, s) {
  for (let r = 0, o = t.length; r < o; ++r) {
    if (So(n, e, t[r], i, s))
      return !0;
    e = t[r];
  }
  return !1;
}
function bu(n, e, t, i, s) {
  return !!(So(n, e, t, i, s) || Xi(
    n,
    e,
    t,
    i,
    s[0],
    s[1]
  ) || Xi(
    n,
    e,
    t,
    i,
    s[0],
    s[3]
  ) || Xi(
    n,
    e,
    t,
    i,
    s[2],
    s[1]
  ) || Xi(
    n,
    e,
    t,
    i,
    s[2],
    s[3]
  ));
}
function Au(n, e, t, i, s) {
  if (!bu(n, e, t[0], i, s))
    return !1;
  if (t.length === 1)
    return !0;
  for (let r = 1, o = t.length; r < o; ++r)
    if (p_(
      n,
      t[r - 1],
      t[r],
      i,
      s
    ) && !So(
      n,
      t[r - 1],
      t[r],
      i,
      s
    ))
      return !1;
  return !0;
}
function E_(n, e, t, i, s) {
  for (let r = 0, o = t.length; r < o; ++r) {
    const a = t[r];
    if (Au(n, e, a, i, s))
      return !0;
    e = a[a.length - 1];
  }
  return !1;
}
function C_(n, e, t, i) {
  for (; e < t - i; ) {
    for (let s = 0; s < i; ++s) {
      const r = n[e + s];
      n[e + s] = n[t - i + s], n[t - i + s] = r;
    }
    e += i, t -= i;
  }
}
function Pl(n, e, t, i) {
  let s = 0, r = n[t - i], o = n[t - i + 1];
  for (; e < t; e += i) {
    const a = n[e], l = n[e + 1];
    s += (a - r) * (l + o), r = a, o = l;
  }
  return s === 0 ? void 0 : s > 0;
}
function Ll(n, e, t, i, s) {
  s = s !== void 0 ? s : !1;
  for (let r = 0, o = t.length; r < o; ++r) {
    const a = t[r], l = Pl(
      n,
      e,
      a,
      i
    );
    if (r === 0) {
      if (s && l || !s && !l)
        return !1;
    } else if (s && !l || !s && l)
      return !1;
    e = a;
  }
  return !0;
}
function Fu(n, e, t, i, s) {
  for (let r = 0, o = t.length; r < o; ++r) {
    const a = t[r];
    if (!Ll(n, e, a, i, s))
      return !1;
    a.length && (e = a[a.length - 1]);
  }
  return !0;
}
function Vr(n, e, t, i, s) {
  s = s !== void 0 ? s : !1;
  for (let r = 0, o = t.length; r < o; ++r) {
    const a = t[r], l = Pl(
      n,
      e,
      a,
      i
    );
    (r === 0 ? s && l || !s && !l : s && !l || !s && l) && C_(n, e, a, i), e = a;
  }
  return e;
}
function Ma(n, e, t, i, s) {
  for (let r = 0, o = t.length; r < o; ++r)
    e = Vr(
      n,
      e,
      t[r],
      i,
      s
    );
  return e;
}
function Mu(n, e) {
  const t = [];
  let i = 0, s = 0, r;
  for (let o = 0, a = e.length; o < a; ++o) {
    const l = e[o], h = Pl(n, i, l, 2);
    if (r === void 0 && (r = h), h === r)
      t.push(e.slice(s, o + 1));
    else {
      if (t.length === 0)
        continue;
      t[t.length - 1].push(e[s]);
    }
    s = o + 1, i = l;
  }
  return t;
}
class Ne extends ki {
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */
  constructor(e, t, i) {
    super(), this.ends_ = [], this.flatInteriorPointRevision_ = -1, this.flatInteriorPoint_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, t !== void 0 && i ? (this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ), this.ends_ = i) : this.setCoordinates(
      /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
      e,
      t
    );
  }
  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */
  appendLinearRing(e) {
    this.flatCoordinates ? se(this.flatCoordinates, e.getFlatCoordinates()) : this.flatCoordinates = e.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   */
  clone() {
    const e = new Ne(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, i, s) {
    return s < tn(this.getExtent(), e, t) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      Cl(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), Sl(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !0,
      e,
      t,
      i,
      s
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    return Rl(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      e,
      t
    );
  }
  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return Iu(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates(e) {
    let t;
    return e !== void 0 ? (t = this.getOrientedFlatCoordinates().slice(), Vr(t, 0, this.ends_, this.stride, e)) : t = this.flatCoordinates, Ds(t, 0, this.ends_, this.stride);
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * @return {Array<number>} Interior point.
   */
  getFlatInteriorPoint() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      const e = Ot(this.getExtent());
      this.flatInteriorPoint_ = Il(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        e,
        0
      ), this.flatInteriorPointRevision_ = this.getRevision();
    }
    return (
      /** @type {import("../coordinate.js").Coordinate} */
      this.flatInteriorPoint_
    );
  }
  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoint() {
    return new lt(this.getFlatInteriorPoint(), "XYM");
  }
  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */
  getLinearRingCount() {
    return this.ends_.length;
  }
  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */
  getLinearRing(e) {
    return e < 0 || this.ends_.length <= e ? null : new Hh(
      this.flatCoordinates.slice(
        e === 0 ? 0 : this.ends_[e - 1],
        this.ends_[e]
      ),
      this.layout
    );
  }
  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */
  getLinearRings() {
    const e = this.layout, t = this.flatCoordinates, i = this.ends_, s = [];
    let r = 0;
    for (let o = 0, a = i.length; o < a; ++o) {
      const l = i[o], h = new Hh(
        t.slice(r, l),
        e
      );
      s.push(h), r = l;
    }
    return s;
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const e = this.flatCoordinates;
      Ll(e, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = e : (this.orientedFlatCoordinates_ = e.slice(), this.orientedFlatCoordinates_.length = Vr(
        this.orientedFlatCoordinates_,
        0,
        this.ends_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.orientedFlatCoordinates_
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [], i = [];
    return t.length = vl(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      Math.sqrt(e),
      t,
      0,
      i
    ), new Ne(t, "XY", i);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Polygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return Au(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const i = er(
      this.flatCoordinates,
      0,
      e,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = i.length === 0 ? 0 : i[i.length - 1], this.changed();
  }
}
function jr(n) {
  if (Jn(n))
    throw new Error("Cannot create polygon from empty extent");
  const e = n[0], t = n[1], i = n[2], s = n[3], r = [
    e,
    t,
    e,
    s,
    i,
    s,
    i,
    t,
    e,
    t
  ];
  return new Ne(r, "XY", [r.length]);
}
const Zo = 0;
class w_ extends vt {
  /**
   * @param {ViewOptions} [options] View options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e = Object.assign({}, e), this.hints_ = [0, 0], this.animations_ = [], this.updateAnimationKey_, this.projection_ = fl(e.projection, "EPSG:3857"), this.viewportSize_ = [100, 100], this.targetCenter_ = null, this.targetResolution_, this.targetRotation_, this.nextCenter_ = null, this.nextResolution_, this.nextRotation_, this.cancelAnchor_ = void 0, e.projection && xu(), e.center && (e.center = pe(e.center, this.projection_)), e.extent && (e.extent = Et(e.extent, this.projection_)), this.applyOptions_(e);
  }
  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */
  applyOptions_(e) {
    const t = Object.assign({}, e);
    for (const a in Ke)
      delete t[a];
    this.setProperties(t, !0);
    const i = v_(e);
    this.maxResolution_ = i.maxResolution, this.minResolution_ = i.minResolution, this.zoomFactor_ = i.zoomFactor, this.resolutions_ = e.resolutions, this.padding_ = e.padding, this.minZoom_ = i.minZoom;
    const s = S_(e), r = i.constraint, o = T_(e);
    this.constraints_ = {
      center: s,
      resolution: r,
      rotation: o
    }, this.setRotation(e.rotation !== void 0 ? e.rotation : 0), this.setCenterInternal(
      e.center !== void 0 ? e.center : null
    ), e.resolution !== void 0 ? this.setResolution(e.resolution) : e.zoom !== void 0 && this.setZoom(e.zoom);
  }
  /**
   * Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from that
   * content. The order of the values in the array is top, right, bottom, left.
   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
   * @type {Array<number>|undefined}
   * @api
   */
  get padding() {
    return this.padding_;
  }
  set padding(e) {
    let t = this.padding_;
    this.padding_ = e;
    const i = this.getCenterInternal();
    if (i) {
      const s = e || [0, 0, 0, 0];
      t = t || [0, 0, 0, 0];
      const r = this.getResolution(), o = r / 2 * (s[3] - t[3] + t[1] - s[1]), a = r / 2 * (s[0] - t[0] + t[2] - s[2]);
      this.setCenterInternal([i[0] + o, i[1] - a]);
    }
  }
  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */
  getUpdatedOptions_(e) {
    const t = this.getProperties();
    return t.resolution !== void 0 ? t.resolution = this.getResolution() : t.zoom = this.getZoom(), t.center = this.getCenterInternal(), t.rotation = this.getRotation(), Object.assign({}, t, e);
  }
  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */
  animate(e) {
    this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
    const t = new Array(arguments.length);
    for (let i = 0; i < t.length; ++i) {
      let s = arguments[i];
      s.center && (s = Object.assign({}, s), s.center = pe(
        s.center,
        this.getProjection()
      )), s.anchor && (s = Object.assign({}, s), s.anchor = pe(
        s.anchor,
        this.getProjection()
      )), t[i] = s;
    }
    this.animateInternal.apply(this, t);
  }
  /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */
  animateInternal(e) {
    let t = arguments.length, i;
    t > 1 && typeof arguments[t - 1] == "function" && (i = arguments[t - 1], --t);
    let s = 0;
    for (; s < t && !this.isDef(); ++s) {
      const c = arguments[s];
      c.center && this.setCenterInternal(c.center), c.zoom !== void 0 ? this.setZoom(c.zoom) : c.resolution && this.setResolution(c.resolution), c.rotation !== void 0 && this.setRotation(c.rotation);
    }
    if (s === t) {
      i && mr(i, !0);
      return;
    }
    let r = Date.now(), o = this.targetCenter_.slice(), a = this.targetResolution_, l = this.targetRotation_;
    const h = [];
    for (; s < t; ++s) {
      const c = (
        /** @type {AnimationOptions} */
        arguments[s]
      ), u = {
        start: r,
        complete: !1,
        anchor: c.anchor,
        duration: c.duration !== void 0 ? c.duration : 1e3,
        easing: c.easing || i_,
        callback: i
      };
      if (c.center && (u.sourceCenter = o, u.targetCenter = c.center.slice(), o = u.targetCenter), c.zoom !== void 0 ? (u.sourceResolution = a, u.targetResolution = this.getResolutionForZoom(c.zoom), a = u.targetResolution) : c.resolution && (u.sourceResolution = a, u.targetResolution = c.resolution, a = u.targetResolution), c.rotation !== void 0) {
        u.sourceRotation = l;
        const d = Hi(c.rotation - l + Math.PI, 2 * Math.PI) - Math.PI;
        u.targetRotation = l + d, l = u.targetRotation;
      }
      R_(u) ? u.complete = !0 : r += u.duration, h.push(u);
    }
    this.animations_.push(h), this.setHint(de.ANIMATING, 1), this.updateAnimations_();
  }
  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */
  getAnimating() {
    return this.hints_[de.ANIMATING] > 0;
  }
  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */
  getInteracting() {
    return this.hints_[de.INTERACTING] > 0;
  }
  /**
   * Cancel any ongoing animations.
   * @api
   */
  cancelAnimations() {
    this.setHint(de.ANIMATING, -this.hints_[de.ANIMATING]);
    let e;
    for (let t = 0, i = this.animations_.length; t < i; ++t) {
      const s = this.animations_[t];
      if (s[0].callback && mr(s[0].callback, !1), !e)
        for (let r = 0, o = s.length; r < o; ++r) {
          const a = s[r];
          if (!a.complete) {
            e = a.anchor;
            break;
          }
        }
    }
    this.animations_.length = 0, this.cancelAnchor_ = e, this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
  }
  /**
   * Update all animations.
   */
  updateAnimations_() {
    if (this.updateAnimationKey_ !== void 0 && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), !this.getAnimating())
      return;
    const e = Date.now();
    let t = !1;
    for (let i = this.animations_.length - 1; i >= 0; --i) {
      const s = this.animations_[i];
      let r = !0;
      for (let o = 0, a = s.length; o < a; ++o) {
        const l = s[o];
        if (l.complete)
          continue;
        const h = e - l.start;
        let c = l.duration > 0 ? h / l.duration : 1;
        c >= 1 ? (l.complete = !0, c = 1) : r = !1;
        const u = l.easing(c);
        if (l.sourceCenter) {
          const d = l.sourceCenter[0], f = l.sourceCenter[1], g = l.targetCenter[0], _ = l.targetCenter[1];
          this.nextCenter_ = l.targetCenter;
          const m = d + u * (g - d), p = f + u * (_ - f);
          this.targetCenter_ = [m, p];
        }
        if (l.sourceResolution && l.targetResolution) {
          const d = u === 1 ? l.targetResolution : l.sourceResolution + u * (l.targetResolution - l.sourceResolution);
          if (l.anchor) {
            const f = this.getViewportSize_(this.getRotation()), g = this.constraints_.resolution(
              d,
              0,
              f,
              !0
            );
            this.targetCenter_ = this.calculateCenterZoom(
              g,
              l.anchor
            );
          }
          this.nextResolution_ = l.targetResolution, this.targetResolution_ = d, this.applyTargetState_(!0);
        }
        if (l.sourceRotation !== void 0 && l.targetRotation !== void 0) {
          const d = u === 1 ? Hi(l.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : l.sourceRotation + u * (l.targetRotation - l.sourceRotation);
          if (l.anchor) {
            const f = this.constraints_.rotation(
              d,
              !0
            );
            this.targetCenter_ = this.calculateCenterRotate(
              f,
              l.anchor
            );
          }
          this.nextRotation_ = l.targetRotation, this.targetRotation_ = d;
        }
        if (this.applyTargetState_(!0), t = !0, !l.complete)
          break;
      }
      if (r) {
        this.animations_[i] = null, this.setHint(de.ANIMATING, -1), this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
        const o = s[0].callback;
        o && mr(o, !0);
      }
    }
    this.animations_ = this.animations_.filter(Boolean), t && this.updateAnimationKey_ === void 0 && (this.updateAnimationKey_ = requestAnimationFrame(
      this.updateAnimations_.bind(this)
    ));
  }
  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */
  calculateCenterRotate(e, t) {
    let i;
    const s = this.getCenterInternal();
    return s !== void 0 && (i = [s[0] - t[0], s[1] - t[1]], hl(i, e - this.getRotation()), zg(i, t)), i;
  }
  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */
  calculateCenterZoom(e, t) {
    let i;
    const s = this.getCenterInternal(), r = this.getResolution();
    if (s !== void 0 && r !== void 0) {
      const o = t[0] - e * (t[0] - s[0]) / r, a = t[1] - e * (t[1] - s[1]) / r;
      i = [o, a];
    }
    return i;
  }
  /**
   * Returns the current viewport size.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */
  getViewportSize_(e) {
    const t = this.viewportSize_;
    if (e) {
      const i = t[0], s = t[1];
      return [
        Math.abs(i * Math.cos(e)) + Math.abs(s * Math.sin(e)),
        Math.abs(i * Math.sin(e)) + Math.abs(s * Math.cos(e))
      ];
    }
    return t;
  }
  /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
   */
  setViewportSize(e) {
    this.viewportSize_ = Array.isArray(e) ? e.slice() : [100, 100], this.getAnimating() || this.resolveConstraints(0);
  }
  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */
  getCenter() {
    const e = this.getCenterInternal();
    return e && Vn(e, this.getProjection());
  }
  /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */
  getCenterInternal() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(Ke.CENTER)
    );
  }
  /**
   * @return {Constraints} Constraints.
   */
  getConstraints() {
    return this.constraints_;
  }
  /**
   * @return {boolean} Resolution constraint is set
   */
  getConstrainResolution() {
    return this.get("constrainResolution");
  }
  /**
   * @param {Array<number>} [hints] Destination array.
   * @return {Array<number>} Hint.
   */
  getHints(e) {
    return e !== void 0 ? (e[0] = this.hints_[0], e[1] = this.hints_[1], e) : this.hints_.slice();
  }
  /**
   * Calculate the extent for the current view state and the passed box size.
   * @param {import("./size.js").Size} [size] The pixel dimensions of the box
   * into which the calculated extent should fit. Defaults to the size of the
   * map the view is associated with.
   * If no map or multiple maps are connected to the view, provide the desired
   * box size (e.g. `map.getSize()`).
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */
  calculateExtent(e) {
    const t = this.calculateExtentInternal(e);
    return yo(t, this.getProjection());
  }
  /**
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */
  calculateExtentInternal(e) {
    e = e || this.getViewportSizeMinusPadding_();
    const t = (
      /** @type {!import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    Q(t, "The view center is not defined");
    const i = (
      /** @type {!number} */
      this.getResolution()
    );
    Q(i !== void 0, "The view resolution is not defined");
    const s = (
      /** @type {!number} */
      this.getRotation()
    );
    return Q(s !== void 0, "The view rotation is not defined"), Ms(t, i, s, e);
  }
  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */
  getMaxResolution() {
    return this.maxResolution_;
  }
  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */
  getMinResolution() {
    return this.minResolution_;
  }
  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.minResolution_)
    );
  }
  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */
  setMaxZoom(e) {
    this.applyOptions_(this.getUpdatedOptions_({ maxZoom: e }));
  }
  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.maxResolution_)
    );
  }
  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */
  setMinZoom(e) {
    this.applyOptions_(this.getUpdatedOptions_({ minZoom: e }));
  }
  /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */
  setConstrainResolution(e) {
    this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: e }));
  }
  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */
  getProjection() {
    return this.projection_;
  }
  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */
  getResolution() {
    return (
      /** @type {number|undefined} */
      this.get(Ke.RESOLUTION)
    );
  }
  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */
  getResolutionForExtent(e, t) {
    return this.getResolutionForExtentInternal(
      Et(e, this.getProjection()),
      t
    );
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */
  getResolutionForExtentInternal(e, t) {
    t = t || this.getViewportSizeMinusPadding_();
    const i = ie(e) / t[0], s = Te(e) / t[1];
    return Math.max(i, s);
  }
  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Resolution for value function.
   */
  getResolutionForValueFunction(e) {
    e = e || 2;
    const t = this.getConstrainedResolution(this.maxResolution_), i = this.minResolution_, s = Math.log(t / i) / Math.log(e);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      function(r) {
        return t / Math.pow(e, r * s);
      }
    );
  }
  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */
  getRotation() {
    return (
      /** @type {number} */
      this.get(Ke.ROTATION)
    );
  }
  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Value for resolution function.
   */
  getValueForResolutionFunction(e) {
    const t = Math.log(e || 2), i = this.getConstrainedResolution(this.maxResolution_), s = this.minResolution_, r = Math.log(i / s) / t;
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      function(o) {
        return Math.log(i / o) / t / r;
      }
    );
  }
  /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */
  getViewportSizeMinusPadding_(e) {
    let t = this.getViewportSize_(e);
    const i = this.padding_;
    return i && (t = [
      t[0] - i[1] - i[3],
      t[1] - i[0] - i[2]
    ]), t;
  }
  /**
   * @return {State} View state.
   */
  getState() {
    const e = this.getProjection(), t = this.getResolution(), i = this.getRotation();
    let s = (
      /** @type {import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    const r = this.padding_;
    if (r) {
      const o = this.getViewportSizeMinusPadding_();
      s = Ho(
        s,
        this.getViewportSize_(),
        [o[0] / 2 + r[3], o[1] / 2 + r[0]],
        t,
        i
      );
    }
    return {
      center: s.slice(0),
      projection: e !== void 0 ? e : null,
      resolution: t,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation: i,
      zoom: this.getZoom()
    };
  }
  /**
   * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
   */
  getViewStateAndExtent() {
    return {
      viewState: this.getState(),
      extent: this.calculateExtent()
    };
  }
  /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */
  getZoom() {
    let e;
    const t = this.getResolution();
    return t !== void 0 && (e = this.getZoomForResolution(t)), e;
  }
  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */
  getZoomForResolution(e) {
    let t = this.minZoom_ || 0, i, s;
    if (this.resolutions_) {
      const r = go(this.resolutions_, e, 1);
      t = r, i = this.resolutions_[r], r == this.resolutions_.length - 1 ? s = 2 : s = i / this.resolutions_[r + 1];
    } else
      i = this.maxResolution_, s = this.zoomFactor_;
    return t + Math.log(i / e) / Math.log(s);
  }
  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */
  getResolutionForZoom(e) {
    if (this.resolutions_) {
      if (this.resolutions_.length <= 1)
        return 0;
      const t = _e(
        Math.floor(e),
        0,
        this.resolutions_.length - 2
      ), i = this.resolutions_[t] / this.resolutions_[t + 1];
      return this.resolutions_[t] / Math.pow(i, _e(e - t, 0, 1));
    }
    return this.maxResolution_ / Math.pow(this.zoomFactor_, e - this.minZoom_);
  }
  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [options] Options.
   * @api
   */
  fit(e, t) {
    let i;
    if (Q(
      Array.isArray(e) || typeof /** @type {?} */
      e.getSimplifiedGeometry == "function",
      "Invalid extent or geometry provided as `geometry`"
    ), Array.isArray(e)) {
      Q(
        !Jn(e),
        "Cannot fit empty extent provided as `geometry`"
      );
      const s = Et(e, this.getProjection());
      i = jr(s);
    } else if (e.getType() === "Circle") {
      const s = Et(
        e.getExtent(),
        this.getProjection()
      );
      i = jr(s), i.rotate(this.getRotation(), Ot(s));
    } else
      i = e;
    this.fitInternal(i, t);
  }
  /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */
  rotatedExtentForGeometry(e) {
    const t = this.getRotation(), i = Math.cos(t), s = Math.sin(-t), r = e.getFlatCoordinates(), o = e.getStride();
    let a = 1 / 0, l = 1 / 0, h = -1 / 0, c = -1 / 0;
    for (let u = 0, d = r.length; u < d; u += o) {
      const f = r[u] * i - r[u + 1] * s, g = r[u] * s + r[u + 1] * i;
      a = Math.min(a, f), l = Math.min(l, g), h = Math.max(h, f), c = Math.max(c, g);
    }
    return [a, l, h, c];
  }
  /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [options] Options.
   */
  fitInternal(e, t) {
    t = t || {};
    let i = t.size;
    i || (i = this.getViewportSizeMinusPadding_());
    const s = t.padding !== void 0 ? t.padding : [0, 0, 0, 0], r = t.nearest !== void 0 ? t.nearest : !1;
    let o;
    t.minResolution !== void 0 ? o = t.minResolution : t.maxZoom !== void 0 ? o = this.getResolutionForZoom(t.maxZoom) : o = 0;
    const a = this.rotatedExtentForGeometry(e);
    let l = this.getResolutionForExtentInternal(a, [
      i[0] - s[1] - s[3],
      i[1] - s[0] - s[2]
    ]);
    l = isNaN(l) ? o : Math.max(l, o), l = this.getConstrainedResolution(l, r ? 0 : 1);
    const h = this.getRotation(), c = Math.sin(h), u = Math.cos(h), d = Ot(a);
    d[0] += (s[1] - s[3]) / 2 * l, d[1] += (s[0] - s[2]) / 2 * l;
    const f = d[0] * u - d[1] * c, g = d[1] * u + d[0] * c, _ = this.getConstrainedCenter([f, g], l), m = t.callback ? t.callback : Gn;
    t.duration !== void 0 ? this.animateInternal(
      {
        resolution: l,
        center: _,
        duration: t.duration,
        easing: t.easing
      },
      m
    ) : (this.targetResolution_ = l, this.targetCenter_ = _, this.applyTargetState_(!1, !0), mr(m, !0));
  }
  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */
  centerOn(e, t, i) {
    this.centerOnInternal(
      pe(e, this.getProjection()),
      t,
      i
    );
  }
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */
  centerOnInternal(e, t, i) {
    this.setCenterInternal(
      Ho(
        e,
        t,
        i,
        this.getResolution(),
        this.getRotation()
      )
    );
  }
  /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */
  calculateCenterShift(e, t, i, s) {
    let r;
    const o = this.padding_;
    if (o && e) {
      const a = this.getViewportSizeMinusPadding_(-i), l = Ho(
        e,
        s,
        [a[0] / 2 + o[3], a[1] / 2 + o[0]],
        t,
        i
      );
      r = [
        e[0] - l[0],
        e[1] - l[1]
      ];
    }
    return r;
  }
  /**
   * @return {boolean} Is defined.
   */
  isDef() {
    return !!this.getCenterInternal() && this.getResolution() !== void 0;
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */
  adjustCenter(e) {
    const t = Vn(this.targetCenter_, this.getProjection());
    this.setCenter([
      t[0] + e[0],
      t[1] + e[1]
    ]);
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */
  adjustCenterInternal(e) {
    const t = this.targetCenter_;
    this.setCenterInternal([
      t[0] + e[0],
      t[1] + e[1]
    ]);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustResolution(e, t) {
    t = t && pe(t, this.getProjection()), this.adjustResolutionInternal(e, t);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  adjustResolutionInternal(e, t) {
    const i = this.getAnimating() || this.getInteracting(), s = this.getViewportSize_(this.getRotation()), r = this.constraints_.resolution(
      this.targetResolution_ * e,
      0,
      s,
      i
    );
    t && (this.targetCenter_ = this.calculateCenterZoom(r, t)), this.targetResolution_ *= e, this.applyTargetState_();
  }
  /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustZoom(e, t) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -e), t);
  }
  /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   * @api
   */
  adjustRotation(e, t) {
    t && (t = pe(t, this.getProjection())), this.adjustRotationInternal(e, t);
  }
  /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   */
  adjustRotationInternal(e, t) {
    const i = this.getAnimating() || this.getInteracting(), s = this.constraints_.rotation(
      this.targetRotation_ + e,
      i
    );
    t && (this.targetCenter_ = this.calculateCenterRotate(s, t)), this.targetRotation_ += e, this.applyTargetState_();
  }
  /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */
  setCenter(e) {
    this.setCenterInternal(
      e && pe(e, this.getProjection())
    );
  }
  /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */
  setCenterInternal(e) {
    this.targetCenter_ = e, this.applyTargetState_();
  }
  /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */
  setHint(e, t) {
    return this.hints_[e] += t, this.changed(), this.hints_[e];
  }
  /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */
  setResolution(e) {
    this.targetResolution_ = e, this.applyTargetState_();
  }
  /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */
  setRotation(e) {
    this.targetRotation_ = e, this.applyTargetState_();
  }
  /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */
  setZoom(e) {
    this.setResolution(this.getResolutionForZoom(e));
  }
  /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
   * @private
   */
  applyTargetState_(e, t) {
    const i = this.getAnimating() || this.getInteracting() || t, s = this.constraints_.rotation(
      this.targetRotation_,
      i
    ), r = this.getViewportSize_(s), o = this.constraints_.resolution(
      this.targetResolution_,
      0,
      r,
      i
    ), a = this.constraints_.center(
      this.targetCenter_,
      o,
      r,
      i,
      this.calculateCenterShift(
        this.targetCenter_,
        o,
        s,
        r
      )
    );
    this.get(Ke.ROTATION) !== s && this.set(Ke.ROTATION, s), this.get(Ke.RESOLUTION) !== o && (this.set(Ke.RESOLUTION, o), this.set("zoom", this.getZoom(), !0)), (!a || !this.get(Ke.CENTER) || !nt(this.get(Ke.CENTER), a)) && this.set(Ke.CENTER, a), this.getAnimating() && !e && this.cancelAnimations(), this.cancelAnchor_ = void 0;
  }
  /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [duration] The animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  resolveConstraints(e, t, i) {
    e = e !== void 0 ? e : 200;
    const s = t || 0, r = this.constraints_.rotation(this.targetRotation_), o = this.getViewportSize_(r), a = this.constraints_.resolution(
      this.targetResolution_,
      s,
      o
    ), l = this.constraints_.center(
      this.targetCenter_,
      a,
      o,
      !1,
      this.calculateCenterShift(
        this.targetCenter_,
        a,
        r,
        o
      )
    );
    if (e === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = a, this.targetRotation_ = r, this.targetCenter_ = l, this.applyTargetState_();
      return;
    }
    i = i || (e === 0 ? this.cancelAnchor_ : void 0), this.cancelAnchor_ = void 0, (this.getResolution() !== a || this.getRotation() !== r || !this.getCenterInternal() || !nt(this.getCenterInternal(), l)) && (this.getAnimating() && this.cancelAnimations(), this.animateInternal({
      rotation: r,
      center: l,
      resolution: a,
      duration: e,
      easing: nn,
      anchor: i
    }));
  }
  /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */
  beginInteraction() {
    this.resolveConstraints(0), this.setHint(de.INTERACTING, 1);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  endInteraction(e, t, i) {
    i = i && pe(i, this.getProjection()), this.endInteractionInternal(e, t, i);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  endInteractionInternal(e, t, i) {
    this.getInteracting() && (this.setHint(de.INTERACTING, -1), this.resolveConstraints(e, t, i));
  }
  /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */
  getConstrainedCenter(e, t) {
    const i = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(
      e,
      t || this.getResolution(),
      i
    );
  }
  /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */
  getConstrainedZoom(e, t) {
    const i = this.getResolutionForZoom(e);
    return this.getZoomForResolution(
      this.getConstrainedResolution(i, t)
    );
  }
  /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */
  getConstrainedResolution(e, t) {
    t = t || 0;
    const i = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(e, t, i);
  }
}
function mr(n, e) {
  setTimeout(function() {
    n(e);
  }, 0);
}
function S_(n) {
  if (n.extent !== void 0) {
    const t = n.smoothExtentConstraint !== void 0 ? n.smoothExtentConstraint : !0;
    return jh(n.extent, n.constrainOnlyCenter, t);
  }
  const e = fl(n.projection, "EPSG:3857");
  if (n.multiWorld !== !0 && e.isGlobal()) {
    const t = e.getExtent().slice();
    return t[0] = -1 / 0, t[2] = 1 / 0, jh(t, !1, !1);
  }
  return qg;
}
function v_(n) {
  let e, t, i, o = n.minZoom !== void 0 ? n.minZoom : Zo, a = n.maxZoom !== void 0 ? n.maxZoom : 28;
  const l = n.zoomFactor !== void 0 ? n.zoomFactor : 2, h = n.multiWorld !== void 0 ? n.multiWorld : !1, c = n.smoothResolutionConstraint !== void 0 ? n.smoothResolutionConstraint : !0, u = n.showFullExtent !== void 0 ? n.showFullExtent : !1, d = fl(n.projection, "EPSG:3857"), f = d.getExtent();
  let g = n.constrainOnlyCenter, _ = n.extent;
  if (!h && !_ && d.isGlobal() && (g = !1, _ = f), n.resolutions !== void 0) {
    const m = n.resolutions;
    t = m[o], i = m[a] !== void 0 ? m[a] : m[m.length - 1], n.constrainResolution ? e = Jg(
      m,
      c,
      !g && _,
      u
    ) : e = Yh(
      t,
      i,
      c,
      !g && _,
      u
    );
  } else {
    const p = (f ? Math.max(ie(f), Te(f)) : (
      // use an extent that can fit the whole world if need be
      360 * zn.degrees / d.getMetersPerUnit()
    )) / nl / Math.pow(2, Zo), y = p / Math.pow(2, 28 - Zo);
    t = n.maxResolution, t !== void 0 ? o = 0 : t = p / Math.pow(l, o), i = n.minResolution, i === void 0 && (n.maxZoom !== void 0 ? n.maxResolution !== void 0 ? i = t / Math.pow(l, a) : i = p / Math.pow(l, a) : i = y), a = o + Math.floor(
      Math.log(t / i) / Math.log(l)
    ), i = t / Math.pow(l, a - o), n.constrainResolution ? e = Qg(
      l,
      t,
      i,
      c,
      !g && _,
      u
    ) : e = Yh(
      t,
      i,
      c,
      !g && _,
      u
    );
  }
  return {
    constraint: e,
    maxResolution: t,
    minResolution: i,
    minZoom: o,
    zoomFactor: l
  };
}
function T_(n) {
  if (n.enableRotation !== void 0 ? n.enableRotation : !0) {
    const t = n.constrainRotation;
    return t === void 0 || t === !0 ? t_() : t === !1 ? Xh : typeof t == "number" ? e_(t) : Xh;
  }
  return ml;
}
function R_(n) {
  return !(n.sourceCenter && n.targetCenter && !nt(n.sourceCenter, n.targetCenter) || n.sourceResolution !== n.targetResolution || n.sourceRotation !== n.targetRotation);
}
function Ho(n, e, t, i, s) {
  const r = Math.cos(-s);
  let o = Math.sin(-s), a = n[0] * r - n[1] * o, l = n[1] * r + n[0] * o;
  a += (e[0] / 2 - t[0]) * i, l += (t[1] - e[1] / 2) * i, o = -o;
  const h = a * r - l * o, c = l * r + a * o;
  return [h, c];
}
const pt = w_;
class I_ extends lu {
  /**
   * @param {Options<SourceType>} options Layer options.
   */
  constructor(e) {
    const t = Object.assign({}, e);
    delete t.source, super(t), this.on, this.once, this.un, this.mapPrecomposeKey_ = null, this.mapRenderKey_ = null, this.sourceChangeKey_ = null, this.renderer_ = null, this.sourceReady_ = !1, this.rendered = !1, e.render && (this.render = e.render), e.map && this.setMap(e.map), this.addChangeListener(
      le.SOURCE,
      this.handleSourcePropertyChange_
    );
    const i = e.source ? (
      /** @type {SourceType} */
      e.source
    ) : null;
    this.setSource(i);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(e) {
    return e = e || [], e.push(this), e;
  }
  /**
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(e) {
    return e = e || [], e.push(this.getLayerState()), e;
  }
  /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */
  getSource() {
    return (
      /** @type {SourceType} */
      this.get(le.SOURCE) || null
    );
  }
  /**
   * @return {SourceType|null} The source being rendered.
   */
  getRenderSource() {
    return this.getSource();
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    const e = this.getSource();
    return e ? e.getState() : "undefined";
  }
  /**
   * @private
   */
  handleSourceChange_() {
    this.changed(), !(this.sourceReady_ || this.getSource().getState() !== "ready") && (this.sourceReady_ = !0, this.dispatchEvent("sourceready"));
  }
  /**
   * @private
   */
  handleSourcePropertyChange_() {
    this.sourceChangeKey_ && (he(this.sourceChangeKey_), this.sourceChangeKey_ = null), this.sourceReady_ = !1;
    const e = this.getSource();
    e && (this.sourceChangeKey_ = Z(
      e,
      G.CHANGE,
      this.handleSourceChange_,
      this
    ), e.getState() === "ready" && (this.sourceReady_ = !0, setTimeout(() => {
      this.dispatchEvent("sourceready");
    }, 0))), this.changed();
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(e) {
    return this.renderer_ ? this.renderer_.getFeatures(e) : Promise.resolve([]);
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(e) {
    return !this.renderer_ || !this.rendered ? null : this.renderer_.getData(e);
  }
  /**
   * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
   * extent, not set to `visible: false`, and not inside a layer group that is set
   * to `visible: false`.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {boolean} The layer is visible in the map view.
   * @api
   */
  isVisible(e) {
    let t;
    const i = this.getMapInternal();
    !e && i && (e = i.getView()), e instanceof pt ? t = {
      viewState: e.getState(),
      extent: e.calculateExtent()
    } : t = e, !t.layerStatesArray && i && (t.layerStatesArray = i.getLayerGroup().getLayerStatesArray());
    let s;
    t.layerStatesArray ? s = t.layerStatesArray.find(
      (o) => o.layer === this
    ) : s = this.getLayerState();
    const r = this.getExtent();
    return bl(s, t.viewState) && (!r || ye(r, t.extent));
  }
  /**
   * Get the attributions of the source of this layer for the given view.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {Array<string>} Attributions for this layer at the given view.
   * @api
   */
  getAttributions(e) {
    if (!this.isVisible(e))
      return [];
    let t;
    const i = this.getSource();
    if (i && (t = i.getAttributions()), !t)
      return [];
    const s = e instanceof pt ? e.getViewStateAndExtent() : e;
    let r = t(s);
    return Array.isArray(r) || (r = [r]), r;
  }
  /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement|null} The rendered element.
   */
  render(e, t) {
    const i = this.getRenderer();
    return i.prepareFrame(e) ? (this.rendered = !0, i.renderFrame(e, t)) : null;
  }
  /**
   * Called when a layer is not visible during a map render.
   */
  unrender() {
    this.rendered = !1;
  }
  /** @return {string} Declutter */
  getDeclutter() {
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(e, t) {
  }
  /**
   * When the renderer follows a layout -> render approach, do the final rendering here.
   * @param {import('../Map.js').FrameState} frameState Frame state
   */
  renderDeferred(e) {
    const t = this.getRenderer();
    t && t.renderDeferred(e);
  }
  /**
   * For use inside the library only.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMapInternal(e) {
    e || this.unrender(), this.set(le.MAP, e);
  }
  /**
   * For use inside the library only.
   * @return {import("../Map.js").default|null} Map.
   */
  getMapInternal() {
    return this.get(le.MAP);
  }
  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map~Map#addLayer} instead.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    this.mapPrecomposeKey_ && (he(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), e || this.changed(), this.mapRenderKey_ && (he(this.mapRenderKey_), this.mapRenderKey_ = null), e && (this.mapPrecomposeKey_ = Z(
      e,
      st.PRECOMPOSE,
      function(t) {
        const s = /** @type {import("../render/Event.js").default} */ t.frameState.layerStatesArray, r = this.getLayerState(!1);
        Q(
          !s.some(function(o) {
            return o.layer === r.layer;
          }),
          "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
        ), s.push(r);
      },
      this
    ), this.mapRenderKey_ = Z(this, G.CHANGE, e.render, e), this.changed());
  }
  /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */
  setSource(e) {
    this.set(le.SOURCE, e);
  }
  /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */
  getRenderer() {
    return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_;
  }
  /**
   * @return {boolean} The layer has a renderer.
   */
  hasRenderer() {
    return !!this.renderer_;
  }
  /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */
  createRenderer() {
    return null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.renderer_ && (this.renderer_.dispose(), delete this.renderer_), this.setSource(null), super.disposeInternal();
  }
}
function bl(n, e) {
  if (!n.visible)
    return !1;
  const t = e.resolution;
  if (t < n.minResolution || t >= n.maxResolution)
    return !1;
  const i = e.zoom;
  return i > n.minZoom && i <= n.maxZoom;
}
const tr = I_;
function P_(n, e, t, i, s) {
  Ou(n, e, t || 0, i || n.length - 1, s || L_);
}
function Ou(n, e, t, i, s) {
  for (; i > t; ) {
    if (i - t > 600) {
      var r = i - t + 1, o = e - t + 1, a = Math.log(r), l = 0.5 * Math.exp(2 * a / 3), h = 0.5 * Math.sqrt(a * l * (r - l) / r) * (o - r / 2 < 0 ? -1 : 1), c = Math.max(t, Math.floor(e - o * l / r + h)), u = Math.min(i, Math.floor(e + (r - o) * l / r + h));
      Ou(n, e, c, u, s);
    }
    var d = n[e], f = t, g = i;
    for (cs(n, t, e), s(n[i], d) > 0 && cs(n, t, i); f < g; ) {
      for (cs(n, f, g), f++, g--; s(n[f], d) < 0; )
        f++;
      for (; s(n[g], d) > 0; )
        g--;
    }
    s(n[t], d) === 0 ? cs(n, t, g) : (g++, cs(n, g, i)), g <= e && (t = g + 1), e <= g && (i = g - 1);
  }
}
function cs(n, e, t) {
  var i = n[e];
  n[e] = n[t], n[t] = i;
}
function L_(n, e) {
  return n < e ? -1 : n > e ? 1 : 0;
}
let Du = class {
  constructor(e = 9) {
    this._maxEntries = Math.max(4, e), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(e) {
    let t = this.data;
    const i = [];
    if (!yr(e, t))
      return i;
    const s = this.toBBox, r = [];
    for (; t; ) {
      for (let o = 0; o < t.children.length; o++) {
        const a = t.children[o], l = t.leaf ? s(a) : a;
        yr(e, l) && (t.leaf ? i.push(a) : Jo(e, l) ? this._all(a, i) : r.push(a));
      }
      t = r.pop();
    }
    return i;
  }
  collides(e) {
    let t = this.data;
    if (!yr(e, t))
      return !1;
    const i = [];
    for (; t; ) {
      for (let s = 0; s < t.children.length; s++) {
        const r = t.children[s], o = t.leaf ? this.toBBox(r) : r;
        if (yr(e, o)) {
          if (t.leaf || Jo(e, o))
            return !0;
          i.push(r);
        }
      }
      t = i.pop();
    }
    return !1;
  }
  load(e) {
    if (!(e && e.length))
      return this;
    if (e.length < this._minEntries) {
      for (let i = 0; i < e.length; i++)
        this.insert(e[i]);
      return this;
    }
    let t = this._build(e.slice(), 0, e.length - 1, 0);
    if (!this.data.children.length)
      this.data = t;
    else if (this.data.height === t.height)
      this._splitRoot(this.data, t);
    else {
      if (this.data.height < t.height) {
        const i = this.data;
        this.data = t, t = i;
      }
      this._insert(t, this.data.height - t.height - 1, !0);
    }
    return this;
  }
  insert(e) {
    return e && this._insert(e, this.data.height - 1), this;
  }
  clear() {
    return this.data = En([]), this;
  }
  remove(e, t) {
    if (!e)
      return this;
    let i = this.data;
    const s = this.toBBox(e), r = [], o = [];
    let a, l, h;
    for (; i || r.length; ) {
      if (i || (i = r.pop(), l = r[r.length - 1], a = o.pop(), h = !0), i.leaf) {
        const c = b_(e, i.children, t);
        if (c !== -1)
          return i.children.splice(c, 1), r.push(i), this._condense(r), this;
      }
      !h && !i.leaf && Jo(i, s) ? (r.push(i), o.push(a), a = 0, l = i, i = i.children[0]) : l ? (a++, i = l.children[a], h = !1) : i = null;
    }
    return this;
  }
  toBBox(e) {
    return e;
  }
  compareMinX(e, t) {
    return e.minX - t.minX;
  }
  compareMinY(e, t) {
    return e.minY - t.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(e) {
    return this.data = e, this;
  }
  _all(e, t) {
    const i = [];
    for (; e; )
      e.leaf ? t.push(...e.children) : i.push(...e.children), e = i.pop();
    return t;
  }
  _build(e, t, i, s) {
    const r = i - t + 1;
    let o = this._maxEntries, a;
    if (r <= o)
      return a = En(e.slice(t, i + 1)), fn(a, this.toBBox), a;
    s || (s = Math.ceil(Math.log(r) / Math.log(o)), o = Math.ceil(r / Math.pow(o, s - 1))), a = En([]), a.leaf = !1, a.height = s;
    const l = Math.ceil(r / o), h = l * Math.ceil(Math.sqrt(o));
    qh(e, t, i, h, this.compareMinX);
    for (let c = t; c <= i; c += h) {
      const u = Math.min(c + h - 1, i);
      qh(e, c, u, l, this.compareMinY);
      for (let d = c; d <= u; d += l) {
        const f = Math.min(d + l - 1, u);
        a.children.push(this._build(e, d, f, s - 1));
      }
    }
    return fn(a, this.toBBox), a;
  }
  _chooseSubtree(e, t, i, s) {
    for (; s.push(t), !(t.leaf || s.length - 1 === i); ) {
      let r = 1 / 0, o = 1 / 0, a;
      for (let l = 0; l < t.children.length; l++) {
        const h = t.children[l], c = qo(h), u = M_(e, h) - c;
        u < o ? (o = u, r = c < r ? c : r, a = h) : u === o && c < r && (r = c, a = h);
      }
      t = a || t.children[0];
    }
    return t;
  }
  _insert(e, t, i) {
    const s = i ? e : this.toBBox(e), r = [], o = this._chooseSubtree(s, this.data, t, r);
    for (o.children.push(e), ps(o, s); t >= 0 && r[t].children.length > this._maxEntries; )
      this._split(r, t), t--;
    this._adjustParentBBoxes(s, r, t);
  }
  // split overflowed node into two
  _split(e, t) {
    const i = e[t], s = i.children.length, r = this._minEntries;
    this._chooseSplitAxis(i, r, s);
    const o = this._chooseSplitIndex(i, r, s), a = En(i.children.splice(o, i.children.length - o));
    a.height = i.height, a.leaf = i.leaf, fn(i, this.toBBox), fn(a, this.toBBox), t ? e[t - 1].children.push(a) : this._splitRoot(i, a);
  }
  _splitRoot(e, t) {
    this.data = En([e, t]), this.data.height = e.height + 1, this.data.leaf = !1, fn(this.data, this.toBBox);
  }
  _chooseSplitIndex(e, t, i) {
    let s, r = 1 / 0, o = 1 / 0;
    for (let a = t; a <= i - t; a++) {
      const l = ms(e, 0, a, this.toBBox), h = ms(e, a, i, this.toBBox), c = O_(l, h), u = qo(l) + qo(h);
      c < r ? (r = c, s = a, o = u < o ? u : o) : c === r && u < o && (o = u, s = a);
    }
    return s || i - t;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(e, t, i) {
    const s = e.leaf ? this.compareMinX : A_, r = e.leaf ? this.compareMinY : F_, o = this._allDistMargin(e, t, i, s), a = this._allDistMargin(e, t, i, r);
    o < a && e.children.sort(s);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(e, t, i, s) {
    e.children.sort(s);
    const r = this.toBBox, o = ms(e, 0, t, r), a = ms(e, i - t, i, r);
    let l = pr(o) + pr(a);
    for (let h = t; h < i - t; h++) {
      const c = e.children[h];
      ps(o, e.leaf ? r(c) : c), l += pr(o);
    }
    for (let h = i - t - 1; h >= t; h--) {
      const c = e.children[h];
      ps(a, e.leaf ? r(c) : c), l += pr(a);
    }
    return l;
  }
  _adjustParentBBoxes(e, t, i) {
    for (let s = i; s >= 0; s--)
      ps(t[s], e);
  }
  _condense(e) {
    for (let t = e.length - 1, i; t >= 0; t--)
      e[t].children.length === 0 ? t > 0 ? (i = e[t - 1].children, i.splice(i.indexOf(e[t]), 1)) : this.clear() : fn(e[t], this.toBBox);
  }
};
function b_(n, e, t) {
  if (!t)
    return e.indexOf(n);
  for (let i = 0; i < e.length; i++)
    if (t(n, e[i]))
      return i;
  return -1;
}
function fn(n, e) {
  ms(n, 0, n.children.length, e, n);
}
function ms(n, e, t, i, s) {
  s || (s = En(null)), s.minX = 1 / 0, s.minY = 1 / 0, s.maxX = -1 / 0, s.maxY = -1 / 0;
  for (let r = e; r < t; r++) {
    const o = n.children[r];
    ps(s, n.leaf ? i(o) : o);
  }
  return s;
}
function ps(n, e) {
  return n.minX = Math.min(n.minX, e.minX), n.minY = Math.min(n.minY, e.minY), n.maxX = Math.max(n.maxX, e.maxX), n.maxY = Math.max(n.maxY, e.maxY), n;
}
function A_(n, e) {
  return n.minX - e.minX;
}
function F_(n, e) {
  return n.minY - e.minY;
}
function qo(n) {
  return (n.maxX - n.minX) * (n.maxY - n.minY);
}
function pr(n) {
  return n.maxX - n.minX + (n.maxY - n.minY);
}
function M_(n, e) {
  return (Math.max(e.maxX, n.maxX) - Math.min(e.minX, n.minX)) * (Math.max(e.maxY, n.maxY) - Math.min(e.minY, n.minY));
}
function O_(n, e) {
  const t = Math.max(n.minX, e.minX), i = Math.max(n.minY, e.minY), s = Math.min(n.maxX, e.maxX), r = Math.min(n.maxY, e.maxY);
  return Math.max(0, s - t) * Math.max(0, r - i);
}
function Jo(n, e) {
  return n.minX <= e.minX && n.minY <= e.minY && e.maxX <= n.maxX && e.maxY <= n.maxY;
}
function yr(n, e) {
  return e.minX <= n.maxX && e.minY <= n.maxY && e.maxX >= n.minX && e.maxY >= n.minY;
}
function En(n) {
  return {
    children: n,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function qh(n, e, t, i, s) {
  const r = [e, t];
  for (; r.length; ) {
    if (t = r.pop(), e = r.pop(), t - e <= i)
      continue;
    const o = e + Math.ceil((t - e) / i / 2) * i;
    P_(n, o, e, t, s), r.push(e, o, o, t);
  }
}
const M = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};
function Jh(n) {
  return n[0] > 0 && n[1] > 0;
}
function D_(n, e, t) {
  return t === void 0 && (t = [0, 0]), t[0] = n[0] * e + 0.5 | 0, t[1] = n[1] * e + 0.5 | 0, t;
}
function $e(n, e) {
  return Array.isArray(n) ? n : (e === void 0 ? e = [n, n] : (e[0] = n, e[1] = n), e);
}
class Al {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    this.opacity_ = e.opacity, this.rotateWithView_ = e.rotateWithView, this.rotation_ = e.rotation, this.scale_ = e.scale, this.scaleArray_ = $e(e.scale), this.displacement_ = e.displacement, this.declutterMode_ = e.declutterMode;
  }
  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale();
    return new Al({
      opacity: this.getOpacity(),
      scale: Array.isArray(e) ? e.slice() : e,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */
  getOpacity() {
    return this.opacity_;
  }
  /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */
  getDisplacement() {
    return this.displacement_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */
  getAnchor() {
    return B();
  }
  /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getImage(e) {
    return B();
  }
  /**
   * @abstract
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getHitDetectionImage() {
    return B();
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(e) {
    return 1;
  }
  /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return B();
  }
  /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return B();
  }
  /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */
  getOrigin() {
    return B();
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */
  getSize() {
    return B();
  }
  /**
   * Set the displacement.
   *
   * @param {Array<number>} displacement Displacement.
   * @api
   */
  setDisplacement(e) {
    this.displacement_ = e;
  }
  /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */
  setOpacity(e) {
    this.opacity_ = e;
  }
  /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(e) {
    this.rotateWithView_ = e;
  }
  /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */
  setRotation(e) {
    this.rotation_ = e;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(e) {
    this.scale_ = e, this.scaleArray_ = $e(e);
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(e) {
    B();
  }
  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    B();
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(e) {
    B();
  }
  /**
   * @return {Promise<void>} `false` or Promise that resolves when the style is ready to use.
   */
  ready() {
    return Promise.resolve();
  }
}
const Nu = Al, Ns = {
  name: "rgb",
  min: [0, 0, 0],
  max: [255, 255, 255],
  channel: ["red", "green", "blue"],
  alias: ["RGB"]
};
var Le = {
  name: "xyz",
  min: [0, 0, 0],
  channel: ["X", "Y", "Z"],
  alias: ["XYZ", "ciexyz", "cie1931"]
};
Le.whitepoint = {
  //1931 2°
  2: {
    //incadescent
    A: [109.85, 100, 35.585],
    // B:[],
    C: [98.074, 100, 118.232],
    D50: [96.422, 100, 82.521],
    D55: [95.682, 100, 92.149],
    //daylight
    D65: [95.045592705167, 100, 108.9057750759878],
    D75: [94.972, 100, 122.638],
    //flourescent
    // F1: [],
    F2: [99.187, 100, 67.395],
    // F3: [],
    // F4: [],
    // F5: [],
    // F6:[],
    F7: [95.044, 100, 108.755],
    // F8: [],
    // F9: [],
    // F10: [],
    F11: [100.966, 100, 64.37],
    // F12: [],
    E: [100, 100, 100]
  },
  //1964  10°
  10: {
    //incadescent
    A: [111.144, 100, 35.2],
    C: [97.285, 100, 116.145],
    D50: [96.72, 100, 81.427],
    D55: [95.799, 100, 90.926],
    //daylight
    D65: [94.811, 100, 107.304],
    D75: [94.416, 100, 120.641],
    //flourescent
    F2: [103.28, 100, 69.026],
    F7: [95.792, 100, 107.687],
    F11: [103.866, 100, 65.627],
    E: [100, 100, 100]
  }
};
Le.max = Le.whitepoint[2].D65;
Le.rgb = function(n, e) {
  e = e || Le.whitepoint[2].E;
  var t = n[0] / e[0], i = n[1] / e[1], s = n[2] / e[2], r, o, a;
  return r = t * 3.240969941904521 + i * -1.537383177570093 + s * -0.498610760293, o = t * -0.96924363628087 + i * 1.87596750150772 + s * 0.041555057407175, a = t * 0.055630079696993 + i * -0.20397695888897 + s * 1.056971514242878, r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r = r * 12.92, o = o > 31308e-7 ? 1.055 * Math.pow(o, 1 / 2.4) - 0.055 : o = o * 12.92, a = a > 31308e-7 ? 1.055 * Math.pow(a, 1 / 2.4) - 0.055 : a = a * 12.92, r = Math.min(Math.max(0, r), 1), o = Math.min(Math.max(0, o), 1), a = Math.min(Math.max(0, a), 1), [r * 255, o * 255, a * 255];
};
Ns.xyz = function(n, e) {
  var t = n[0] / 255, i = n[1] / 255, s = n[2] / 255;
  t = t > 0.04045 ? Math.pow((t + 0.055) / 1.055, 2.4) : t / 12.92, i = i > 0.04045 ? Math.pow((i + 0.055) / 1.055, 2.4) : i / 12.92, s = s > 0.04045 ? Math.pow((s + 0.055) / 1.055, 2.4) : s / 12.92;
  var r = t * 0.41239079926595 + i * 0.35758433938387 + s * 0.18048078840183, o = t * 0.21263900587151 + i * 0.71516867876775 + s * 0.072192315360733, a = t * 0.019330818715591 + i * 0.11919477979462 + s * 0.95053215224966;
  return e = e || Le.whitepoint[2].E, [r * e[0], o * e[1], a * e[2]];
};
const Fl = {
  name: "luv",
  //NOTE: luv has no rigidly defined limits
  //easyrgb fails to get proper coords
  //boronine states no rigid limits
  //colorMine refers this ones:
  min: [0, -134, -140],
  max: [100, 224, 122],
  channel: ["lightness", "u", "v"],
  alias: ["LUV", "cieluv", "cie1976"],
  xyz: function(n, e, t) {
    var i, s, r, o, a, l, h, c, u, d, f, g, _;
    if (r = n[0], o = n[1], a = n[2], r === 0)
      return [0, 0, 0];
    var m = 0.0011070564598794539;
    return e = e || "D65", t = t || 2, u = Le.whitepoint[t][e][0], d = Le.whitepoint[t][e][1], f = Le.whitepoint[t][e][2], g = 4 * u / (u + 15 * d + 3 * f), _ = 9 * d / (u + 15 * d + 3 * f), i = o / (13 * r) + g || 0, s = a / (13 * r) + _ || 0, h = r > 8 ? d * Math.pow((r + 16) / 116, 3) : d * r * m, l = h * 9 * i / (4 * s) || 0, c = h * (12 - 3 * i - 20 * s) / (4 * s) || 0, [l, h, c];
  }
};
Le.luv = function(n, e, t) {
  var i, s, r, o, a, l, h, c, u, d, f, g, _, m = 0.008856451679035631, p = 903.2962962962961;
  e = e || "D65", t = t || 2, u = Le.whitepoint[t][e][0], d = Le.whitepoint[t][e][1], f = Le.whitepoint[t][e][2], g = 4 * u / (u + 15 * d + 3 * f), _ = 9 * d / (u + 15 * d + 3 * f), l = n[0], h = n[1], c = n[2], i = 4 * l / (l + 15 * h + 3 * c) || 0, s = 9 * h / (l + 15 * h + 3 * c) || 0;
  var y = h / d;
  return r = y <= m ? p * y : 116 * Math.pow(y, 1 / 3) - 16, o = 13 * r * (i - g), a = 13 * r * (s - _), [r, o, a];
};
var ku = {
  name: "lchuv",
  channel: ["lightness", "chroma", "hue"],
  alias: ["LCHuv", "cielchuv"],
  min: [0, 0, 0],
  max: [100, 100, 360],
  luv: function(n) {
    var e = n[0], t = n[1], i = n[2], s, r, o;
    return o = i / 360 * 2 * Math.PI, s = t * Math.cos(o), r = t * Math.sin(o), [e, s, r];
  },
  xyz: function(n) {
    return Fl.xyz(ku.luv(n));
  }
};
Fl.lchuv = function(n) {
  var e = n[0], t = n[1], i = n[2], s = Math.sqrt(t * t + i * i), r = Math.atan2(i, t), o = r * 360 / 2 / Math.PI;
  return o < 0 && (o += 360), [e, s, o];
};
Le.lchuv = function(n) {
  return Fl.lchuv(Le.luv(n));
};
function Gu(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var N_ = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
const Qh = /* @__PURE__ */ Gu(N_);
var ec = {
  red: 0,
  orange: 60,
  yellow: 120,
  green: 180,
  blue: 240,
  purple: 300
};
function k_(n) {
  var c, u;
  var e, t = [], i = 1, s;
  if (typeof n == "number")
    return { space: "rgb", values: [n >>> 16, (n & 65280) >>> 8, n & 255], alpha: 1 };
  if (typeof n == "number")
    return { space: "rgb", values: [n >>> 16, (n & 65280) >>> 8, n & 255], alpha: 1 };
  if (n = String(n).toLowerCase(), Qh[n])
    t = Qh[n].slice(), s = "rgb";
  else if (n === "transparent")
    i = 0, s = "rgb", t = [0, 0, 0];
  else if (n[0] === "#") {
    var r = n.slice(1), o = r.length, a = o <= 4;
    i = 1, a ? (t = [
      parseInt(r[0] + r[0], 16),
      parseInt(r[1] + r[1], 16),
      parseInt(r[2] + r[2], 16)
    ], o === 4 && (i = parseInt(r[3] + r[3], 16) / 255)) : (t = [
      parseInt(r[0] + r[1], 16),
      parseInt(r[2] + r[3], 16),
      parseInt(r[4] + r[5], 16)
    ], o === 8 && (i = parseInt(r[6] + r[7], 16) / 255)), t[0] || (t[0] = 0), t[1] || (t[1] = 0), t[2] || (t[2] = 0), s = "rgb";
  } else if (e = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(n)) {
    var l = e[1];
    s = l.replace(/a$/, "");
    var h = s === "cmyk" ? 4 : s === "gray" ? 1 : 3;
    t = e[2].trim().split(/\s*[,\/]\s*|\s+/), s === "color" && (s = t.shift()), t = t.map(function(d, f) {
      if (d[d.length - 1] === "%")
        return d = parseFloat(d) / 100, f === 3 ? d : s === "rgb" ? d * 255 : s[0] === "h" || s[0] === "l" && !f ? d * 100 : s === "lab" ? d * 125 : s === "lch" ? f < 2 ? d * 150 : d * 360 : s[0] === "o" && !f ? d : s === "oklab" ? d * 0.4 : s === "oklch" ? f < 2 ? d * 0.4 : d * 360 : d;
      if (s[f] === "h" || f === 2 && s[s.length - 1] === "h") {
        if (ec[d] !== void 0)
          return ec[d];
        if (d.endsWith("deg"))
          return parseFloat(d);
        if (d.endsWith("turn"))
          return parseFloat(d) * 360;
        if (d.endsWith("grad"))
          return parseFloat(d) * 360 / 400;
        if (d.endsWith("rad"))
          return parseFloat(d) * 180 / Math.PI;
      }
      return d === "none" ? 0 : parseFloat(d);
    }), i = t.length > h ? t.pop() : 1;
  } else
    /[0-9](?:\s|\/|,)/.test(n) && (t = n.match(/([0-9]+)/g).map(function(d) {
      return parseFloat(d);
    }), s = ((u = (c = n.match(/([a-z])/ig)) == null ? void 0 : c.join("")) == null ? void 0 : u.toLowerCase()) || "rgb");
  return {
    space: s,
    values: t,
    alpha: i
  };
}
const Qo = {
  name: "hsl",
  min: [0, 0, 0],
  max: [360, 100, 100],
  channel: ["hue", "saturation", "lightness"],
  alias: ["HSL"],
  rgb: function(n) {
    var e = n[0] / 360, t = n[1] / 100, i = n[2] / 100, s, r, o, a, l, h = 0;
    if (t === 0)
      return l = i * 255, [l, l, l];
    for (r = i < 0.5 ? i * (1 + t) : i + t - i * t, s = 2 * i - r, a = [0, 0, 0]; h < 3; )
      o = e + 1 / 3 * -(h - 1), o < 0 ? o++ : o > 1 && o--, l = 6 * o < 1 ? s + (r - s) * 6 * o : 2 * o < 1 ? r : 3 * o < 2 ? s + (r - s) * (2 / 3 - o) * 6 : s, a[h++] = l * 255;
    return a;
  }
};
Ns.hsl = function(n) {
  var e = n[0] / 255, t = n[1] / 255, i = n[2] / 255, s = Math.min(e, t, i), r = Math.max(e, t, i), o = r - s, a, l, h;
  return r === s ? a = 0 : e === r ? a = (t - i) / o : t === r ? a = 2 + (i - e) / o : i === r && (a = 4 + (e - t) / o), a = Math.min(a * 60, 360), a < 0 && (a += 360), h = (s + r) / 2, r === s ? l = 0 : h <= 0.5 ? l = o / (r + s) : l = o / (2 - r - s), [a, l * 100, h * 100];
};
function G_(n) {
  Array.isArray(n) && n.raw && (n = String.raw(...arguments)), n instanceof Number && (n = +n);
  var e, t = k_(n);
  if (!t.space)
    return [];
  const i = t.space[0] === "h" ? Qo.min : Ns.min, s = t.space[0] === "h" ? Qo.max : Ns.max;
  return e = Array(3), e[0] = Math.min(Math.max(t.values[0], i[0]), s[0]), e[1] = Math.min(Math.max(t.values[1], i[1]), s[1]), e[2] = Math.min(Math.max(t.values[2], i[2]), s[2]), t.space[0] === "h" && (e = Qo.rgb(e)), e.push(Math.min(Math.max(t.alpha, 0), 1)), e;
}
function z_(n) {
  return typeof n == "string" ? n : $u(n);
}
const $_ = 1024, us = {};
let ea = 0;
function U_(n) {
  if (n.length === 4)
    return n;
  const e = n.slice();
  return e[3] = 1, e;
}
function tc(n) {
  const e = Le.lchuv(Ns.xyz(n));
  return e[3] = n[3], e;
}
function V_(n) {
  const e = Le.rgb(ku.xyz(n));
  return e[3] = n[3], e;
}
function Ml(n) {
  if (us.hasOwnProperty(n))
    return us[n];
  if (ea >= $_) {
    let t = 0;
    for (const i in us)
      t++ & 3 || (delete us[i], --ea);
  }
  const e = G_(n);
  if (e.length !== 4)
    throw new Error('Failed to parse "' + n + '" as color');
  for (const t of e)
    if (isNaN(t))
      throw new Error('Failed to parse "' + n + '" as color');
  return zu(e), us[n] = e, ++ea, e;
}
function jn(n) {
  return Array.isArray(n) ? n : Ml(n);
}
function zu(n) {
  return n[0] = _e(n[0] + 0.5 | 0, 0, 255), n[1] = _e(n[1] + 0.5 | 0, 0, 255), n[2] = _e(n[2] + 0.5 | 0, 0, 255), n[3] = _e(n[3], 0, 1), n;
}
function $u(n) {
  let e = n[0];
  e != (e | 0) && (e = e + 0.5 | 0);
  let t = n[1];
  t != (t | 0) && (t = t + 0.5 | 0);
  let i = n[2];
  i != (i | 0) && (i = i + 0.5 | 0);
  const s = n[3] === void 0 ? 1 : Math.round(n[3] * 1e3) / 1e3;
  return "rgba(" + e + "," + t + "," + i + "," + s + ")";
}
function j_(n) {
  try {
    return Ml(n), !0;
  } catch {
    return !1;
  }
}
const Oi = typeof navigator < "u" && typeof navigator.userAgent < "u" ? navigator.userAgent.toLowerCase() : "", Y_ = Oi.includes("firefox"), X_ = Oi.includes("safari") && !Oi.includes("chrom");
X_ && (Oi.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(Oi));
const B_ = Oi.includes("webkit") && !Oi.includes("edge"), Ol = Oi.includes("macintosh"), Uu = typeof devicePixelRatio < "u" ? devicePixelRatio : 1, Vu = typeof WorkerGlobalScope < "u" && typeof OffscreenCanvas < "u" && self instanceof WorkerGlobalScope, Dl = typeof Image < "u" && Image.prototype.decode, W_ = typeof createImageBitmap == "function", ju = function() {
  let n = !1;
  try {
    const e = Object.defineProperty({}, "passive", {
      get: function() {
        n = !0;
      }
    });
    window.addEventListener("_", null, e), window.removeEventListener("_", null, e);
  } catch {
  }
  return n;
}();
function Pe(n, e, t, i) {
  let s;
  return t && t.length ? s = /** @type {HTMLCanvasElement} */
  t.shift() : Vu ? s = new OffscreenCanvas(n || 300, e || 300) : s = document.createElement("canvas"), n && (s.width = n), e && (s.height = e), /** @type {CanvasRenderingContext2D} */
  s.getContext("2d", i);
}
let ta;
function Oa() {
  return ta || (ta = Pe(1, 1)), ta;
}
function ir(n) {
  const e = n.canvas;
  e.width = 1, e.height = 1, n.clearRect(0, 0, 1, 1);
}
function K_(n) {
  let e = n.offsetWidth;
  const t = getComputedStyle(n);
  return e += parseInt(t.marginLeft, 10) + parseInt(t.marginRight, 10), e;
}
function Z_(n) {
  let e = n.offsetHeight;
  const t = getComputedStyle(n);
  return e += parseInt(t.marginTop, 10) + parseInt(t.marginBottom, 10), e;
}
function Yn(n, e) {
  const t = e.parentNode;
  t && t.replaceChild(n, e);
}
function Yr(n) {
  return n && n.parentNode ? n.parentNode.removeChild(n) : null;
}
function Yu(n) {
  for (; n.lastChild; )
    n.removeChild(n.lastChild);
}
function H_(n, e) {
  const t = n.childNodes;
  for (let i = 0; ; ++i) {
    const s = t[i], r = e[i];
    if (!s && !r)
      break;
    if (s !== r) {
      if (!s) {
        n.appendChild(r);
        continue;
      }
      if (!r) {
        n.removeChild(s), --i;
        continue;
      }
      n.insertBefore(r, s);
    }
  }
}
class Xu extends Ks {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y
   * resolution will be assumed.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("./ImageState.js").default|import("./Image.js").Loader} stateOrLoader State.
   */
  constructor(e, t, i, s) {
    super(), this.extent = e, this.pixelRatio_ = i, this.resolution = t, this.state = typeof s == "function" ? M.IDLE : s, this.image_ = null, this.loader = typeof s == "function" ? s : null;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(G.CHANGE);
  }
  /**
   * @return {import("./extent.js").Extent} Extent.
   */
  getExtent() {
    return this.extent;
  }
  /**
   * @return {import('./DataTile.js').ImageLike} Image.
   */
  getImage() {
    return this.image_;
  }
  /**
   * @return {number} PixelRatio.
   */
  getPixelRatio() {
    return this.pixelRatio_;
  }
  /**
   * @return {number|Array<number>} Resolution.
   */
  getResolution() {
    return (
      /** @type {number} */
      this.resolution
    );
  }
  /**
   * @return {import("./ImageState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == M.IDLE && this.loader) {
      this.state = M.LOADING, this.changed();
      const e = this.getResolution(), t = Array.isArray(e) ? e[0] : e;
      gg(
        () => this.loader(
          this.getExtent(),
          t,
          this.getPixelRatio()
        )
      ).then((i) => {
        "image" in i && (this.image_ = i.image), "extent" in i && (this.extent = i.extent), "resolution" in i && (this.resolution = i.resolution), "pixelRatio" in i && (this.pixelRatio_ = i.pixelRatio), (i instanceof HTMLImageElement || i instanceof ImageBitmap || i instanceof HTMLCanvasElement || i instanceof HTMLVideoElement) && (this.image_ = i), this.state = M.LOADED;
      }).catch((i) => {
        this.state = M.ERROR, console.error(i);
      }).finally(() => this.changed());
    }
  }
  /**
   * @param {import('./DataTile.js').ImageLike} image The image.
   */
  setImage(e) {
    this.image_ = e;
  }
  /**
   * @param {number|Array<number>} resolution Resolution.
   */
  setResolution(e) {
    this.resolution = e;
  }
}
function q_(n, e, t) {
  const i = (
    /** @type {HTMLImageElement} */
    n
  );
  let s = !0, r = !1, o = !1;
  const a = [
    Fs(i, G.LOAD, function() {
      o = !0, r || e();
    })
  ];
  return i.src && Dl ? (r = !0, i.decode().then(function() {
    s && e();
  }).catch(function(l) {
    s && (o ? e() : t());
  })) : a.push(Fs(i, G.ERROR, t)), function() {
    s = !1, a.forEach(he);
  };
}
function J_(n, e) {
  return new Promise((t, i) => {
    function s() {
      o(), t(n);
    }
    function r() {
      o(), i(new Error("Image load error"));
    }
    function o() {
      n.removeEventListener("load", s), n.removeEventListener("error", r);
    }
    n.addEventListener("load", s), n.addEventListener("error", r), e && (n.src = e);
  });
}
function Bu(n, e) {
  return e && (n.src = e), n.src && Dl ? new Promise(
    (t, i) => n.decode().then(() => t(n)).catch(
      (s) => n.complete && n.width ? t(n) : i(s)
    )
  ) : J_(n);
}
function Wu(n, e) {
  return e && (n.src = e), n.src && Dl && W_ ? n.decode().then(() => createImageBitmap(n)).catch((t) => {
    if (n.complete && n.width)
      return n;
    throw t;
  }) : Bu(n);
}
class Q_ {
  constructor() {
    this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 32;
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.cacheSize_ > this.maxCacheSize_;
  }
  /**
   * FIXME empty description for jsdoc
   */
  expire() {
    if (this.canExpireCache()) {
      let e = 0;
      for (const t in this.cache_) {
        const i = this.cache_[t];
        !(e++ & 3) && !i.hasListener() && (delete this.cache_[t], delete this.patternCache_[t], --this.cacheSize_);
      }
    }
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {import("./IconImage.js").default} Icon image.
   */
  get(e, t, i) {
    const s = ia(e, t, i);
    return s in this.cache_ ? this.cache_[s] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {CanvasPattern} Icon image.
   */
  getPattern(e, t, i) {
    const s = ia(e, t, i);
    return s in this.patternCache_ ? this.patternCache_[s] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @param {import("./IconImage.js").default|null} iconImage Icon image.
   * @param {boolean} [pattern] Also cache a `'repeat'` pattern with this `iconImage`.
   */
  set(e, t, i, s, r) {
    const o = ia(e, t, i), a = o in this.cache_;
    this.cache_[o] = s, r && (s.getImageState() === M.IDLE && s.load(), s.getImageState() === M.LOADING ? s.ready().then(() => {
      this.patternCache_[o] = Oa().createPattern(
        s.getImage(1),
        "repeat"
      );
    }) : this.patternCache_[o] = Oa().createPattern(
      s.getImage(1),
      "repeat"
    )), a || ++this.cacheSize_;
  }
  /**
   * Set the cache size of the icon cache. Default is `32`. Change this value when
   * your map uses more than 32 different icon images and you are not caching icon
   * styles on the application level.
   * @param {number} maxCacheSize Cache max size.
   * @api
   */
  setSize(e) {
    this.maxCacheSize_ = e, this.expire();
  }
}
function ia(n, e, t) {
  const i = t ? jn(t) : "null";
  return e + ":" + n + ":" + i;
}
const bt = new Q_();
let ds = null;
class em extends Ks {
  /**
   * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap|null} image Image.
   * @param {string|undefined} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default|undefined} imageState Image state.
   * @param {import("../color.js").Color|string|null} color Color.
   */
  constructor(e, t, i, s, r) {
    super(), this.hitDetectionImage_ = null, this.image_ = e, this.crossOrigin_ = i, this.canvas_ = {}, this.color_ = r, this.imageState_ = s === void 0 ? M.IDLE : s, this.size_ = e && e.width && e.height ? [e.width, e.height] : null, this.src_ = t, this.tainted_, this.ready_ = null;
  }
  /**
   * @private
   */
  initializeImage_() {
    this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_);
  }
  /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */
  isTainted_() {
    if (this.tainted_ === void 0 && this.imageState_ === M.LOADED) {
      ds || (ds = Pe(1, 1, void 0, {
        willReadFrequently: !0
      })), ds.drawImage(this.image_, 0, 0);
      try {
        ds.getImageData(0, 0, 1, 1), this.tainted_ = !1;
      } catch {
        ds = null, this.tainted_ = !0;
      }
    }
    return this.tainted_ === !0;
  }
  /**
   * @private
   */
  dispatchChangeEvent_() {
    this.dispatchEvent(G.CHANGE);
  }
  /**
   * @private
   */
  handleImageError_() {
    this.imageState_ = M.ERROR, this.dispatchChangeEvent_();
  }
  /**
   * @private
   */
  handleImageLoad_() {
    this.imageState_ = M.LOADED, this.size_ = [this.image_.width, this.image_.height], this.dispatchChangeEvent_();
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
   */
  getImage(e) {
    return this.image_ || this.initializeImage_(), this.replaceColor_(e), this.canvas_[e] ? this.canvas_[e] : this.image_;
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */
  getPixelRatio(e) {
    return this.replaceColor_(e), this.canvas_[e] ? e : 1;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   */
  getHitDetectionImage() {
    if (this.image_ || this.initializeImage_(), !this.hitDetectionImage_)
      if (this.isTainted_()) {
        const e = this.size_[0], t = this.size_[1], i = Pe(e, t);
        i.fillRect(0, 0, e, t), this.hitDetectionImage_ = i.canvas;
      } else
        this.hitDetectionImage_ = this.image_;
    return this.hitDetectionImage_;
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */
  getSize() {
    return this.size_;
  }
  /**
   * @return {string|undefined} Image src.
   */
  getSrc() {
    return this.src_;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.imageState_ === M.IDLE) {
      this.image_ || this.initializeImage_(), this.imageState_ = M.LOADING;
      try {
        this.src_ !== void 0 && (this.image_.src = this.src_);
      } catch {
        this.handleImageError_();
      }
      this.image_ instanceof HTMLImageElement && Bu(this.image_, this.src_).then((e) => {
        this.image_ = e, this.handleImageLoad_();
      }).catch(this.handleImageError_.bind(this));
    }
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */
  replaceColor_(e) {
    if (!this.color_ || this.canvas_[e] || this.imageState_ !== M.LOADED)
      return;
    const t = this.image_, i = document.createElement("canvas");
    i.width = Math.ceil(t.width * e), i.height = Math.ceil(t.height * e);
    const s = i.getContext("2d");
    s.scale(e, e), s.drawImage(t, 0, 0), s.globalCompositeOperation = "multiply", s.fillStyle = z_(this.color_), s.fillRect(0, 0, i.width / e, i.height / e), s.globalCompositeOperation = "destination-in", s.drawImage(t, 0, 0), this.canvas_[e] = i;
  }
  /**
   * @return {Promise<void>} Promise that resolves when the image is loaded.
   */
  ready() {
    return this.ready_ || (this.ready_ = new Promise((e) => {
      this.imageState_ === M.LOADED || this.imageState_ === M.ERROR ? e() : this.addEventListener(G.CHANGE, function t() {
        (this.imageState_ === M.LOADED || this.imageState_ === M.ERROR) && (this.removeEventListener(G.CHANGE, t), e());
      });
    })), this.ready_;
  }
}
function Nl(n, e, t, i, s, r) {
  let o = e === void 0 ? void 0 : bt.get(e, t, s);
  return o || (o = new em(
    n,
    n instanceof HTMLImageElement ? n.src || void 0 : e,
    t,
    i,
    s
  ), bt.set(e, t, s, o, r)), r && o && !bt.getPattern(e, t, s) && bt.set(e, t, s, o, r), o;
}
function At(n) {
  return n ? Array.isArray(n) ? $u(n) : typeof n == "object" && "src" in n ? tm(n) : n : null;
}
function tm(n) {
  if (!n.offset || !n.size)
    return bt.getPattern(n.src, "anonymous", n.color);
  const e = n.src + ":" + n.offset, t = bt.getPattern(
    e,
    void 0,
    n.color
  );
  if (t)
    return t;
  const i = bt.get(n.src, "anonymous", null);
  if (i.getImageState() !== M.LOADED)
    return null;
  const s = Pe(
    n.size[0],
    n.size[1]
  );
  return s.drawImage(
    i.getImage(1),
    n.offset[0],
    n.offset[1],
    n.size[0],
    n.size[1],
    0,
    0,
    n.size[0],
    n.size[1]
  ), Nl(
    s.canvas,
    e,
    void 0,
    M.LOADED,
    n.color,
    !0
  ), bt.getPattern(e, void 0, n.color);
}
const xr = "ol-hidden", im = "ol-selectable", Dt = "ol-unselectable", ic = "ol-unsupported", rn = "ol-control", Xr = "ol-collapsed", nm = new RegExp(
  [
    "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
    "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
    "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
    "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
    `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
  ].join(""),
  "i"
), nc = [
  "style",
  "variant",
  "weight",
  "size",
  "lineHeight",
  "family"
], Ku = function(n) {
  const e = n.match(nm);
  if (!e)
    return null;
  const t = (
    /** @type {FontParameters} */
    {
      lineHeight: "normal",
      size: "1.2em",
      style: "normal",
      weight: "normal",
      variant: "normal"
    }
  );
  for (let i = 0, s = nc.length; i < s; ++i) {
    const r = e[i + 1];
    r !== void 0 && (t[nc[i]] = r);
  }
  return t.families = t.family.split(/,\s?/), t;
}, Zu = "10px sans-serif", Ye = "#000", Xn = "round", Jt = [], Qt = 0, Bn = "round", ks = 10, Gs = "#000", zs = "center", Br = "middle", Bi = [0, 0, 0, 0], $s = 1, Bt = new vt();
let Cn = null, Da;
const Na = {}, sm = function() {
  const e = "32px ", t = ["monospace", "serif"], i = t.length, s = "wmytzilWMYTZIL@#/&?$%10";
  let r, o;
  function a(h, c, u) {
    let d = !0;
    for (let f = 0; f < i; ++f) {
      const g = t[f];
      if (o = Wr(
        h + " " + c + " " + e + g,
        s
      ), u != g) {
        const _ = Wr(
          h + " " + c + " " + e + u + "," + g,
          s
        );
        d = d && _ != o;
      }
    }
    return !!d;
  }
  function l() {
    let h = !0;
    const c = Bt.getKeys();
    for (let u = 0, d = c.length; u < d; ++u) {
      const f = c[u];
      Bt.get(f) < 100 && (a.apply(this, f.split(`
`)) ? (Ws(Na), Cn = null, Da = void 0, Bt.set(f, 100)) : (Bt.set(f, Bt.get(f) + 1, !0), h = !1));
    }
    h && (clearInterval(r), r = void 0);
  }
  return function(h) {
    const c = Ku(h);
    if (!c)
      return;
    const u = c.families;
    for (let d = 0, f = u.length; d < f; ++d) {
      const g = u[d], _ = c.style + `
` + c.weight + `
` + g;
      Bt.get(_) === void 0 && (Bt.set(_, 100, !0), a(c.style, c.weight, g) || (Bt.set(_, 0, !0), r === void 0 && (r = setInterval(l, 32))));
    }
  };
}(), rm = /* @__PURE__ */ function() {
  let n;
  return function(e) {
    let t = Na[e];
    if (t == null) {
      if (Vu) {
        const i = Ku(e), s = Hu(e, "Žg");
        t = (isNaN(Number(i.lineHeight)) ? 1.2 : Number(i.lineHeight)) * (s.actualBoundingBoxAscent + s.actualBoundingBoxDescent);
      } else
        n || (n = document.createElement("div"), n.innerHTML = "M", n.style.minHeight = "0", n.style.maxHeight = "none", n.style.height = "auto", n.style.padding = "0", n.style.border = "none", n.style.position = "absolute", n.style.display = "block", n.style.left = "-99999px"), n.style.font = e, document.body.appendChild(n), t = n.offsetHeight, document.body.removeChild(n);
      Na[e] = t;
    }
    return t;
  };
}();
function Hu(n, e) {
  return Cn || (Cn = Pe(1, 1)), n != Da && (Cn.font = n, Da = Cn.font), Cn.measureText(e);
}
function Wr(n, e) {
  return Hu(n, e).width;
}
function sc(n, e, t) {
  if (e in t)
    return t[e];
  const i = e.split(`
`).reduce((s, r) => Math.max(s, Wr(n, r)), 0);
  return t[e] = i, i;
}
function om(n, e) {
  const t = [], i = [], s = [];
  let r = 0, o = 0, a = 0, l = 0;
  for (let h = 0, c = e.length; h <= c; h += 2) {
    const u = e[h];
    if (u === `
` || h === c) {
      r = Math.max(r, o), s.push(o), o = 0, a += l;
      continue;
    }
    const d = e[h + 1] || n.font, f = Wr(d, u);
    t.push(f), o += f;
    const g = rm(d);
    i.push(g), l = Math.max(l, g);
  }
  return { width: r, height: a, widths: t, heights: i, lineWidths: s };
}
function am(n, e, t, i, s, r, o, a, l, h, c) {
  n.save(), t !== 1 && (n.globalAlpha === void 0 ? n.globalAlpha = (u) => u.globalAlpha *= t : n.globalAlpha *= t), e && n.transform.apply(n, e), /** @type {*} */
  i.contextInstructions ? (n.translate(l, h), n.scale(c[0], c[1]), lm(
    /** @type {Label} */
    i,
    n
  )) : c[0] < 0 || c[1] < 0 ? (n.translate(l, h), n.scale(c[0], c[1]), n.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    i,
    s,
    r,
    o,
    a,
    0,
    0,
    o,
    a
  )) : n.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    i,
    s,
    r,
    o,
    a,
    l,
    h,
    o * c[0],
    a * c[1]
  ), n.restore();
}
function lm(n, e) {
  const t = n.contextInstructions;
  for (let i = 0, s = t.length; i < s; i += 2)
    Array.isArray(t[i + 1]) ? e[t[i]].apply(
      e,
      t[i + 1]
    ) : e[t[i]] = t[i + 1];
}
class kl extends Nu {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    super({
      opacity: 1,
      rotateWithView: e.rotateWithView !== void 0 ? e.rotateWithView : !1,
      rotation: e.rotation !== void 0 ? e.rotation : 0,
      scale: e.scale !== void 0 ? e.scale : 1,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      declutterMode: e.declutterMode
    }), this.canvases_, this.hitDetectionCanvas_ = null, this.fill_ = e.fill !== void 0 ? e.fill : null, this.origin_ = [0, 0], this.points_ = e.points, this.radius_ = e.radius, this.radius2_ = e.radius2, this.angle_ = e.angle !== void 0 ? e.angle : 0, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.size_, this.renderOptions_, this.imageState_ = this.fill_ && this.fill_.loading() ? M.LOADING : M.LOADED, this.imageState_ === M.LOADING && this.ready().then(() => this.imageState_ = M.LOADED), this.render();
  }
  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale(), t = new kl({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(e) ? e.slice() : e,
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return t.setOpacity(this.getOpacity()), t;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    const e = this.size_, t = this.getDisplacement(), i = this.getScaleArray();
    return [
      e[0] / 2 - t[0] / i[0],
      e[1] / 2 + t[1] / i[1]
    ];
  }
  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */
  getAngle() {
    return this.angle_;
  }
  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e, this.render();
  }
  /**
   * @return {HTMLCanvasElement} Image element.
   */
  getHitDetectionImage() {
    return this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(
      this.renderOptions_
    )), this.hitDetectionCanvas_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement} Image or Canvas element.
   * @api
   */
  getImage(e) {
    let t = this.canvases_[e];
    if (!t) {
      const i = this.renderOptions_, s = Pe(
        i.size * e,
        i.size * e
      );
      this.draw_(i, s, e), t = s.canvas, this.canvases_[e] = t;
    }
    return t;
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(e) {
    return e;
  }
  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.size_;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    return this.origin_;
  }
  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */
  getPoints() {
    return this.points_;
  }
  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return this.radius_;
  }
  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */
  getRadius2() {
    return this.radius2_;
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   */
  getSize() {
    return this.size_;
  }
  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e, this.render();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(e) {
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(e) {
  }
  /**
   * Calculate additional canvas size needed for the miter.
   * @param {string} lineJoin Line join
   * @param {number} strokeWidth Stroke width
   * @param {number} miterLimit Miter limit
   * @return {number} Additional canvas size needed
   * @private
   */
  calculateLineJoinSize_(e, t, i) {
    if (t === 0 || this.points_ === 1 / 0 || e !== "bevel" && e !== "miter")
      return t;
    let s = this.radius_, r = this.radius2_ === void 0 ? s : this.radius2_;
    if (s < r) {
      const w = s;
      s = r, r = w;
    }
    const o = this.radius2_ === void 0 ? this.points_ : this.points_ * 2, a = 2 * Math.PI / o, l = r * Math.sin(a), h = Math.sqrt(r * r - l * l), c = s - h, u = Math.sqrt(l * l + c * c), d = u / l;
    if (e === "miter" && d <= i)
      return d * t;
    const f = t / 2 / d, g = t / 2 * (c / u), m = Math.sqrt((s + f) * (s + f) + g * g) - s;
    if (this.radius2_ === void 0 || e === "bevel")
      return m * 2;
    const p = s * Math.sin(a), y = Math.sqrt(s * s - p * p), x = r - y, C = Math.sqrt(p * p + x * x) / p;
    if (C <= i) {
      const w = C * t / 2 - r - s;
      return 2 * Math.max(m, w);
    }
    return m * 2;
  }
  /**
   * @return {RenderOptions}  The render options
   * @protected
   */
  createRenderOptions() {
    let e = Xn, t = Bn, i = 0, s = null, r = 0, o, a = 0;
    this.stroke_ && (o = At(this.stroke_.getColor() ?? Gs), a = this.stroke_.getWidth() ?? $s, s = this.stroke_.getLineDash(), r = this.stroke_.getLineDashOffset() ?? 0, t = this.stroke_.getLineJoin() ?? Bn, e = this.stroke_.getLineCap() ?? Xn, i = this.stroke_.getMiterLimit() ?? ks);
    const l = this.calculateLineJoinSize_(t, a, i), h = Math.max(this.radius_, this.radius2_ || 0), c = Math.ceil(2 * h + l);
    return {
      strokeStyle: o,
      strokeWidth: a,
      size: c,
      lineCap: e,
      lineDash: s,
      lineDashOffset: r,
      lineJoin: t,
      miterLimit: i
    };
  }
  /**
   * @protected
   */
  render() {
    this.renderOptions_ = this.createRenderOptions();
    const e = this.renderOptions_.size;
    this.canvases_ = {}, this.hitDetectionCanvas_ = null, this.size_ = [e, e];
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} pixelRatio The pixel ratio.
   */
  draw_(e, t, i) {
    if (t.scale(i, i), t.translate(e.size / 2, e.size / 2), this.createPath_(t), this.fill_) {
      let s = this.fill_.getColor();
      s === null && (s = Ye), t.fillStyle = At(s), t.fill();
    }
    e.strokeStyle && (t.strokeStyle = e.strokeStyle, t.lineWidth = e.strokeWidth, e.lineDash && (t.setLineDash(e.lineDash), t.lineDashOffset = e.lineDashOffset), t.lineCap = e.lineCap, t.lineJoin = e.lineJoin, t.miterLimit = e.miterLimit, t.stroke());
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @return {HTMLCanvasElement} Canvas containing the icon
   */
  createHitDetectionCanvas_(e) {
    let t;
    if (this.fill_) {
      let i = this.fill_.getColor(), s = 0;
      typeof i == "string" && (i = jn(i)), i === null ? s = 1 : Array.isArray(i) && (s = i.length === 4 ? i[3] : 1), s === 0 && (t = Pe(e.size, e.size), this.drawHitDetectionCanvas_(e, t));
    }
    return t ? t.canvas : this.getImage(1);
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context The context to draw in.
   */
  createPath_(e) {
    let t = this.points_;
    const i = this.radius_;
    if (t === 1 / 0)
      e.arc(0, 0, i, 0, 2 * Math.PI);
    else {
      const s = this.radius2_ === void 0 ? i : this.radius2_;
      this.radius2_ !== void 0 && (t *= 2);
      const r = this.angle_ - Math.PI / 2, o = 2 * Math.PI / t;
      for (let a = 0; a < t; a++) {
        const l = r + a * o, h = a % 2 === 0 ? i : s;
        e.lineTo(h * Math.cos(l), h * Math.sin(l));
      }
      e.closePath();
    }
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   */
  drawHitDetectionCanvas_(e, t) {
    t.translate(e.size / 2, e.size / 2), this.createPath_(t), t.fillStyle = Ye, t.fill(), e.strokeStyle && (t.strokeStyle = e.strokeStyle, t.lineWidth = e.strokeWidth, e.lineDash && (t.setLineDash(e.lineDash), t.lineDashOffset = e.lineDashOffset), t.lineJoin = e.lineJoin, t.miterLimit = e.miterLimit, t.stroke());
  }
  ready() {
    return this.fill_ ? this.fill_.ready() : Promise.resolve();
  }
}
const qu = kl;
class Gl extends qu {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || { radius: 5 }, super({
      points: 1 / 0,
      fill: e.fill,
      radius: e.radius,
      stroke: e.stroke,
      scale: e.scale !== void 0 ? e.scale : 1,
      rotation: e.rotation !== void 0 ? e.rotation : 0,
      rotateWithView: e.rotateWithView !== void 0 ? e.rotateWithView : !1,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      declutterMode: e.declutterMode
    });
  }
  /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale(), t = new Gl({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      radius: this.getRadius(),
      scale: Array.isArray(e) ? e.slice() : e,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return t.setOpacity(this.getOpacity()), t;
  }
  /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */
  setRadius(e) {
    this.radius_ = e, this.render();
  }
}
const zl = Gl;
class $l {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.patternImage_ = null, this.color_ = null, e.color !== void 0 && this.setColor(e.color);
  }
  /**
   * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */
  clone() {
    const e = this.getColor();
    return new $l({
      color: Array.isArray(e) ? e.slice() : e || void 0
    });
  }
  /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} color Color.
   * @api
   */
  setColor(e) {
    if (e !== null && typeof e == "object" && "src" in e) {
      const t = Nl(
        null,
        e.src,
        "anonymous",
        void 0,
        e.offset ? null : e.color ? e.color : null,
        !(e.offset && e.size)
      );
      t.ready().then(() => {
        this.patternImage_ = null;
      }), t.getImageState() === M.IDLE && t.load(), t.getImageState() === M.LOADING && (this.patternImage_ = t);
    }
    this.color_ = e;
  }
  /**
   * @return {boolean} The fill style is loading an image pattern.
   */
  loading() {
    return !!this.patternImage_;
  }
  /**
   * @return {Promise<void>} `false` or a promise that resolves when the style is ready to use.
   */
  ready() {
    return this.patternImage_ ? this.patternImage_.ready() : Promise.resolve();
  }
}
const Di = $l;
class Ul {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.color_ = e.color !== void 0 ? e.color : null, this.lineCap_ = e.lineCap, this.lineDash_ = e.lineDash !== void 0 ? e.lineDash : null, this.lineDashOffset_ = e.lineDashOffset, this.lineJoin_ = e.lineJoin, this.miterLimit_ = e.miterLimit, this.width_ = e.width;
  }
  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */
  clone() {
    const e = this.getColor();
    return new Ul({
      color: Array.isArray(e) ? e.slice() : e || void 0,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth()
    });
  }
  /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */
  getLineCap() {
    return this.lineCap_;
  }
  /**
   * Get the line dash style for the stroke.
   * @return {Array<number>|null} Line dash.
   * @api
   */
  getLineDash() {
    return this.lineDash_;
  }
  /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */
  getLineDashOffset() {
    return this.lineDashOffset_;
  }
  /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */
  getLineJoin() {
    return this.lineJoin_;
  }
  /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */
  getMiterLimit() {
    return this.miterLimit_;
  }
  /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */
  getWidth() {
    return this.width_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */
  setColor(e) {
    this.color_ = e;
  }
  /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */
  setLineCap(e) {
    this.lineCap_ = e;
  }
  /**
   * Set the line dash.
   *
   * @param {Array<number>|null} lineDash Line dash.
   * @api
   */
  setLineDash(e) {
    this.lineDash_ = e;
  }
  /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */
  setLineDashOffset(e) {
    this.lineDashOffset_ = e;
  }
  /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */
  setLineJoin(e) {
    this.lineJoin_ = e;
  }
  /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */
  setMiterLimit(e) {
    this.miterLimit_ = e;
  }
  /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */
  setWidth(e) {
    this.width_ = e;
  }
}
const Ai = Ul;
class Ci {
  /**
   * @param {Options} [options] Style options.
   */
  constructor(e) {
    e = e || {}, this.geometry_ = null, this.geometryFunction_ = rc, e.geometry !== void 0 && this.setGeometry(e.geometry), this.fill_ = e.fill !== void 0 ? e.fill : null, this.image_ = e.image !== void 0 ? e.image : null, this.renderer_ = e.renderer !== void 0 ? e.renderer : null, this.hitDetectionRenderer_ = e.hitDetectionRenderer !== void 0 ? e.hitDetectionRenderer : null, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.text_ = e.text !== void 0 ? e.text : null, this.zIndex_ = e.zIndex;
  }
  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */
  clone() {
    let e = this.getGeometry();
    return e && typeof e == "object" && (e = /** @type {import("../geom/Geometry.js").default} */
    e.clone()), new Ci({
      geometry: e ?? void 0,
      fill: this.getFill() ? this.getFill().clone() : void 0,
      image: this.getImage() ? this.getImage().clone() : void 0,
      renderer: this.getRenderer() ?? void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      text: this.getText() ? this.getText().clone() : void 0,
      zIndex: this.getZIndex()
    });
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setRenderer(e) {
    this.renderer_ = e;
  }
  /**
   * Sets a custom renderer function for this style used
   * in hit detection.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setHitDetectionRenderer(e) {
    this.hitDetectionRenderer_ = e;
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getHitDetectionRenderer() {
    return this.hitDetectionRenderer_;
  }
  /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */
  getGeometry() {
    return this.geometry_;
  }
  /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */
  getGeometryFunction() {
    return this.geometryFunction_;
  }
  /**
   * Get the fill style.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e;
  }
  /**
   * Get the image style.
   * @return {import("./Image.js").default|null} Image style.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */
  setImage(e) {
    this.image_ = e;
  }
  /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e;
  }
  /**
   * Get the text style.
   * @return {import("./Text.js").default|null} Text style.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */
  setText(e) {
    this.text_ = e;
  }
  /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */
  getZIndex() {
    return this.zIndex_;
  }
  /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */
  setGeometry(e) {
    typeof e == "function" ? this.geometryFunction_ = e : typeof e == "string" ? this.geometryFunction_ = function(t) {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        t.get(e)
      );
    } : e ? e !== void 0 && (this.geometryFunction_ = function() {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        e
      );
    }) : this.geometryFunction_ = rc, this.geometry_ = e;
  }
  /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */
  setZIndex(e) {
    this.zIndex_ = e;
  }
}
function hm(n) {
  let e;
  if (typeof n == "function")
    e = n;
  else {
    let t;
    Array.isArray(n) ? t = n : (Q(
      typeof /** @type {?} */
      n.getZIndex == "function",
      "Expected an `Style` or an array of `Style`"
    ), t = [
      /** @type {Style} */
      n
    ]), e = function() {
      return t;
    };
  }
  return e;
}
let na = null;
function cm(n, e) {
  if (!na) {
    const t = new Di({
      color: "rgba(255,255,255,0.4)"
    }), i = new Ai({
      color: "#3399CC",
      width: 1.25
    });
    na = [
      new Ci({
        image: new zl({
          fill: t,
          stroke: i,
          radius: 5
        }),
        fill: t,
        stroke: i
      })
    ];
  }
  return na;
}
function Ju() {
  const n = {}, e = [255, 255, 255, 1], t = [0, 153, 255, 1], i = 3;
  return n.Polygon = [
    new Ci({
      fill: new Di({
        color: [255, 255, 255, 0.5]
      })
    })
  ], n.MultiPolygon = n.Polygon, n.LineString = [
    new Ci({
      stroke: new Ai({
        color: e,
        width: i + 2
      })
    }),
    new Ci({
      stroke: new Ai({
        color: t,
        width: i
      })
    })
  ], n.MultiLineString = n.LineString, n.Circle = n.Polygon.concat(n.LineString), n.Point = [
    new Ci({
      image: new zl({
        radius: i * 2,
        fill: new Di({
          color: t
        }),
        stroke: new Ai({
          color: e,
          width: i / 2
        })
      }),
      zIndex: 1 / 0
    })
  ], n.MultiPoint = n.Point, n.GeometryCollection = n.Polygon.concat(
    n.LineString,
    n.Point
  ), n;
}
function rc(n) {
  return n.getGeometry();
}
const Ft = Ci;
function oc(n, e, t, i) {
  return t !== void 0 && i !== void 0 ? [t / n, i / e] : t !== void 0 ? t / n : i !== void 0 ? i / e : 1;
}
class Vl extends Nu {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = e.opacity !== void 0 ? e.opacity : 1, i = e.rotation !== void 0 ? e.rotation : 0, s = e.scale !== void 0 ? e.scale : 1, r = e.rotateWithView !== void 0 ? e.rotateWithView : !1;
    super({
      opacity: t,
      rotation: i,
      scale: s,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      rotateWithView: r,
      declutterMode: e.declutterMode
    }), this.anchor_ = e.anchor !== void 0 ? e.anchor : [0.5, 0.5], this.normalizedAnchor_ = null, this.anchorOrigin_ = e.anchorOrigin !== void 0 ? e.anchorOrigin : "top-left", this.anchorXUnits_ = e.anchorXUnits !== void 0 ? e.anchorXUnits : "fraction", this.anchorYUnits_ = e.anchorYUnits !== void 0 ? e.anchorYUnits : "fraction", this.crossOrigin_ = e.crossOrigin !== void 0 ? e.crossOrigin : null;
    const o = e.img !== void 0 ? e.img : null;
    let a = e.src;
    Q(
      !(a !== void 0 && o),
      "`image` and `src` cannot be provided at the same time"
    ), (a === void 0 || a.length === 0) && o && (a = /** @type {HTMLImageElement} */
    o.src || j(o)), Q(
      a !== void 0 && a.length > 0,
      "A defined and non-empty `src` or `image` must be provided"
    ), Q(
      !((e.width !== void 0 || e.height !== void 0) && e.scale !== void 0),
      "`width` or `height` cannot be provided together with `scale`"
    );
    let l;
    if (e.src !== void 0 ? l = M.IDLE : o !== void 0 && (o instanceof HTMLImageElement ? o.complete ? l = o.src ? M.LOADED : M.IDLE : l = M.LOADING : l = M.LOADED), this.color_ = e.color !== void 0 ? jn(e.color) : null, this.iconImage_ = Nl(
      o,
      /** @type {string} */
      a,
      this.crossOrigin_,
      l,
      this.color_
    ), this.offset_ = e.offset !== void 0 ? e.offset : [0, 0], this.offsetOrigin_ = e.offsetOrigin !== void 0 ? e.offsetOrigin : "top-left", this.origin_ = null, this.size_ = e.size !== void 0 ? e.size : null, e.width !== void 0 || e.height !== void 0) {
      let h, c;
      if (e.size)
        [h, c] = e.size;
      else {
        const u = this.getImage(1);
        if (u.width && u.height)
          h = u.width, c = u.height;
        else if (u instanceof HTMLImageElement) {
          this.initialOptions_ = e;
          const d = () => {
            if (this.unlistenImageChange(d), !this.initialOptions_)
              return;
            const f = this.iconImage_.getSize();
            this.setScale(
              oc(
                f[0],
                f[1],
                e.width,
                e.height
              )
            );
          };
          this.listenImageChange(d);
          return;
        }
      }
      h !== void 0 && this.setScale(
        oc(h, c, e.width, e.height)
      );
    }
  }
  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   */
  clone() {
    let e, t, i;
    return this.initialOptions_ ? (t = this.initialOptions_.width, i = this.initialOptions_.height) : (e = this.getScale(), e = Array.isArray(e) ? e.slice() : e), new Vl({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
      crossOrigin: this.crossOrigin_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale: e,
      width: t,
      height: i,
      size: this.size_ !== null ? this.size_.slice() : void 0,
      src: this.getSrc(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    let e = this.normalizedAnchor_;
    if (!e) {
      e = this.anchor_;
      const s = this.getSize();
      if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
        if (!s)
          return null;
        e = this.anchor_.slice(), this.anchorXUnits_ == "fraction" && (e[0] *= s[0]), this.anchorYUnits_ == "fraction" && (e[1] *= s[1]);
      }
      if (this.anchorOrigin_ != "top-left") {
        if (!s)
          return null;
        e === this.anchor_ && (e = this.anchor_.slice()), (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") && (e[0] = -e[0] + s[0]), (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") && (e[1] = -e[1] + s[1]);
      }
      this.normalizedAnchor_ = e;
    }
    const t = this.getDisplacement(), i = this.getScaleArray();
    return [
      e[0] - t[0] / i[0],
      e[1] + t[1] / i[1]
    ];
  }
  /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */
  setAnchor(e) {
    this.anchor_ = e, this.normalizedAnchor_ = null;
  }
  /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
   * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
   * @api
   */
  getImage(e) {
    return this.iconImage_.getImage(e);
  }
  /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ratio of the image.
   * @api
   */
  getPixelRatio(e) {
    return this.iconImage_.getPixelRatio(e);
  }
  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.iconImage_.getSize();
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.iconImage_.getImageState();
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   */
  getHitDetectionImage() {
    return this.iconImage_.getHitDetectionImage();
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    if (this.origin_)
      return this.origin_;
    let e = this.offset_;
    if (this.offsetOrigin_ != "top-left") {
      const t = this.getSize(), i = this.iconImage_.getSize();
      if (!t || !i)
        return null;
      e = e.slice(), (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") && (e[0] = i[0] - t[0] - e[0]), (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") && (e[1] = i[1] - t[1] - e[1]);
    }
    return this.origin_ = e, this.origin_;
  }
  /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */
  getSrc() {
    return this.iconImage_.getSrc();
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   */
  getSize() {
    return this.size_ ? this.size_ : this.iconImage_.getSize();
  }
  /**
   * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon width (in pixels).
   * @api
   */
  getWidth() {
    const e = this.getScaleArray();
    if (this.size_)
      return this.size_[0] * e[0];
    if (this.iconImage_.getImageState() == M.LOADED)
      return this.iconImage_.getSize()[0] * e[0];
  }
  /**
   * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon height (in pixels).
   * @api
   */
  getHeight() {
    const e = this.getScaleArray();
    if (this.size_)
      return this.size_[1] * e[1];
    if (this.iconImage_.getImageState() == M.LOADED)
      return this.iconImage_.getSize()[1] * e[1];
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(e) {
    delete this.initialOptions_, super.setScale(e);
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(e) {
    this.iconImage_.addEventListener(G.CHANGE, e);
  }
  /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   */
  load() {
    this.iconImage_.load();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(e) {
    this.iconImage_.removeEventListener(G.CHANGE, e);
  }
  ready() {
    return this.iconImage_.ready();
  }
}
const vo = Vl, um = "#333";
class jl {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.font_ = e.font, this.rotation_ = e.rotation, this.rotateWithView_ = e.rotateWithView, this.scale_ = e.scale, this.scaleArray_ = $e(e.scale !== void 0 ? e.scale : 1), this.text_ = e.text, this.textAlign_ = e.textAlign, this.justify_ = e.justify, this.repeat_ = e.repeat, this.textBaseline_ = e.textBaseline, this.fill_ = e.fill !== void 0 ? e.fill : new Di({ color: um }), this.maxAngle_ = e.maxAngle !== void 0 ? e.maxAngle : Math.PI / 4, this.placement_ = e.placement !== void 0 ? e.placement : "point", this.overflow_ = !!e.overflow, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.offsetX_ = e.offsetX !== void 0 ? e.offsetX : 0, this.offsetY_ = e.offsetY !== void 0 ? e.offsetY : 0, this.backgroundFill_ = e.backgroundFill ? e.backgroundFill : null, this.backgroundStroke_ = e.backgroundStroke ? e.backgroundStroke : null, this.padding_ = e.padding === void 0 ? null : e.padding, this.declutterMode_ = e.declutterMode;
  }
  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale();
    return new jl({
      font: this.getFont(),
      placement: this.getPlacement(),
      repeat: this.getRepeat(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(e) ? e.slice() : e,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      justify: this.getJustify(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
      padding: this.getPadding() || void 0,
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */
  getOverflow() {
    return this.overflow_;
  }
  /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */
  getFont() {
    return this.font_;
  }
  /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */
  getMaxAngle() {
    return this.maxAngle_;
  }
  /**
   * Get the label placement.
   * @return {TextPlacement} Text placement.
   * @api
   */
  getPlacement() {
    return this.placement_;
  }
  /**
   * Get the repeat interval of the text.
   * @return {number|undefined} Repeat interval in pixels.
   * @api
   */
  getRepeat() {
    return this.repeat_;
  }
  /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */
  getOffsetX() {
    return this.offsetX_;
  }
  /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */
  getOffsetY() {
    return this.offsetY_;
  }
  /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Get the text to be rendered.
   * @return {string|Array<string>|undefined} Text.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Get the text alignment.
   * @return {CanvasTextAlign|undefined} Text align.
   * @api
   */
  getTextAlign() {
    return this.textAlign_;
  }
  /**
   * Get the justification.
   * @return {TextJustify|undefined} Justification.
   * @api
   */
  getJustify() {
    return this.justify_;
  }
  /**
   * Get the text baseline.
   * @return {CanvasTextBaseline|undefined} Text baseline.
   * @api
   */
  getTextBaseline() {
    return this.textBaseline_;
  }
  /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getBackgroundFill() {
    return this.backgroundFill_;
  }
  /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getBackgroundStroke() {
    return this.backgroundStroke_;
  }
  /**
   * Get the padding for the text.
   * @return {Array<number>|null} Padding.
   * @api
   */
  getPadding() {
    return this.padding_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */
  setOverflow(e) {
    this.overflow_ = e;
  }
  /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */
  setFont(e) {
    this.font_ = e;
  }
  /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */
  setMaxAngle(e) {
    this.maxAngle_ = e;
  }
  /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */
  setOffsetX(e) {
    this.offsetX_ = e;
  }
  /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */
  setOffsetY(e) {
    this.offsetY_ = e;
  }
  /**
   * Set the text placement.
   *
   * @param {TextPlacement} placement Placement.
   * @api
   */
  setPlacement(e) {
    this.placement_ = e;
  }
  /**
   * Set the repeat interval of the text.
   * @param {number|undefined} [repeat] Repeat interval in pixels.
   * @api
   */
  setRepeat(e) {
    this.repeat_ = e;
  }
  /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(e) {
    this.rotateWithView_ = e;
  }
  /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e;
  }
  /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */
  setRotation(e) {
    this.rotation_ = e;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */
  setScale(e) {
    this.scale_ = e, this.scaleArray_ = $e(e !== void 0 ? e : 1);
  }
  /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e;
  }
  /**
   * Set the text.
   *
   * @param {string|Array<string>|undefined} text Text.
   * @api
   */
  setText(e) {
    this.text_ = e;
  }
  /**
   * Set the text alignment.
   *
   * @param {CanvasTextAlign|undefined} textAlign Text align.
   * @api
   */
  setTextAlign(e) {
    this.textAlign_ = e;
  }
  /**
   * Set the justification.
   *
   * @param {TextJustify|undefined} justify Justification.
   * @api
   */
  setJustify(e) {
    this.justify_ = e;
  }
  /**
   * Set the text baseline.
   *
   * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
   * @api
   */
  setTextBaseline(e) {
    this.textBaseline_ = e;
  }
  /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setBackgroundFill(e) {
    this.backgroundFill_ = e;
  }
  /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setBackgroundStroke(e) {
    this.backgroundStroke_ = e;
  }
  /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {Array<number>|null} padding Padding.
   * @api
   */
  setPadding(e) {
    this.padding_ = e;
  }
}
const Yl = jl;
let Qn = 0;
const es = 0, Ee = 1 << Qn++, k = 1 << Qn++, Ct = 1 << Qn++, Me = 1 << Qn++, ni = 1 << Qn++, Ae = Math.pow(2, Qn) - 1, Qu = {
  [Ee]: "boolean",
  [k]: "number",
  [Ct]: "string",
  [Me]: "color",
  [ni]: "number[]"
}, dm = Object.keys(Qu).map(Number).sort(ti);
function De(n) {
  const e = [];
  for (const t of dm)
    fm(n, t) && e.push(Qu[t]);
  return e.length === 0 ? "untyped" : e.length < 3 ? e.join(" or ") : e.slice(0, -1).join(", ") + ", or " + e[e.length - 1];
}
function fm(n, e) {
  return (n & e) === e;
}
function Mt(n, e) {
  return !!(n & e);
}
function To(n, e) {
  return n === e;
}
class wi {
  /**
   * @param {number} type The value type.
   * @param {LiteralValue} value The literal value.
   */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
}
class gm {
  /**
   * @param {number} type The return type.
   * @param {string} operator The operator.
   * @param {...Expression} args The arguments.
   */
  constructor(e, t, ...i) {
    this.type = e, this.operator = t, this.args = i;
  }
}
function ed() {
  return {
    variables: /* @__PURE__ */ new Set(),
    properties: /* @__PURE__ */ new Set(),
    featureId: !1,
    geometryType: !1,
    style: {}
  };
}
function _m(n) {
  switch (n) {
    case "string":
      return Ct;
    case "color":
      return Me;
    case "number":
      return k;
    case "boolean":
      return Ee;
    case "number[]":
      return ni;
    default:
      throw new Error(`Unrecognized type hint: ${n}`);
  }
}
function re(n, e, t) {
  switch (typeof n) {
    case "boolean":
      return new wi(Ee, n);
    case "number":
      return new wi(k, n);
    case "string": {
      let s = Ct;
      return j_(n) && (s |= Me), To(s & t, es) || (s &= t), new wi(s, n);
    }
  }
  if (!Array.isArray(n))
    throw new Error("Expression must be an array or a primitive value");
  if (n.length === 0)
    throw new Error("Empty expression");
  if (typeof n[0] == "string")
    return Im(n, e, t);
  for (const s of n)
    if (typeof s != "number")
      throw new Error("Expected an array of numbers");
  let i = ni;
  return (n.length === 3 || n.length === 4) && (i |= Me), t && (i &= t), new wi(i, n);
}
const T = {
  Get: "get",
  Var: "var",
  Concat: "concat",
  GeometryType: "geometry-type",
  Any: "any",
  All: "all",
  Not: "!",
  Resolution: "resolution",
  Zoom: "zoom",
  Time: "time",
  Equal: "==",
  NotEqual: "!=",
  GreaterThan: ">",
  GreaterThanOrEqualTo: ">=",
  LessThan: "<",
  LessThanOrEqualTo: "<=",
  Multiply: "*",
  Divide: "/",
  Add: "+",
  Subtract: "-",
  Clamp: "clamp",
  Mod: "%",
  Pow: "^",
  Abs: "abs",
  Floor: "floor",
  Ceil: "ceil",
  Round: "round",
  Sin: "sin",
  Cos: "cos",
  Atan: "atan",
  Sqrt: "sqrt",
  Match: "match",
  Between: "between",
  Interpolate: "interpolate",
  Coalesce: "coalesce",
  Case: "case",
  In: "in",
  Number: "number",
  String: "string",
  Array: "array",
  Color: "color",
  Id: "id",
  Band: "band",
  Palette: "palette"
}, mm = {
  [T.Get]: K(
    ([n, e]) => e !== void 0 ? _m(
      /** @type {string} */
      /** @type {LiteralExpression} */
      e.value
    ) : Ae,
    H(1, 2),
    pm
  ),
  [T.Var]: K(
    ([n]) => n.type,
    H(1, 1),
    ym
  ),
  [T.Id]: K(k | Ct, fs, xm),
  [T.Concat]: K(
    Ct,
    H(2, 1 / 0),
    te(Ae)
  ),
  [T.GeometryType]: K(Ct, fs, Em),
  [T.Resolution]: K(k, fs),
  [T.Zoom]: K(k, fs),
  [T.Time]: K(k, fs),
  [T.Any]: K(
    Ee,
    H(2, 1 / 0),
    te(Ee)
  ),
  [T.All]: K(
    Ee,
    H(2, 1 / 0),
    te(Ee)
  ),
  [T.Not]: K(
    Ee,
    H(1, 1),
    te(Ee)
  ),
  [T.Equal]: K(
    Ee,
    H(2, 2),
    te(Ae),
    ui
  ),
  [T.NotEqual]: K(
    Ee,
    H(2, 2),
    te(Ae),
    ui
  ),
  [T.GreaterThan]: K(
    Ee,
    H(2, 2),
    te(Ae),
    ui
  ),
  [T.GreaterThanOrEqualTo]: K(
    Ee,
    H(2, 2),
    te(Ae),
    ui
  ),
  [T.LessThan]: K(
    Ee,
    H(2, 2),
    te(Ae),
    ui
  ),
  [T.LessThanOrEqualTo]: K(
    Ee,
    H(2, 2),
    te(Ae),
    ui
  ),
  [T.Multiply]: K(
    (n) => {
      let e = k | Me;
      for (let t = 0; t < n.length; t++)
        e &= n[t].type;
      return e;
    },
    H(2, 1 / 0),
    te(k | Me),
    ui
  ),
  [T.Coalesce]: K(
    (n) => {
      let e = Ae;
      for (let t = 1; t < n.length; t += 2)
        e &= n[t].type;
      return e &= n[n.length - 1].type, e;
    },
    H(2, 1 / 0),
    te(Ae),
    ui
  ),
  [T.Divide]: K(
    k,
    H(2, 2),
    te(k)
  ),
  [T.Add]: K(
    k,
    H(2, 1 / 0),
    te(k)
  ),
  [T.Subtract]: K(
    k,
    H(2, 2),
    te(k)
  ),
  [T.Clamp]: K(
    k,
    H(3, 3),
    te(k)
  ),
  [T.Mod]: K(
    k,
    H(2, 2),
    te(k)
  ),
  [T.Pow]: K(
    k,
    H(2, 2),
    te(k)
  ),
  [T.Abs]: K(
    k,
    H(1, 1),
    te(k)
  ),
  [T.Floor]: K(
    k,
    H(1, 1),
    te(k)
  ),
  [T.Ceil]: K(
    k,
    H(1, 1),
    te(k)
  ),
  [T.Round]: K(
    k,
    H(1, 1),
    te(k)
  ),
  [T.Sin]: K(
    k,
    H(1, 1),
    te(k)
  ),
  [T.Cos]: K(
    k,
    H(1, 1),
    te(k)
  ),
  [T.Atan]: K(
    k,
    H(1, 2),
    te(k)
  ),
  [T.Sqrt]: K(
    k,
    H(1, 1),
    te(k)
  ),
  [T.Match]: K(
    (n) => {
      let e = Ae;
      for (let t = 2; t < n.length; t += 2)
        e &= n[t].type;
      return e &= n[n.length - 1].type, e;
    },
    H(4, 1 / 0),
    ac,
    wm
  ),
  [T.Between]: K(
    Ee,
    H(3, 3),
    te(k)
  ),
  [T.Interpolate]: K(
    (n) => {
      let e = Me | k;
      for (let t = 3; t < n.length; t += 2)
        e &= n[t].type;
      return e;
    },
    H(6, 1 / 0),
    ac,
    Sm
  ),
  [T.Case]: K(
    (n) => {
      let e = Ae;
      for (let t = 1; t < n.length; t += 2)
        e &= n[t].type;
      return e &= n[n.length - 1].type, e;
    },
    H(3, 1 / 0),
    Cm,
    vm
  ),
  [T.In]: K(Ee, H(2, 2), Tm),
  [T.Number]: K(
    k,
    H(1, 1 / 0),
    te(Ae)
  ),
  [T.String]: K(
    Ct,
    H(1, 1 / 0),
    te(Ae)
  ),
  [T.Array]: K(
    (n) => n.length === 3 || n.length === 4 ? ni | Me : ni,
    H(1, 1 / 0),
    te(k)
  ),
  [T.Color]: K(
    Me,
    H(1, 4),
    te(k)
  ),
  [T.Band]: K(
    k,
    H(1, 3),
    te(k)
  ),
  [T.Palette]: K(Me, H(2, 2), Rm)
};
function pm(n, e) {
  const t = re(n[1], e);
  if (!(t instanceof wi))
    throw new Error("Expected a literal argument for get operation");
  if (typeof t.value != "string")
    throw new Error("Expected a string argument for get operation");
  if (e.properties.add(t.value), n.length === 3) {
    const i = re(n[2], e);
    return [t, i];
  }
  return [t];
}
function ym(n, e, t, i) {
  const s = n[1];
  if (typeof s != "string")
    throw new Error("Expected a string argument for var operation");
  if (e.variables.add(s), !("variables" in e.style) || e.style.variables[s] === void 0)
    return [new wi(Ae, s)];
  const r = e.style.variables[s], o = (
    /** @type {LiteralExpression} */
    re(r, e)
  );
  if (o.value = s, i && !Mt(i, o.type))
    throw new Error(
      `The variable ${s} has type ${De(
        o.type
      )} but the following type was expected: ${De(i)}`
    );
  return [o];
}
function xm(n, e) {
  e.featureId = !0;
}
function Em(n, e) {
  e.geometryType = !0;
}
function fs(n, e) {
  const t = n[0];
  if (n.length !== 1)
    throw new Error(`Expected no arguments for ${t} operation`);
  return [];
}
function H(n, e) {
  return function(t, i) {
    const s = t[0], r = t.length - 1;
    if (n === e) {
      if (r !== n) {
        const o = n === 1 ? "" : "s";
        throw new Error(
          `Expected ${n} argument${o} for ${s}, got ${r}`
        );
      }
    } else if (r < n || r > e) {
      const o = e === 1 / 0 ? `${n} or more` : `${n} to ${e}`;
      throw new Error(
        `Expected ${o} arguments for ${s}, got ${r}`
      );
    }
  };
}
function te(n) {
  return function(e, t) {
    const i = e[0], s = e.length - 1, r = new Array(s);
    for (let o = 0; o < s; ++o) {
      const a = re(e[o + 1], t);
      if (!Mt(n, a.type)) {
        const l = De(n), h = De(a.type);
        throw new Error(
          `Unexpected type for argument ${o} of ${i} operation, got ${l} but expected ${h}`
        );
      }
      a.type &= n, r[o] = a;
    }
    return r;
  };
}
function ui(n, e, t) {
  const i = n[0], s = n.length - 1;
  let r = Ae;
  for (let a = 0; a < t.length; ++a)
    r &= t[a].type;
  if (r === es)
    throw new Error(
      `No common type could be found for arguments of ${i} operation`
    );
  const o = new Array(s);
  for (let a = 0; a < s; ++a)
    o[a] = re(n[a + 1], e, r);
  return o;
}
function Cm(n, e) {
  const t = n[0], i = n.length - 1;
  if (i % 2 === 0)
    throw new Error(
      `An odd amount of arguments was expected for operation ${t}, got ${JSON.stringify(
        i
      )} instead`
    );
}
function ac(n, e) {
  const t = n[0], i = n.length - 1;
  if (i % 2 === 1)
    throw new Error(
      `An even amount of arguments was expected for operation ${t}, got ${JSON.stringify(
        i
      )} instead`
    );
}
function wm(n, e, t, i) {
  const s = n.length - 1;
  let o = re(n[1], e).type;
  const a = re(n[n.length - 1], e);
  let l = i !== void 0 ? i & a.type : a.type;
  const h = new Array(s - 2);
  for (let u = 0; u < s - 2; u += 2) {
    const d = re(n[u + 2], e), f = re(n[u + 3], e);
    o &= d.type, l &= f.type, h[u] = d, h[u + 1] = f;
  }
  const c = Ct | k | Ee;
  if (!Mt(c, o))
    throw new Error(
      `Expected an input of type ${De(
        c
      )} for the interpolate operation, got ${De(o)} instead`
    );
  if (To(l, es))
    throw new Error(
      "Could not find a common output type for the following match operation: " + JSON.stringify(n)
    );
  for (let u = 0; u < s - 2; u += 2) {
    const d = re(n[u + 2], e, o), f = re(n[u + 3], e, l);
    h[u] = d, h[u + 1] = f;
  }
  return [
    re(n[1], e, o),
    ...h,
    re(n[n.length - 1], e, l)
  ];
}
function Sm(n, e, t, i) {
  const s = n[1];
  let r;
  switch (s[0]) {
    case "linear":
      r = 1;
      break;
    case "exponential":
      if (r = s[1], typeof r != "number")
        throw new Error(
          `Expected a number base for exponential interpolation, got ${JSON.stringify(r)} instead`
        );
      break;
    default:
      r = null;
  }
  if (!r)
    throw new Error(
      `Invalid interpolation type: ${JSON.stringify(s)}`
    );
  r = re(r, e);
  let o = re(n[2], e);
  if (!Mt(k, o.type))
    throw new Error(
      `Expected an input of type number for the interpolate operation, got ${De(o.type)} instead`
    );
  o = re(n[2], e, k);
  const a = new Array(n.length - 3);
  for (let l = 0; l < a.length; l += 2) {
    let h = re(n[l + 3], e);
    if (!Mt(k, h.type))
      throw new Error(
        `Expected all stop input values in the interpolate operation to be of type number, got ${De(h.type)} at position ${l + 2} instead`
      );
    let c = re(n[l + 4], e);
    if (!Mt(k | Me, c.type))
      throw new Error(
        `Expected all stop output values in the interpolate operation to be a number or color, got ${De(c.type)} at position ${l + 3} instead`
      );
    h = re(n[l + 3], e, k), c = re(n[l + 4], e, k | Me), a[l] = h, a[l + 1] = c;
  }
  return [r, o, ...a];
}
function vm(n, e, t, i) {
  const s = re(n[n.length - 1], e);
  let r = i !== void 0 ? i & s.type : s.type;
  const o = new Array(n.length - 1);
  for (let a = 0; a < o.length - 1; a += 2) {
    const l = re(n[a + 1], e), h = re(n[a + 2], e);
    if (!Mt(Ee, l.type))
      throw new Error(
        `Expected all conditions in the case operation to be of type boolean, got ${De(l.type)} at position ${a} instead`
      );
    r &= h.type, o[a] = l, o[a + 1] = h;
  }
  if (To(r, es))
    throw new Error(
      "Could not find a common output type for the following case operation: " + JSON.stringify(n)
    );
  for (let a = 0; a < o.length - 1; a += 2)
    o[a + 1] = re(n[a + 2], e, r);
  return o[o.length - 1] = re(
    n[n.length - 1],
    e,
    r
  ), o;
}
function Tm(n, e) {
  let t = (
    /** @type {any} */
    n[2]
  );
  if (!Array.isArray(t))
    throw new Error(
      'The "in" operator was provided a literal value which was not an array as second argument.'
    );
  if (typeof t[0] == "string") {
    if (t[0] !== "literal")
      throw new Error(
        'For the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions.'
      );
    if (!Array.isArray(t[1]))
      throw new Error(
        'The "in" operator was provided a literal value which was not an array as second argument.'
      );
    t = t[1];
  }
  let i = Ct | k;
  const s = new Array(t.length);
  for (let o = 0; o < s.length; o++) {
    const a = re(t[o], e);
    i &= a.type, s[o] = a;
  }
  if (To(i, es))
    throw new Error(
      "Could not find a common type for the following in operation: " + JSON.stringify(n)
    );
  return [re(n[1], e, i), ...s];
}
function Rm(n, e) {
  const t = re(n[1], e, k);
  if (t.type !== k)
    throw new Error(
      `The first argument of palette must be an number, got ${De(
        t.type
      )} instead`
    );
  const i = n[2];
  if (!Array.isArray(i))
    throw new Error("The second argument of palette must be an array");
  const s = new Array(i.length);
  for (let r = 0; r < s.length; r++) {
    const o = re(i[r], e, Me);
    if (!(o instanceof wi))
      throw new Error(
        `The palette color at index ${r} must be a literal value`
      );
    if (!Mt(o.type, Me))
      throw new Error(
        `The palette color at index ${r} should be of type color, got ${De(
          o.type
        )} instead`
      );
    s[r] = o;
  }
  return [t, ...s];
}
function K(n, ...e) {
  return function(t, i, s) {
    const r = t[0];
    let o = [];
    for (let l = 0; l < e.length; l++)
      o = e[l](t, i, o, s) || o;
    let a = typeof n == "function" ? n(o) : n;
    if (s !== void 0) {
      if (!Mt(a, s))
        throw new Error(
          `The following expression was expected to return ${De(
            s
          )}, but returns ${De(a)} instead: ${JSON.stringify(
            t
          )}`
        );
      a &= s;
    }
    if (a === es)
      throw new Error(
        `No matching type was found for the following expression: ${JSON.stringify(
          t
        )}`
      );
    return new gm(a, r, ...o);
  };
}
function Im(n, e, t) {
  const i = n[0], s = mm[i];
  if (!s)
    throw new Error(`Unknown operator: ${i}`);
  return s(n, e, t);
}
function td(n) {
  if (!n)
    return "";
  const e = n.getType();
  switch (e) {
    case "Point":
    case "LineString":
    case "Polygon":
      return e;
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
      return (
        /** @type {'Point'|'LineString'|'Polygon'} */
        e.substring(5)
      );
    case "Circle":
      return "Polygon";
    case "GeometryCollection":
      return td(
        /** @type {import("../geom/GeometryCollection.js").default} */
        n.getGeometries()[0]
      );
    default:
      return "";
  }
}
function id() {
  return {
    variables: {},
    properties: {},
    resolution: NaN,
    featureId: null,
    geometryType: ""
  };
}
function oi(n, e, t) {
  const i = re(n, t);
  if (!Mt(e, i.type)) {
    const s = De(e), r = De(i.type);
    throw new Error(
      `Expected expression to be of type ${s}, got ${r}`
    );
  }
  return Nt(i);
}
function Nt(n, e) {
  if (n instanceof wi) {
    if (n.type === Me && typeof n.value == "string") {
      const i = Ml(n.value);
      return function() {
        return i;
      };
    }
    return function() {
      return n.value;
    };
  }
  const t = n.operator;
  switch (t) {
    case T.Number:
    case T.String:
    case T.Coalesce:
      return Pm(n);
    case T.Get:
    case T.Var:
      return Lm(n);
    case T.Id:
      return (i) => i.featureId;
    case T.GeometryType:
      return (i) => i.geometryType;
    case T.Concat: {
      const i = n.args.map((s) => Nt(s));
      return (s) => "".concat(...i.map((r) => r(s).toString()));
    }
    case T.Resolution:
      return (i) => i.resolution;
    case T.Any:
    case T.All:
    case T.Not:
      return Am(n);
    case T.Equal:
    case T.NotEqual:
    case T.LessThan:
    case T.LessThanOrEqualTo:
    case T.GreaterThan:
    case T.GreaterThanOrEqualTo:
      return bm(n);
    case T.Multiply:
    case T.Divide:
    case T.Add:
    case T.Subtract:
    case T.Clamp:
    case T.Mod:
    case T.Pow:
    case T.Abs:
    case T.Floor:
    case T.Ceil:
    case T.Round:
    case T.Sin:
    case T.Cos:
    case T.Atan:
    case T.Sqrt:
      return Fm(n);
    case T.Case:
      return Mm(n);
    case T.Match:
      return Om(n);
    case T.Interpolate:
      return Dm(n);
    default:
      throw new Error(`Unsupported operator ${t}`);
  }
}
function Pm(n, e) {
  const t = n.operator, i = n.args.length, s = new Array(i);
  for (let r = 0; r < i; ++r)
    s[r] = Nt(n.args[r]);
  switch (t) {
    case T.Coalesce:
      return (r) => {
        for (let o = 0; o < i; ++o) {
          const a = s[o](r);
          if (typeof a < "u" && a !== null)
            return a;
        }
        throw new Error("Expected one of the values to be non-null");
      };
    case T.Number:
    case T.String:
      return (r) => {
        for (let o = 0; o < i; ++o) {
          const a = s[o](r);
          if (typeof a === t)
            return a;
        }
        throw new Error(`Expected one of the values to be a ${t}`);
      };
    default:
      throw new Error(`Unsupported assertion operator ${t}`);
  }
}
function Lm(n, e) {
  const i = (
    /** @type {string} */
    /** @type {LiteralExpression} */
    n.args[0].value
  );
  switch (n.operator) {
    case T.Get:
      return (s) => s.properties[i];
    case T.Var:
      return (s) => s.variables[i];
    default:
      throw new Error(`Unsupported accessor operator ${n.operator}`);
  }
}
function bm(n, e) {
  const t = n.operator, i = Nt(n.args[0]), s = Nt(n.args[1]);
  switch (t) {
    case T.Equal:
      return (r) => i(r) === s(r);
    case T.NotEqual:
      return (r) => i(r) !== s(r);
    case T.LessThan:
      return (r) => i(r) < s(r);
    case T.LessThanOrEqualTo:
      return (r) => i(r) <= s(r);
    case T.GreaterThan:
      return (r) => i(r) > s(r);
    case T.GreaterThanOrEqualTo:
      return (r) => i(r) >= s(r);
    default:
      throw new Error(`Unsupported comparison operator ${t}`);
  }
}
function Am(n, e) {
  const t = n.operator, i = n.args.length, s = new Array(i);
  for (let r = 0; r < i; ++r)
    s[r] = Nt(n.args[r]);
  switch (t) {
    case T.Any:
      return (r) => {
        for (let o = 0; o < i; ++o)
          if (s[o](r))
            return !0;
        return !1;
      };
    case T.All:
      return (r) => {
        for (let o = 0; o < i; ++o)
          if (!s[o](r))
            return !1;
        return !0;
      };
    case T.Not:
      return (r) => !s[0](r);
    default:
      throw new Error(`Unsupported logical operator ${t}`);
  }
}
function Fm(n, e) {
  const t = n.operator, i = n.args.length, s = new Array(i);
  for (let r = 0; r < i; ++r)
    s[r] = Nt(n.args[r]);
  switch (t) {
    case T.Multiply:
      return (r) => {
        let o = 1;
        for (let a = 0; a < i; ++a)
          o *= s[a](r);
        return o;
      };
    case T.Divide:
      return (r) => s[0](r) / s[1](r);
    case T.Add:
      return (r) => {
        let o = 0;
        for (let a = 0; a < i; ++a)
          o += s[a](r);
        return o;
      };
    case T.Subtract:
      return (r) => s[0](r) - s[1](r);
    case T.Clamp:
      return (r) => {
        const o = s[0](r), a = s[1](r);
        if (o < a)
          return a;
        const l = s[2](r);
        return o > l ? l : o;
      };
    case T.Mod:
      return (r) => s[0](r) % s[1](r);
    case T.Pow:
      return (r) => Math.pow(s[0](r), s[1](r));
    case T.Abs:
      return (r) => Math.abs(s[0](r));
    case T.Floor:
      return (r) => Math.floor(s[0](r));
    case T.Ceil:
      return (r) => Math.ceil(s[0](r));
    case T.Round:
      return (r) => Math.round(s[0](r));
    case T.Sin:
      return (r) => Math.sin(s[0](r));
    case T.Cos:
      return (r) => Math.cos(s[0](r));
    case T.Atan:
      return i === 2 ? (r) => Math.atan2(s[0](r), s[1](r)) : (r) => Math.atan(s[0](r));
    case T.Sqrt:
      return (r) => Math.sqrt(s[0](r));
    default:
      throw new Error(`Unsupported numeric operator ${t}`);
  }
}
function Mm(n, e) {
  const t = n.args.length, i = new Array(t);
  for (let s = 0; s < t; ++s)
    i[s] = Nt(n.args[s]);
  return (s) => {
    for (let r = 0; r < t - 1; r += 2)
      if (i[r](s))
        return i[r + 1](s);
    return i[t - 1](s);
  };
}
function Om(n, e) {
  const t = n.args.length, i = new Array(t);
  for (let s = 0; s < t; ++s)
    i[s] = Nt(n.args[s]);
  return (s) => {
    const r = i[0](s);
    for (let o = 1; o < t; o += 2)
      if (r === i[o](s))
        return i[o + 1](s);
    return i[t - 1](s);
  };
}
function Dm(n, e) {
  const t = n.args.length, i = new Array(t);
  for (let s = 0; s < t; ++s)
    i[s] = Nt(n.args[s]);
  return (s) => {
    const r = i[0](s), o = i[1](s);
    let a, l;
    for (let h = 2; h < t; h += 2) {
      const c = i[h](s);
      let u = i[h + 1](s);
      const d = Array.isArray(u);
      if (d && (u = U_(u)), c >= o)
        return h === 2 ? u : d ? Nm(
          r,
          o,
          a,
          l,
          c,
          u
        ) : ys(
          r,
          o,
          a,
          l,
          c,
          u
        );
      a = c, l = u;
    }
    return l;
  };
}
function ys(n, e, t, i, s, r) {
  const o = s - t;
  if (o === 0)
    return i;
  const a = e - t, l = n === 1 ? a / o : (Math.pow(n, a) - 1) / (Math.pow(n, o) - 1);
  return i + l * (r - i);
}
function Nm(n, e, t, i, s, r) {
  if (s - t === 0)
    return i;
  const a = tc(i), l = tc(r);
  let h = l[2] - a[2];
  h > 180 ? h -= 360 : h < -180 && (h += 360);
  const c = [
    ys(n, e, t, a[0], s, l[0]),
    ys(n, e, t, a[1], s, l[1]),
    a[2] + ys(n, e, t, 0, s, h),
    ys(n, e, t, i[3], s, r[3])
  ];
  return zu(V_(c));
}
function km(n) {
  return !0;
}
function Gm(n) {
  const e = ed(), t = zm(n, e), i = id();
  return function(s, r) {
    if (i.properties = s.getPropertiesInternal(), i.resolution = r, e.featureId) {
      const o = s.getId();
      o !== void 0 ? i.featureId = o : i.featureId = null;
    }
    return e.geometryType && (i.geometryType = td(
      s.getGeometry()
    )), t(i);
  };
}
function lc(n) {
  const e = ed(), t = n.length, i = new Array(t);
  for (let o = 0; o < t; ++o)
    i[o] = ka(n[o], e);
  const s = id(), r = new Array(t);
  return function(o, a) {
    if (s.properties = o.getPropertiesInternal(), s.resolution = a, e.featureId) {
      const h = o.getId();
      h !== void 0 ? s.featureId = h : s.featureId = null;
    }
    let l = 0;
    for (let h = 0; h < t; ++h) {
      const c = i[h](s);
      c && (r[l] = c, l += 1);
    }
    return r.length = l, r;
  };
}
function zm(n, e) {
  const t = n.length, i = new Array(t);
  for (let s = 0; s < t; ++s) {
    const r = n[s], o = "filter" in r ? oi(r.filter, Ee, e) : km;
    let a;
    if (Array.isArray(r.style)) {
      const l = r.style.length;
      a = new Array(l);
      for (let h = 0; h < l; ++h)
        a[h] = ka(r.style[h], e);
    } else
      a = [ka(r.style, e)];
    i[s] = { filter: o, styles: a };
  }
  return function(s) {
    const r = [];
    let o = !1;
    for (let a = 0; a < t; ++a) {
      const l = i[a].filter;
      if (l(s) && !(n[a].else && o)) {
        o = !0;
        for (const h of i[a].styles) {
          const c = h(s);
          c && r.push(c);
        }
      }
    }
    return r;
  };
}
function ka(n, e) {
  const t = Us(n, "", e), i = Vs(n, "", e), s = $m(n, e), r = Um(n, e), o = Xe(n, "z-index", e);
  if (!t && !i && !s && !r && !Fi(n))
    throw new Error(
      "No fill, stroke, point, or text symbolizer properties in style: " + JSON.stringify(n)
    );
  const a = new Ft();
  return function(l) {
    let h = !0;
    if (t) {
      const c = t(l);
      c && (h = !1), a.setFill(c);
    }
    if (i) {
      const c = i(l);
      c && (h = !1), a.setStroke(c);
    }
    if (s) {
      const c = s(l);
      c && (h = !1), a.setText(c);
    }
    if (r) {
      const c = r(l);
      c && (h = !1), a.setImage(c);
    }
    return o && a.setZIndex(o(l)), h ? null : a;
  };
}
function Us(n, e, t) {
  let i;
  if (e + "fill-pattern-src" in n ? i = Xm(n, e + "fill-", t) : i = Xl(
    n,
    e + "fill-color",
    t
  ), !i)
    return null;
  const s = new Di();
  return function(r) {
    const o = i(r);
    return o === "none" ? null : (s.setColor(o), s);
  };
}
function Vs(n, e, t) {
  const i = Xe(
    n,
    e + "stroke-width",
    t
  ), s = Xl(
    n,
    e + "stroke-color",
    t
  );
  if (!i && !s)
    return null;
  const r = Kt(
    n,
    e + "stroke-line-cap",
    t
  ), o = Kt(
    n,
    e + "stroke-line-join",
    t
  ), a = nd(
    n,
    e + "stroke-line-dash",
    t
  ), l = Xe(
    n,
    e + "stroke-line-dash-offset",
    t
  ), h = Xe(
    n,
    e + "stroke-miter-limit",
    t
  ), c = new Ai();
  return function(u) {
    if (s) {
      const d = s(u);
      if (d === "none")
        return null;
      c.setColor(d);
    }
    if (i && c.setWidth(i(u)), r) {
      const d = r(u);
      if (d !== "butt" && d !== "round" && d !== "square")
        throw new Error("Expected butt, round, or square line cap");
      c.setLineCap(d);
    }
    if (o) {
      const d = o(u);
      if (d !== "bevel" && d !== "round" && d !== "miter")
        throw new Error("Expected bevel, round, or miter line join");
      c.setLineJoin(d);
    }
    return a && c.setLineDash(a(u)), l && c.setLineDashOffset(l(u)), h && c.setMiterLimit(h(u)), c;
  };
}
function $m(n, e) {
  const t = "text-", i = Kt(n, t + "value", e);
  if (!i)
    return null;
  const s = Us(n, t, e), r = Us(
    n,
    t + "background-",
    e
  ), o = Vs(n, t, e), a = Vs(
    n,
    t + "background-",
    e
  ), l = Kt(n, t + "font", e), h = Xe(
    n,
    t + "max-angle",
    e
  ), c = Xe(
    n,
    t + "offset-x",
    e
  ), u = Xe(
    n,
    t + "offset-y",
    e
  ), d = js(
    n,
    t + "overflow",
    e
  ), f = Kt(
    n,
    t + "placement",
    e
  ), g = Xe(n, t + "repeat", e), _ = Ro(n, t + "scale", e), m = js(
    n,
    t + "rotate-with-view",
    e
  ), p = Xe(
    n,
    t + "rotation",
    e
  ), y = Kt(n, t + "align", e), x = Kt(
    n,
    t + "justify",
    e
  ), E = Kt(
    n,
    t + "baseline",
    e
  ), C = nd(
    n,
    t + "padding",
    e
  ), w = Io(
    n,
    t + "declutter-mode"
  ), S = new Yl({ declutterMode: w });
  return function(v) {
    if (S.setText(i(v)), s && S.setFill(s(v)), r && S.setBackgroundFill(r(v)), o && S.setStroke(o(v)), a && S.setBackgroundStroke(a(v)), l && S.setFont(l(v)), h && S.setMaxAngle(h(v)), c && S.setOffsetX(c(v)), u && S.setOffsetY(u(v)), d && S.setOverflow(d(v)), f) {
      const R = f(v);
      if (R !== "point" && R !== "line")
        throw new Error("Expected point or line for text-placement");
      S.setPlacement(R);
    }
    if (g && S.setRepeat(g(v)), _ && S.setScale(_(v)), m && S.setRotateWithView(m(v)), p && S.setRotation(p(v)), y) {
      const R = y(v);
      if (R !== "left" && R !== "center" && R !== "right" && R !== "end" && R !== "start")
        throw new Error(
          "Expected left, right, center, start, or end for text-align"
        );
      S.setTextAlign(R);
    }
    if (x) {
      const R = x(v);
      if (R !== "left" && R !== "right" && R !== "center")
        throw new Error("Expected left, right, or center for text-justify");
      S.setJustify(R);
    }
    if (E) {
      const R = E(v);
      if (R !== "bottom" && R !== "top" && R !== "middle" && R !== "alphabetic" && R !== "hanging")
        throw new Error(
          "Expected bottom, top, middle, alphabetic, or hanging for text-baseline"
        );
      S.setTextBaseline(R);
    }
    return C && S.setPadding(C(v)), S;
  };
}
function Um(n, e) {
  return "icon-src" in n ? Vm(n, e) : "shape-points" in n ? jm(n, e) : "circle-radius" in n ? Ym(n, e) : null;
}
function Vm(n, e) {
  const t = "icon-", i = t + "src", s = sd(n[i], i), r = Kr(
    n,
    t + "anchor",
    e
  ), o = Ro(n, t + "scale", e), a = Xe(
    n,
    t + "opacity",
    e
  ), l = Kr(
    n,
    t + "displacement",
    e
  ), h = Xe(
    n,
    t + "rotation",
    e
  ), c = js(
    n,
    t + "rotate-with-view",
    e
  ), u = cc(n, t + "anchor-origin"), d = uc(
    n,
    t + "anchor-x-units"
  ), f = uc(
    n,
    t + "anchor-y-units"
  ), g = Zm(n, t + "color"), _ = Wm(n, t + "cross-origin"), m = Km(n, t + "offset"), p = cc(n, t + "offset-origin"), y = Zr(n, t + "width"), x = Zr(n, t + "height"), E = Bm(n, t + "size"), C = Io(
    n,
    t + "declutter-mode"
  ), w = new vo({
    src: s,
    anchorOrigin: u,
    anchorXUnits: d,
    anchorYUnits: f,
    color: g,
    crossOrigin: _,
    offset: m,
    offsetOrigin: p,
    height: x,
    width: y,
    size: E,
    declutterMode: C
  });
  return function(S) {
    return a && w.setOpacity(a(S)), l && w.setDisplacement(l(S)), h && w.setRotation(h(S)), c && w.setRotateWithView(c(S)), o && w.setScale(o(S)), r && w.setAnchor(r(S)), w;
  };
}
function jm(n, e) {
  const t = "shape-", i = t + "points", s = t + "radius", r = Ga(n[i], i), o = Ga(n[s], s), a = Us(n, t, e), l = Vs(n, t, e), h = Ro(n, t + "scale", e), c = Kr(
    n,
    t + "displacement",
    e
  ), u = Xe(
    n,
    t + "rotation",
    e
  ), d = js(
    n,
    t + "rotate-with-view",
    e
  ), f = Zr(n, t + "radius2"), g = Zr(n, t + "angle"), _ = Io(
    n,
    t + "declutter-mode"
  ), m = new qu({
    points: r,
    radius: o,
    radius2: f,
    angle: g,
    declutterMode: _
  });
  return function(p) {
    return a && m.setFill(a(p)), l && m.setStroke(l(p)), c && m.setDisplacement(c(p)), u && m.setRotation(u(p)), d && m.setRotateWithView(d(p)), h && m.setScale(h(p)), m;
  };
}
function Ym(n, e) {
  const t = "circle-", i = Us(n, t, e), s = Vs(n, t, e), r = Xe(n, t + "radius", e), o = Ro(n, t + "scale", e), a = Kr(
    n,
    t + "displacement",
    e
  ), l = Xe(
    n,
    t + "rotation",
    e
  ), h = js(
    n,
    t + "rotate-with-view",
    e
  ), c = Io(
    n,
    t + "declutter-mode"
  ), u = new zl({
    radius: 5,
    // this is arbitrary, but required - the evaluated radius is used below
    declutterMode: c
  });
  return function(d) {
    return r && u.setRadius(r(d)), i && u.setFill(i(d)), s && u.setStroke(s(d)), a && u.setDisplacement(a(d)), l && u.setRotation(l(d)), h && u.setRotateWithView(h(d)), o && u.setScale(o(d)), u;
  };
}
function Xe(n, e, t) {
  if (!(e in n))
    return;
  const i = oi(n[e], k, t);
  return function(s) {
    return Ga(i(s), e);
  };
}
function Kt(n, e, t) {
  if (!(e in n))
    return null;
  const i = oi(n[e], Ct, t);
  return function(s) {
    return sd(i(s), e);
  };
}
function Xm(n, e, t) {
  const i = Kt(
    n,
    e + "pattern-src",
    t
  ), s = hc(
    n,
    e + "pattern-offset",
    t
  ), r = hc(
    n,
    e + "pattern-size",
    t
  ), o = Xl(
    n,
    e + "color",
    t
  );
  return function(a) {
    return {
      src: i(a),
      offset: s && s(a),
      size: r && r(a),
      color: o && o(a)
    };
  };
}
function js(n, e, t) {
  if (!(e in n))
    return null;
  const i = oi(n[e], Ee, t);
  return function(s) {
    const r = i(s);
    if (typeof r != "boolean")
      throw new Error(`Expected a boolean for ${e}`);
    return r;
  };
}
function Xl(n, e, t) {
  if (!(e in n))
    return null;
  const i = oi(
    n[e],
    Me | Ct,
    t
  );
  return function(s) {
    return rd(i(s), e);
  };
}
function nd(n, e, t) {
  if (!(e in n))
    return null;
  const i = oi(n[e], ni, t);
  return function(s) {
    return nr(i(s), e);
  };
}
function Kr(n, e, t) {
  if (!(e in n))
    return null;
  const i = oi(n[e], ni, t);
  return function(s) {
    const r = nr(i(s), e);
    if (r.length !== 2)
      throw new Error(`Expected two numbers for ${e}`);
    return r;
  };
}
function hc(n, e, t) {
  if (!(e in n))
    return null;
  const i = oi(n[e], ni, t);
  return function(s) {
    return od(i(s), e);
  };
}
function Ro(n, e, t) {
  if (!(e in n))
    return null;
  const i = oi(
    n[e],
    ni | k,
    t
  );
  return function(s) {
    return Hm(i(s), e);
  };
}
function Zr(n, e) {
  const t = n[e];
  if (t !== void 0) {
    if (typeof t != "number")
      throw new Error(`Expected a number for ${e}`);
    return t;
  }
}
function Bm(n, e) {
  const t = n[e];
  if (t !== void 0) {
    if (typeof t == "number")
      return $e(t);
    if (!Array.isArray(t))
      throw new Error(`Expected a number or size array for ${e}`);
    if (t.length !== 2 || typeof t[0] != "number" || typeof t[1] != "number")
      throw new Error(`Expected a number or size array for ${e}`);
    return t;
  }
}
function Wm(n, e) {
  const t = n[e];
  if (t !== void 0) {
    if (typeof t != "string")
      throw new Error(`Expected a string for ${e}`);
    return t;
  }
}
function cc(n, e) {
  const t = n[e];
  if (t !== void 0) {
    if (t !== "bottom-left" && t !== "bottom-right" && t !== "top-left" && t !== "top-right")
      throw new Error(
        `Expected bottom-left, bottom-right, top-left, or top-right for ${e}`
      );
    return t;
  }
}
function uc(n, e) {
  const t = n[e];
  if (t !== void 0) {
    if (t !== "pixels" && t !== "fraction")
      throw new Error(`Expected pixels or fraction for ${e}`);
    return t;
  }
}
function Km(n, e) {
  const t = n[e];
  if (t !== void 0)
    return nr(t, e);
}
function Io(n, e) {
  const t = n[e];
  if (t !== void 0) {
    if (typeof t != "string")
      throw new Error(`Expected a string for ${e}`);
    if (t !== "declutter" && t !== "obstacle" && t !== "none")
      throw new Error(`Expected declutter, obstacle, or none for ${e}`);
    return t;
  }
}
function Zm(n, e) {
  const t = n[e];
  if (t !== void 0)
    return rd(t, e);
}
function nr(n, e) {
  if (!Array.isArray(n))
    throw new Error(`Expected an array for ${e}`);
  const t = n.length;
  for (let i = 0; i < t; ++i)
    if (typeof n[i] != "number")
      throw new Error(`Expected an array of numbers for ${e}`);
  return n;
}
function sd(n, e) {
  if (typeof n != "string")
    throw new Error(`Expected a string for ${e}`);
  return n;
}
function Ga(n, e) {
  if (typeof n != "number")
    throw new Error(`Expected a number for ${e}`);
  return n;
}
function rd(n, e) {
  if (typeof n == "string")
    return n;
  const t = nr(n, e), i = t.length;
  if (i < 3 || i > 4)
    throw new Error(`Expected a color with 3 or 4 values for ${e}`);
  return t;
}
function od(n, e) {
  const t = nr(n, e);
  if (t.length !== 2)
    throw new Error(`Expected an array of two numbers for ${e}`);
  return t;
}
function Hm(n, e) {
  return typeof n == "number" ? n : od(n, e);
}
const dc = {
  RENDER_ORDER: "renderOrder"
};
class qm extends tr {
  /**
   * @param {Options<VectorSourceType>} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign({}, e);
    delete t.style, delete t.renderBuffer, delete t.updateWhileAnimating, delete t.updateWhileInteracting, super(t), this.declutter_ = e.declutter ? String(e.declutter) : void 0, this.renderBuffer_ = e.renderBuffer !== void 0 ? e.renderBuffer : 100, this.style_ = null, this.styleFunction_ = void 0, this.setStyle(e.style), this.updateWhileAnimating_ = e.updateWhileAnimating !== void 0 ? e.updateWhileAnimating : !1, this.updateWhileInteracting_ = e.updateWhileInteracting !== void 0 ? e.updateWhileInteracting : !1;
  }
  /**
   * @return {string} Declutter group.
   */
  getDeclutter() {
    return this.declutter_;
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   */
  getFeatures(e) {
    return super.getFeatures(e);
  }
  /**
   * @return {number|undefined} Render buffer.
   */
  getRenderBuffer() {
    return this.renderBuffer_;
  }
  /**
   * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
   *     order.
   */
  getRenderOrder() {
    return (
      /** @type {import("../render.js").OrderFunction|null|undefined} */
      this.get(dc.RENDER_ORDER)
    );
  }
  /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */
  getUpdateWhileAnimating() {
    return this.updateWhileAnimating_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */
  getUpdateWhileInteracting() {
    return this.updateWhileInteracting_;
  }
  /**
   * Render declutter items for this layer
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(e, t) {
    const i = this.getDeclutter();
    i in e.declutter || (e.declutter[i] = new Du(9)), this.getRenderer().renderDeclutter(e, t);
  }
  /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */
  setRenderOrder(e) {
    this.set(dc.RENDER_ORDER, e);
  }
  /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
   *
   * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
   * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
   * ```js
   * vectorLayer.setStyle({
   *   "fill-color": "yellow",
   *   "stroke-color": "black",
   *   "stroke-width": 4
   * })
   * ```
   *
   * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
   * @api
   */
  setStyle(e) {
    this.style_ = Jm(e), this.styleFunction_ = e === null ? void 0 : hm(this.style_), this.changed();
  }
}
function Jm(n) {
  if (n === void 0)
    return cm;
  if (!n)
    return null;
  if (typeof n == "function" || n instanceof Ft)
    return n;
  if (!Array.isArray(n))
    return lc([n]);
  if (n.length === 0)
    return [];
  const e = n.length, t = n[0];
  if (t instanceof Ft) {
    const s = new Array(e);
    for (let r = 0; r < e; ++r) {
      const o = n[r];
      if (!(o instanceof Ft))
        throw new Error("Expected a list of style instances");
      s[r] = o;
    }
    return s;
  }
  if ("style" in t) {
    const s = new Array(e);
    for (let r = 0; r < e; ++r) {
      const o = n[r];
      if (!("style" in o))
        throw new Error("Expected a list of rules with a style property");
      s[r] = o;
    }
    return Gm(s);
  }
  return lc(
    /** @type {Array<import("../style/flat.js").FlatStyle>} */
    n
  );
}
const Bl = qm;
class Qm extends il {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(e) {
    super(), this.map_ = e;
  }
  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(e, t) {
    B();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @protected
   */
  calculateMatrices2D(e) {
    const t = e.viewState, i = e.coordinateToPixelTransform, s = e.pixelToCoordinateTransform;
    wt(
      i,
      e.size[0] / 2,
      e.size[1] / 2,
      1 / t.resolution,
      -1 / t.resolution,
      -t.rotation,
      -t.center[0],
      -t.center[1]
    ), Eo(s, i);
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  forEachFeatureAtCoordinate(e, t, i, s, r, o, a, l) {
    let h;
    const c = t.viewState;
    function u(E, C, w, S) {
      return r.call(o, C, E ? w : null, S);
    }
    const d = c.projection, f = mo(e.slice(), d), g = [[0, 0]];
    if (d.canWrapX() && s) {
      const E = d.getExtent(), C = ie(E);
      g.push([-C, 0], [C, 0]);
    }
    const _ = t.layerStatesArray, m = _.length, p = (
      /** @type {Array<HitMatch<T>>} */
      []
    ), y = [];
    for (let E = 0; E < g.length; E++)
      for (let C = m - 1; C >= 0; --C) {
        const w = _[C], S = w.layer;
        if (S.hasRenderer() && bl(w, c) && a.call(l, S)) {
          const v = S.getRenderer(), R = S.getSource();
          if (v && R) {
            const b = R.getWrapX() ? f : e, A = u.bind(
              null,
              w.managed
            );
            y[0] = b[0] + g[E][0], y[1] = b[1] + g[E][1], h = v.forEachFeatureAtCoordinate(
              y,
              t,
              i,
              A,
              p
            );
          }
          if (h)
            return h;
        }
      }
    if (p.length === 0)
      return;
    const x = 1 / p.length;
    return p.forEach((E, C) => E.distanceSq += C * x), p.sort((E, C) => E.distanceSq - C.distanceSq), p.some((E) => h = E.callback(E.feature, E.layer, E.geometry)), h;
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */
  hasFeatureAtCoordinate(e, t, i, s, r, o) {
    return this.forEachFeatureAtCoordinate(
      e,
      t,
      i,
      s,
      kn,
      this,
      r,
      o
    ) !== void 0;
  }
  /**
   * @return {import("../Map.js").default} Map.
   */
  getMap() {
    return this.map_;
  }
  /**
   * Render.
   * @abstract
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(e) {
    B();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  scheduleExpireIconCache(e) {
    bt.canExpireCache() && e.postRenderFunctions.push(ep);
  }
}
function ep(n, e) {
  bt.expire();
}
const tp = Qm;
class ip extends dt {
  /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
   */
  constructor(e, t, i, s) {
    super(e), this.inversePixelTransform = t, this.frameState = i, this.context = s;
  }
}
const ad = ip;
class np extends tp {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(e) {
    super(e), this.fontChangeListenerKey_ = Z(
      Bt,
      Ji.PROPERTYCHANGE,
      e.redrawText.bind(e)
    ), this.element_ = document.createElement("div");
    const t = this.element_.style;
    t.position = "absolute", t.width = "100%", t.height = "100%", t.zIndex = "0", this.element_.className = Dt + " ol-layers";
    const i = e.getViewport();
    i.insertBefore(this.element_, i.firstChild || null), this.children_ = [], this.renderedVisible_ = !0;
  }
  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(e, t) {
    const i = this.getMap();
    if (i.hasListener(e)) {
      const s = new ad(e, void 0, t);
      i.dispatchEvent(s);
    }
  }
  disposeInternal() {
    he(this.fontChangeListenerKey_), this.element_.parentNode.removeChild(this.element_), super.disposeInternal();
  }
  /**
   * Render.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(e) {
    if (!e) {
      this.renderedVisible_ && (this.element_.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    this.calculateMatrices2D(e), this.dispatchRenderEvent(st.PRECOMPOSE, e);
    const t = e.layerStatesArray.sort(function(a, l) {
      return a.zIndex - l.zIndex;
    });
    t.some(
      (a) => a.layer instanceof Bl && a.layer.getDeclutter()
    ) && (e.declutter = {});
    const s = e.viewState;
    this.children_.length = 0;
    const r = [];
    let o = null;
    for (let a = 0, l = t.length; a < l; ++a) {
      const h = t[a];
      e.layerIndex = a;
      const c = h.layer, u = c.getSourceState();
      if (!bl(h, s) || u != "ready" && u != "undefined") {
        c.unrender();
        continue;
      }
      const d = c.render(e, o);
      d && (d !== o && (this.children_.push(d), o = d), r.push(h));
    }
    this.declutter(e, r), H_(this.element_, this.children_), this.dispatchRenderEvent(st.POSTCOMPOSE, e), this.renderedVisible_ || (this.element_.style.display = "", this.renderedVisible_ = !0), this.scheduleExpireIconCache(e);
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {Array<import('../layer/Layer.js').State>} layerStates Layers.
   */
  declutter(e, t) {
    for (let i = t.length - 1; i >= 0; --i) {
      const s = t[i], r = s.layer;
      r.getDeclutter() && r.renderDeclutter(e, s);
    }
    t.forEach(
      (i) => i.layer.renderDeferred(e)
    );
  }
}
const sp = np;
class mi extends dt {
  /**
   * @param {EventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */
  constructor(e, t) {
    super(e), this.layer = t;
  }
}
const sa = {
  LAYERS: "layers"
};
class Wl extends lu {
  /**
   * @param {Options} [options] Layer options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {Options} */
      Object.assign({}, e)
    );
    delete t.layers;
    let i = e.layers;
    super(t), this.on, this.once, this.un, this.layersListenerKeys_ = [], this.listenerKeys_ = {}, this.addChangeListener(sa.LAYERS, this.handleLayersChanged_), i ? Array.isArray(i) ? i = new ze(i.slice(), { unique: !0 }) : Q(
      typeof /** @type {?} */
      i.getArray == "function",
      "Expected `layers` to be an array or a `Collection`"
    ) : i = new ze(void 0, { unique: !0 }), this.setLayers(i);
  }
  /**
   * @private
   */
  handleLayerChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleLayersChanged_() {
    this.layersListenerKeys_.forEach(he), this.layersListenerKeys_.length = 0;
    const e = this.getLayers();
    this.layersListenerKeys_.push(
      Z(e, Fe.ADD, this.handleLayersAdd_, this),
      Z(
        e,
        Fe.REMOVE,
        this.handleLayersRemove_,
        this
      )
    );
    for (const i in this.listenerKeys_)
      this.listenerKeys_[i].forEach(he);
    Ws(this.listenerKeys_);
    const t = e.getArray();
    for (let i = 0, s = t.length; i < s; i++) {
      const r = t[i];
      this.registerLayerListeners_(r), this.dispatchEvent(new mi("addlayer", r));
    }
    this.changed();
  }
  /**
   * @param {BaseLayer} layer The layer.
   */
  registerLayerListeners_(e) {
    const t = [
      Z(
        e,
        Ji.PROPERTYCHANGE,
        this.handleLayerChange_,
        this
      ),
      Z(e, G.CHANGE, this.handleLayerChange_, this)
    ];
    e instanceof Wl && t.push(
      Z(e, "addlayer", this.handleLayerGroupAdd_, this),
      Z(e, "removelayer", this.handleLayerGroupRemove_, this)
    ), this.listenerKeys_[j(e)] = t;
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupAdd_(e) {
    this.dispatchEvent(new mi("addlayer", e.layer));
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupRemove_(e) {
    this.dispatchEvent(new mi("removelayer", e.layer));
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersAdd_(e) {
    const t = e.element;
    this.registerLayerListeners_(t), this.dispatchEvent(new mi("addlayer", t)), this.changed();
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersRemove_(e) {
    const t = e.element, i = j(t);
    this.listenerKeys_[i].forEach(he), delete this.listenerKeys_[i], this.dispatchEvent(new mi("removelayer", t)), this.changed();
  }
  /**
   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!Collection<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  getLayers() {
    return (
      /** @type {!Collection<import("./Base.js").default>} */
      this.get(sa.LAYERS)
    );
  }
  /**
   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!Collection<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  setLayers(e) {
    const t = this.getLayers();
    if (t) {
      const i = t.getArray();
      for (let s = 0, r = i.length; s < r; ++s)
        this.dispatchEvent(new mi("removelayer", i[s]));
    }
    this.set(sa.LAYERS, e);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(e) {
    return e = e !== void 0 ? e : [], this.getLayers().forEach(function(t) {
      t.getLayersArray(e);
    }), e;
  }
  /**
   * Get the layer states list and use this groups z-index as the default
   * for all layers in this and nested groups, if it is unset at this point.
   * If dest is not provided and this group's z-index is undefined
   * 0 is used a the default z-index.
   * @param {Array<import("./Layer.js").State>} [dest] Optional list
   * of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(e) {
    const t = e !== void 0 ? e : [], i = t.length;
    this.getLayers().forEach(function(o) {
      o.getLayerStatesArray(t);
    });
    const s = this.getLayerState();
    let r = s.zIndex;
    !e && s.zIndex === void 0 && (r = 0);
    for (let o = i, a = t.length; o < a; o++) {
      const l = t[o];
      l.opacity *= s.opacity, l.visible = l.visible && s.visible, l.maxResolution = Math.min(
        l.maxResolution,
        s.maxResolution
      ), l.minResolution = Math.max(
        l.minResolution,
        s.minResolution
      ), l.minZoom = Math.max(l.minZoom, s.minZoom), l.maxZoom = Math.min(l.maxZoom, s.maxZoom), s.extent !== void 0 && (l.extent !== void 0 ? l.extent = qt(
        l.extent,
        s.extent
      ) : l.extent = s.extent), l.zIndex === void 0 && (l.zIndex = r);
    }
    return t;
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return "ready";
  }
}
const en = Wl;
class rp extends dt {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */
  constructor(e, t, i) {
    super(e), this.map = t, this.frameState = i !== void 0 ? i : null;
  }
}
const wn = rp;
class op extends wn {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */
  constructor(e, t, i, s, r, o) {
    super(e, t, r), this.originalEvent = i, this.pixel_ = null, this.coordinate_ = null, this.dragging = s !== void 0 ? s : !1, this.activePointers = o;
  }
  /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */
  get pixel() {
    return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)), this.pixel_;
  }
  set pixel(e) {
    this.pixel_ = e;
  }
  /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */
  get coordinate() {
    return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)), this.coordinate_;
  }
  set coordinate(e) {
    this.coordinate_ = e;
  }
  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   */
  preventDefault() {
    super.preventDefault(), "preventDefault" in this.originalEvent && this.originalEvent.preventDefault();
  }
  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   */
  stopPropagation() {
    super.stopPropagation(), "stopPropagation" in this.originalEvent && this.originalEvent.stopPropagation();
  }
}
const Wt = op, J = {
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: "singleclick",
  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: G.CLICK,
  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: G.DBLCLICK,
  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: "pointerdrag",
  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
}, Lt = {
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};
class ap extends Ks {
  /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */
  constructor(e, t) {
    super(e), this.map_ = e, this.clickTimeoutId_, this.emulateClicks_ = !1, this.dragging_ = !1, this.dragListenerKeys_ = [], this.moveTolerance_ = t === void 0 ? 1 : t, this.down_ = null;
    const i = this.map_.getViewport();
    this.activePointers_ = [], this.trackedTouches_ = {}, this.element_ = i, this.pointerdownListenerKey_ = Z(
      i,
      Lt.POINTERDOWN,
      this.handlePointerDown_,
      this
    ), this.originalPointerMoveEvent_, this.relayedListenerKey_ = Z(
      i,
      Lt.POINTERMOVE,
      this.relayMoveEvent_,
      this
    ), this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this), this.element_.addEventListener(
      G.TOUCHMOVE,
      this.boundHandleTouchMove_,
      ju ? { passive: !1 } : !1
    );
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  emulateClick_(e) {
    let t = new Wt(
      J.CLICK,
      this.map_,
      e
    );
    this.dispatchEvent(t), this.clickTimeoutId_ !== void 0 ? (clearTimeout(this.clickTimeoutId_), this.clickTimeoutId_ = void 0, t = new Wt(
      J.DBLCLICK,
      this.map_,
      e
    ), this.dispatchEvent(t)) : this.clickTimeoutId_ = setTimeout(() => {
      this.clickTimeoutId_ = void 0;
      const i = new Wt(
        J.SINGLECLICK,
        this.map_,
        e
      );
      this.dispatchEvent(i);
    }, 250);
  }
  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  updateActivePointers_(e) {
    const t = e, i = t.pointerId;
    if (t.type == J.POINTERUP || t.type == J.POINTERCANCEL) {
      delete this.trackedTouches_[i];
      for (const s in this.trackedTouches_)
        if (this.trackedTouches_[s].target !== t.target) {
          delete this.trackedTouches_[s];
          break;
        }
    } else
      (t.type == J.POINTERDOWN || t.type == J.POINTERMOVE) && (this.trackedTouches_[i] = t);
    this.activePointers_ = Object.values(this.trackedTouches_);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerUp_(e) {
    this.updateActivePointers_(e);
    const t = new Wt(
      J.POINTERUP,
      this.map_,
      e,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(t), this.emulateClicks_ && !t.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(e) && this.emulateClick_(this.down_), this.activePointers_.length === 0 && (this.dragListenerKeys_.forEach(he), this.dragListenerKeys_.length = 0, this.dragging_ = !1, this.down_ = null);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */
  isMouseActionButton_(e) {
    return e.button === 0;
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerDown_(e) {
    this.emulateClicks_ = this.activePointers_.length === 0, this.updateActivePointers_(e);
    const t = new Wt(
      J.POINTERDOWN,
      this.map_,
      e,
      void 0,
      void 0,
      this.activePointers_
    );
    if (this.dispatchEvent(t), this.down_ = new PointerEvent(e.type, e), Object.defineProperty(this.down_, "target", {
      writable: !1,
      value: e.target
    }), this.dragListenerKeys_.length === 0) {
      const i = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(
        Z(
          i,
          J.POINTERMOVE,
          this.handlePointerMove_,
          this
        ),
        Z(i, J.POINTERUP, this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        Z(
          this.element_,
          J.POINTERCANCEL,
          this.handlePointerUp_,
          this
        )
      ), this.element_.getRootNode && this.element_.getRootNode() !== i && this.dragListenerKeys_.push(
        Z(
          this.element_.getRootNode(),
          J.POINTERUP,
          this.handlePointerUp_,
          this
        )
      );
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerMove_(e) {
    if (this.isMoving_(e)) {
      this.updateActivePointers_(e), this.dragging_ = !0;
      const t = new Wt(
        J.POINTERDRAG,
        this.map_,
        e,
        this.dragging_,
        void 0,
        this.activePointers_
      );
      this.dispatchEvent(t);
    }
  }
  /**
   * Wrap and relay a pointermove event.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  relayMoveEvent_(e) {
    this.originalPointerMoveEvent_ = e;
    const t = !!(this.down_ && this.isMoving_(e));
    this.dispatchEvent(
      new Wt(
        J.POINTERMOVE,
        this.map_,
        e,
        t
      )
    );
  }
  /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */
  handleTouchMove_(e) {
    const t = this.originalPointerMoveEvent_;
    (!t || t.defaultPrevented) && (typeof e.cancelable != "boolean" || e.cancelable === !0) && e.preventDefault();
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */
  isMoving_(e) {
    return this.dragging_ || Math.abs(e.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(e.clientY - this.down_.clientY) > this.moveTolerance_;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.relayedListenerKey_ && (he(this.relayedListenerKey_), this.relayedListenerKey_ = null), this.element_.removeEventListener(
      G.TOUCHMOVE,
      this.boundHandleTouchMove_
    ), this.pointerdownListenerKey_ && (he(this.pointerdownListenerKey_), this.pointerdownListenerKey_ = null), this.dragListenerKeys_.forEach(he), this.dragListenerKeys_.length = 0, this.element_ = null, super.disposeInternal();
  }
}
const lp = ap, Pt = {
  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: "movestart",
  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: "moveend",
  /**
   * Triggered when loading of additional map data (tiles, images, features) starts.
   * @event module:ol/MapEvent~MapEvent#loadstart
   * @api
   */
  LOADSTART: "loadstart",
  /**
   * Triggered when loading of additional map data has completed.
   * @event module:ol/MapEvent~MapEvent#loadend
   * @api
   */
  LOADEND: "loadend"
}, Ce = {
  LAYERGROUP: "layergroup",
  SIZE: "size",
  TARGET: "target",
  VIEW: "view"
}, Hr = 1 / 0;
class hp {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  constructor(e, t) {
    this.priorityFunction_ = e, this.keyFunction_ = t, this.elements_ = [], this.priorities_ = [], this.queuedElements_ = {};
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.elements_.length = 0, this.priorities_.length = 0, Ws(this.queuedElements_);
  }
  /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */
  dequeue() {
    const e = this.elements_, t = this.priorities_, i = e[0];
    e.length == 1 ? (e.length = 0, t.length = 0) : (e[0] = /** @type {T} */
    e.pop(), t[0] = /** @type {number} */
    t.pop(), this.siftUp_(0));
    const s = this.keyFunction_(i);
    return delete this.queuedElements_[s], i;
  }
  /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(e) {
    Q(
      !(this.keyFunction_(e) in this.queuedElements_),
      "Tried to enqueue an `element` that was already added to the queue"
    );
    const t = this.priorityFunction_(e);
    return t != Hr ? (this.elements_.push(e), this.priorities_.push(t), this.queuedElements_[this.keyFunction_(e)] = !0, this.siftDown_(0, this.elements_.length - 1), !0) : !1;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.elements_.length;
  }
  /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */
  getLeftChildIndex_(e) {
    return e * 2 + 1;
  }
  /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */
  getRightChildIndex_(e) {
    return e * 2 + 2;
  }
  /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */
  getParentIndex_(e) {
    return e - 1 >> 1;
  }
  /**
   * Make this a heap. O(N).
   * @private
   */
  heapify_() {
    let e;
    for (e = (this.elements_.length >> 1) - 1; e >= 0; e--)
      this.siftUp_(e);
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.elements_.length === 0;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */
  isKeyQueued(e) {
    return e in this.queuedElements_;
  }
  /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */
  isQueued(e) {
    return this.isKeyQueued(this.keyFunction_(e));
  }
  /**
   * @param {number} index The index of the node to move down.
   * @private
   */
  siftUp_(e) {
    const t = this.elements_, i = this.priorities_, s = t.length, r = t[e], o = i[e], a = e;
    for (; e < s >> 1; ) {
      const l = this.getLeftChildIndex_(e), h = this.getRightChildIndex_(e), c = h < s && i[h] < i[l] ? h : l;
      t[e] = t[c], i[e] = i[c], e = c;
    }
    t[e] = r, i[e] = o, this.siftDown_(a, e);
  }
  /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */
  siftDown_(e, t) {
    const i = this.elements_, s = this.priorities_, r = i[t], o = s[t];
    for (; t > e; ) {
      const a = this.getParentIndex_(t);
      if (s[a] > o)
        i[t] = i[a], s[t] = s[a], t = a;
      else
        break;
    }
    i[t] = r, s[t] = o;
  }
  /**
   * FIXME empty description for jsdoc
   */
  reprioritize() {
    const e = this.priorityFunction_, t = this.elements_, i = this.priorities_;
    let s = 0;
    const r = t.length;
    let o, a, l;
    for (a = 0; a < r; ++a)
      o = t[a], l = e(o), l == Hr ? delete this.queuedElements_[this.keyFunction_(o)] : (i[s] = l, t[s++] = o);
    t.length = s, i.length = s, this.heapify_();
  }
}
const cp = hp, P = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
};
class up extends cp {
  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */
  constructor(e, t) {
    super(
      /**
       * @param {Array} element Element.
       * @return {number} Priority.
       */
      function(i) {
        return e.apply(null, i);
      },
      /**
       * @param {Array} element Element.
       * @return {string} Key.
       */
      function(i) {
        return (
          /** @type {import("./Tile.js").default} */
          i[0].getKey()
        );
      }
    ), this.boundHandleTileChange_ = this.handleTileChange.bind(this), this.tileChangeCallback_ = t, this.tilesLoading_ = 0, this.tilesLoadingKeys_ = {};
  }
  /**
   * @param {Array} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(e) {
    const t = super.enqueue(e);
    return t && e[0].addEventListener(G.CHANGE, this.boundHandleTileChange_), t;
  }
  /**
   * @return {number} Number of tiles loading.
   */
  getTilesLoading() {
    return this.tilesLoading_;
  }
  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(e) {
    const t = (
      /** @type {import("./Tile.js").default} */
      e.target
    ), i = t.getState();
    if (i === P.LOADED || i === P.ERROR || i === P.EMPTY) {
      i !== P.ERROR && t.removeEventListener(G.CHANGE, this.boundHandleTileChange_);
      const s = t.getKey();
      s in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[s], --this.tilesLoading_), this.tileChangeCallback_();
    }
  }
  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */
  loadMoreTiles(e, t) {
    let i = 0, s, r, o;
    for (; this.tilesLoading_ < e && i < t && this.getCount() > 0; )
      r = /** @type {import("./Tile.js").default} */
      this.dequeue()[0], o = r.getKey(), s = r.getState(), s === P.IDLE && !(o in this.tilesLoadingKeys_) && (this.tilesLoadingKeys_[o] = !0, ++this.tilesLoading_, ++i, r.load());
  }
}
const dp = up;
function fp(n, e, t, i, s) {
  if (!n || !(t in n.wantedTiles) || !n.wantedTiles[t][e.getKey()])
    return Hr;
  const r = n.viewState.center, o = i[0] - r[0], a = i[1] - r[1];
  return 65536 * Math.log(s) + Math.sqrt(o * o + a * a) / s;
}
class gp extends vt {
  /**
   * @param {Options} options Control options.
   */
  constructor(e) {
    super();
    const t = e.element;
    t && !e.target && !t.style.pointerEvents && (t.style.pointerEvents = "auto"), this.element = t || null, this.target_ = null, this.map_ = null, this.listenerKeys = [], e.render && (this.render = e.render), e.target && this.setTarget(e.target);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    Yr(this.element), super.disposeInternal();
  }
  /**
   * Get the map associated with this control.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    this.map_ && Yr(this.element);
    for (let t = 0, i = this.listenerKeys.length; t < i; ++t)
      he(this.listenerKeys[t]);
    this.listenerKeys.length = 0, this.map_ = e, e && ((this.target_ ? this.target_ : e.getOverlayContainerStopEvent()).appendChild(this.element), this.render !== Gn && this.listenerKeys.push(
      Z(e, Pt.POSTRENDER, this.render, this)
    ), e.render());
  }
  /**
   * Renders the control.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */
  render(e) {
  }
  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */
  setTarget(e) {
    this.target_ = typeof e == "string" ? document.getElementById(e) : e;
  }
}
const Gt = gp;
class _p extends Gt {
  /**
   * @param {Options} [options] Attribution options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      render: e.render,
      target: e.target
    }), this.ulElement_ = document.createElement("ul"), this.collapsed_ = e.collapsed !== void 0 ? e.collapsed : !0, this.userCollapsed_ = this.collapsed_, this.overrideCollapsible_ = e.collapsible !== void 0, this.collapsible_ = e.collapsible !== void 0 ? e.collapsible : !0, this.collapsible_ || (this.collapsed_ = !1);
    const t = e.className !== void 0 ? e.className : "ol-attribution", i = e.tipLabel !== void 0 ? e.tipLabel : "Attributions", s = e.expandClassName !== void 0 ? e.expandClassName : t + "-expand", r = e.collapseLabel !== void 0 ? e.collapseLabel : "›", o = e.collapseClassName !== void 0 ? e.collapseClassName : t + "-collapse";
    typeof r == "string" ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = r, this.collapseLabel_.className = o) : this.collapseLabel_ = r;
    const a = e.label !== void 0 ? e.label : "i";
    typeof a == "string" ? (this.label_ = document.createElement("span"), this.label_.textContent = a, this.label_.className = s) : this.label_ = a;
    const l = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
    this.toggleButton_ = document.createElement("button"), this.toggleButton_.setAttribute("type", "button"), this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_)), this.toggleButton_.title = i, this.toggleButton_.appendChild(l), this.toggleButton_.addEventListener(
      G.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const h = t + " " + Dt + " " + rn + (this.collapsed_ && this.collapsible_ ? " " + Xr : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), c = this.element;
    c.className = h, c.appendChild(this.toggleButton_), c.appendChild(this.ulElement_), this.renderedAttributions_ = [], this.renderedVisible_ = !0;
  }
  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */
  collectSourceAttributions_(e) {
    const t = Array.from(
      new Set(
        this.getMap().getAllLayers().flatMap((s) => s.getAttributions(e))
      )
    ), i = !this.getMap().getAllLayers().some(
      (s) => s.getSource() && s.getSource().getAttributionsCollapsible() === !1
    );
    return this.overrideCollapsible_ || this.setCollapsible(i), t;
  }
  /**
   * @private
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  updateElement_(e) {
    if (!e) {
      this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    const t = this.collectSourceAttributions_(e), i = t.length > 0;
    if (this.renderedVisible_ != i && (this.element.style.display = i ? "" : "none", this.renderedVisible_ = i), !ri(t, this.renderedAttributions_)) {
      Yu(this.ulElement_);
      for (let s = 0, r = t.length; s < r; ++s) {
        const o = document.createElement("li");
        o.innerHTML = t[s], this.ulElement_.appendChild(o);
      }
      this.renderedAttributions_ = t;
    }
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.handleToggle_(), this.userCollapsed_ = this.collapsed_;
  }
  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(Xr), this.collapsed_ ? Yn(this.collapseLabel_, this.label_) : Yn(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_, this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
  }
  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }
  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(e) {
    this.collapsible_ !== e && (this.collapsible_ = e, this.element.classList.toggle("ol-uncollapsible"), this.userCollapsed_ && this.handleToggle_());
  }
  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(e) {
    this.userCollapsed_ = e, !(!this.collapsible_ || this.collapsed_ === e) && this.handleToggle_();
  }
  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }
  /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    this.updateElement_(e.frameState);
  }
}
const ld = _p;
class mp extends Gt {
  /**
   * @param {Options} [options] Rotate options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      render: e.render,
      target: e.target
    });
    const t = e.className !== void 0 ? e.className : "ol-rotate", i = e.label !== void 0 ? e.label : "⇧", s = e.compassClassName !== void 0 ? e.compassClassName : "ol-compass";
    this.label_ = null, typeof i == "string" ? (this.label_ = document.createElement("span"), this.label_.className = s, this.label_.textContent = i) : (this.label_ = i, this.label_.classList.add(s));
    const r = e.tipLabel ? e.tipLabel : "Reset rotation", o = document.createElement("button");
    o.className = t + "-reset", o.setAttribute("type", "button"), o.title = r, o.appendChild(this.label_), o.addEventListener(
      G.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const a = t + " " + Dt + " " + rn, l = this.element;
    l.className = a, l.appendChild(o), this.callResetNorth_ = e.resetNorth ? e.resetNorth : void 0, this.duration_ = e.duration !== void 0 ? e.duration : 250, this.autoHide_ = e.autoHide !== void 0 ? e.autoHide : !0, this.rotation_ = void 0, this.autoHide_ && this.element.classList.add(xr);
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.callResetNorth_ !== void 0 ? this.callResetNorth_() : this.resetNorth_();
  }
  /**
   * @private
   */
  resetNorth_() {
    const t = this.getMap().getView();
    if (!t)
      return;
    const i = t.getRotation();
    i !== void 0 && (this.duration_ > 0 && i % (2 * Math.PI) !== 0 ? t.animate({
      rotation: 0,
      duration: this.duration_,
      easing: nn
    }) : t.setRotation(0));
  }
  /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    const t = e.frameState;
    if (!t)
      return;
    const i = t.viewState.rotation;
    if (i != this.rotation_) {
      const s = "rotate(" + i + "rad)";
      if (this.autoHide_) {
        const r = this.element.classList.contains(xr);
        !r && i === 0 ? this.element.classList.add(xr) : r && i !== 0 && this.element.classList.remove(xr);
      }
      this.label_.style.transform = s;
    }
    this.rotation_ = i;
  }
}
const hd = mp;
class pp extends Gt {
  /**
   * @param {Options} [options] Zoom options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      target: e.target
    });
    const t = e.className !== void 0 ? e.className : "ol-zoom", i = e.delta !== void 0 ? e.delta : 1, s = e.zoomInClassName !== void 0 ? e.zoomInClassName : t + "-in", r = e.zoomOutClassName !== void 0 ? e.zoomOutClassName : t + "-out", o = e.zoomInLabel !== void 0 ? e.zoomInLabel : "+", a = e.zoomOutLabel !== void 0 ? e.zoomOutLabel : "–", l = e.zoomInTipLabel !== void 0 ? e.zoomInTipLabel : "Zoom in", h = e.zoomOutTipLabel !== void 0 ? e.zoomOutTipLabel : "Zoom out", c = document.createElement("button");
    c.className = s, c.setAttribute("type", "button"), c.title = l, c.appendChild(
      typeof o == "string" ? document.createTextNode(o) : o
    ), c.addEventListener(
      G.CLICK,
      this.handleClick_.bind(this, i),
      !1
    );
    const u = document.createElement("button");
    u.className = r, u.setAttribute("type", "button"), u.title = h, u.appendChild(
      typeof a == "string" ? document.createTextNode(a) : a
    ), u.addEventListener(
      G.CLICK,
      this.handleClick_.bind(this, -i),
      !1
    );
    const d = t + " " + Dt + " " + rn, f = this.element;
    f.className = d, f.appendChild(c), f.appendChild(u), this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e, t) {
    t.preventDefault(), this.zoomByDelta_(e);
  }
  /**
   * @param {number} delta Zoom delta.
   * @private
   */
  zoomByDelta_(e) {
    const i = this.getMap().getView();
    if (!i)
      return;
    const s = i.getZoom();
    if (s !== void 0) {
      const r = i.getConstrainedZoom(s + e);
      this.duration_ > 0 ? (i.getAnimating() && i.cancelAnimations(), i.animate({
        zoom: r,
        duration: this.duration_,
        easing: nn
      })) : i.setZoom(r);
    }
  }
}
const cd = pp;
function ud(n) {
  n = n || {};
  const e = new ze();
  return (n.zoom !== void 0 ? n.zoom : !0) && e.push(new cd(n.zoomOptions)), (n.rotate !== void 0 ? n.rotate : !0) && e.push(new hd(n.rotateOptions)), (n.attribution !== void 0 ? n.attribution : !0) && e.push(new ld(n.attributionOptions)), e;
}
const za = {
  ACTIVE: "active"
};
class yp extends vt {
  /**
   * @param {InteractionOptions} [options] Options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e && e.handleEvent && (this.handleEvent = e.handleEvent), this.map_ = null, this.setActive(!0);
  }
  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */
  getActive() {
    return (
      /** @type {boolean} */
      this.get(za.ACTIVE)
    );
  }
  /**
   * Get the map associated with this interaction.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(e) {
    return !0;
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(e) {
    this.set(za.ACTIVE, e);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(e) {
    this.map_ = e;
  }
}
function xp(n, e, t) {
  const i = n.getCenterInternal();
  if (i) {
    const s = [i[0] + e[0], i[1] + e[1]];
    n.animateInternal({
      duration: t !== void 0 ? t : 250,
      easing: n_,
      center: n.getConstrainedCenter(s)
    });
  }
}
function Kl(n, e, t, i) {
  const s = n.getZoom();
  if (s === void 0)
    return;
  const r = n.getConstrainedZoom(s + e), o = n.getResolutionForZoom(r);
  n.getAnimating() && n.cancelAnimations(), n.animate({
    resolution: o,
    anchor: t,
    duration: i !== void 0 ? i : 250,
    easing: nn
  });
}
const sr = yp;
class Ep extends sr {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.delta_ = e.delta ? e.delta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    let t = !1;
    if (e.type == J.DBLCLICK) {
      const i = (
        /** @type {MouseEvent} */
        e.originalEvent
      ), s = e.map, r = e.coordinate, o = i.shiftKey ? -this.delta_ : this.delta_, a = s.getView();
      Kl(a, o, r, this.duration_), i.preventDefault(), t = !0;
    }
    return !t;
  }
}
const Cp = Ep;
class wp extends sr {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      e
    ), e.handleDownEvent && (this.handleDownEvent = e.handleDownEvent), e.handleDragEvent && (this.handleDragEvent = e.handleDragEvent), e.handleMoveEvent && (this.handleMoveEvent = e.handleMoveEvent), e.handleUpEvent && (this.handleUpEvent = e.handleUpEvent), e.stopDown && (this.stopDown = e.stopDown), this.handlingDownUpSequence = !1, this.targetPointers = [];
  }
  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */
  getPointerCount() {
    return this.targetPointers.length;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleDownEvent(e) {
    return !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleDragEvent(e) {
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(e) {
    if (!e.originalEvent)
      return !0;
    let t = !1;
    if (this.updateTrackedPointers_(e), this.handlingDownUpSequence) {
      if (e.type == J.POINTERDRAG)
        this.handleDragEvent(e), e.originalEvent.preventDefault();
      else if (e.type == J.POINTERUP) {
        const i = this.handleUpEvent(e);
        this.handlingDownUpSequence = i && this.targetPointers.length > 0;
      }
    } else if (e.type == J.POINTERDOWN) {
      const i = this.handleDownEvent(e);
      this.handlingDownUpSequence = i, t = this.stopDown(i);
    } else
      e.type == J.POINTERMOVE && this.handleMoveEvent(e);
    return !t;
  }
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleMoveEvent(e) {
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleUpEvent(e) {
    return !1;
  }
  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */
  stopDown(e) {
    return e;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */
  updateTrackedPointers_(e) {
    e.activePointers && (this.targetPointers = e.activePointers);
  }
}
function Zl(n) {
  const e = n.length;
  let t = 0, i = 0;
  for (let s = 0; s < e; s++)
    t += n[s].clientX, i += n[s].clientY;
  return { clientX: t / e, clientY: i / e };
}
const on = wp;
function $a(n) {
  const e = arguments;
  return function(t) {
    let i = !0;
    for (let s = 0, r = e.length; s < r && (i = i && e[s](t), !!i); ++s)
      ;
    return i;
  };
}
const Sp = function(n) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    n.originalEvent
  );
  return e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey;
}, vp = function(n) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    n.originalEvent
  );
  return e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
}, Tp = function(n) {
  const e = n.map.getTargetElement(), t = n.map.getOwnerDocument().activeElement;
  return e.contains(t);
}, dd = function(n) {
  return n.map.getTargetElement().hasAttribute("tabindex") ? Tp(n) : !0;
}, qr = kn, fd = function(n) {
  const e = (
    /** @type {MouseEvent} */
    n.originalEvent
  );
  return e.button == 0 && !(B_ && Ol && e.ctrlKey);
}, Rp = Hn, Ip = function(n) {
  return n.type == J.SINGLECLICK;
}, Hl = function(n) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    n.originalEvent
  );
  return !e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey;
}, fc = function(n) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    n.originalEvent
  );
  return !e.altKey && (Ol ? e.metaKey : e.ctrlKey) && !e.shiftKey;
}, Pp = function(n) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    n.originalEvent
  );
  return Ol ? e.metaKey : e.ctrlKey;
}, gd = function(n) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    n.originalEvent
  );
  return !e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
}, _d = function(n) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    n.originalEvent
  ), t = (
    /** @type {Element} */
    e.target.tagName
  );
  return t !== "INPUT" && t !== "SELECT" && t !== "TEXTAREA" && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
  // different type like `SVGElement`.
  // @ts-ignore
  !e.target.isContentEditable;
}, ra = function(n) {
  const e = (
    /** @type {import("../MapBrowserEvent").default} */
    n.originalEvent
  );
  return Q(
    e !== void 0,
    "mapBrowserEvent must originate from a pointer event"
  ), e.pointerType == "mouse";
}, md = function(n) {
  const e = (
    /** @type {import("../MapBrowserEvent").default} */
    n.originalEvent
  );
  return Q(
    e !== void 0,
    "mapBrowserEvent must originate from a pointer event"
  ), e.isPrimary && e.button === 0;
};
class Lp extends on {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super({
      stopDown: Hn
    }), e = e || {}, this.kinetic_ = e.kinetic, this.lastCentroid = null, this.lastPointersCount_, this.panning_ = !1;
    const t = e.condition ? e.condition : $a(Hl, md);
    this.condition_ = e.onFocusOnly ? $a(dd, t) : t, this.noKinetic_ = !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    const t = e.map;
    this.panning_ || (this.panning_ = !0, t.getView().beginInteraction());
    const i = this.targetPointers, s = t.getEventPixel(Zl(i));
    if (i.length == this.lastPointersCount_) {
      if (this.kinetic_ && this.kinetic_.update(s[0], s[1]), this.lastCentroid) {
        const r = [
          this.lastCentroid[0] - s[0],
          s[1] - this.lastCentroid[1]
        ], a = e.map.getView();
        $g(r, a.getResolution()), hl(r, a.getRotation()), a.adjustCenterInternal(r);
      }
    } else
      this.kinetic_ && this.kinetic_.begin();
    this.lastCentroid = s, this.lastPointersCount_ = i.length, e.originalEvent.preventDefault();
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    const t = e.map, i = t.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        const s = this.kinetic_.getDistance(), r = this.kinetic_.getAngle(), o = i.getCenterInternal(), a = t.getPixelFromCoordinateInternal(o), l = t.getCoordinateFromPixelInternal([
          a[0] - s * Math.cos(r),
          a[1] - s * Math.sin(r)
        ]);
        i.animateInternal({
          center: i.getConstrainedCenter(l),
          duration: 500,
          easing: nn
        });
      }
      return this.panning_ && (this.panning_ = !1, i.endInteraction()), !1;
    }
    return this.kinetic_ && this.kinetic_.begin(), this.lastCentroid = null, !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (this.targetPointers.length > 0 && this.condition_(e)) {
      const i = e.map.getView();
      return this.lastCentroid = null, i.getAnimating() && i.cancelAnimations(), this.kinetic_ && this.kinetic_.begin(), this.noKinetic_ = this.targetPointers.length > 1, !0;
    }
    return !1;
  }
}
const Ss = Lp;
class bp extends on {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super({
      stopDown: Hn
    }), this.condition_ = e.condition ? e.condition : vp, this.lastAngle_ = void 0, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    if (!ra(e))
      return;
    const t = e.map, i = t.getView();
    if (i.getConstraints().rotation === ml)
      return;
    const s = t.getSize(), r = e.pixel, o = Math.atan2(s[1] / 2 - r[1], r[0] - s[0] / 2);
    if (this.lastAngle_ !== void 0) {
      const a = o - this.lastAngle_;
      i.adjustRotationInternal(-a);
    }
    this.lastAngle_ = o;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    return ra(e) ? (e.map.getView().endInteraction(this.duration_), !1) : !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    return ra(e) && fd(e) && this.condition_(e) ? (e.map.getView().beginInteraction(), this.lastAngle_ = void 0, !0) : !1;
  }
}
const Ap = bp;
class Fp extends il {
  /**
   * @param {string} className CSS class name.
   */
  constructor(e) {
    super(), this.geometry_ = null, this.element_ = document.createElement("div"), this.element_.style.position = "absolute", this.element_.style.pointerEvents = "auto", this.element_.className = "ol-box " + e, this.map_ = null, this.startPixel_ = null, this.endPixel_ = null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.setMap(null);
  }
  /**
   * @private
   */
  render_() {
    const e = this.startPixel_, t = this.endPixel_, i = "px", s = this.element_.style;
    s.left = Math.min(e[0], t[0]) + i, s.top = Math.min(e[1], t[1]) + i, s.width = Math.abs(t[0] - e[0]) + i, s.height = Math.abs(t[1] - e[1]) + i;
  }
  /**
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(e) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      const t = this.element_.style;
      t.left = "inherit", t.top = "inherit", t.width = "inherit", t.height = "inherit";
    }
    this.map_ = e, this.map_ && this.map_.getOverlayContainer().appendChild(this.element_);
  }
  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */
  setPixels(e, t) {
    this.startPixel_ = e, this.endPixel_ = t, this.createOrUpdateGeometry(), this.render_();
  }
  /**
   * Creates or updates the cached geometry.
   */
  createOrUpdateGeometry() {
    const e = this.startPixel_, t = this.endPixel_, s = [
      e,
      [e[0], t[1]],
      t,
      [t[0], e[1]]
    ].map(
      this.map_.getCoordinateFromPixelInternal,
      this.map_
    );
    s[4] = s[0].slice(), this.geometry_ ? this.geometry_.setCoordinates([s]) : this.geometry_ = new Ne([s]);
  }
  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */
  getGeometry() {
    return this.geometry_;
  }
}
const Mp = Fp, Er = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: "boxstart",
  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: "boxdrag",
  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: "boxend",
  /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */
  BOXCANCEL: "boxcancel"
};
class oa extends dt {
  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */
  constructor(e, t, i) {
    super(e), this.coordinate = t, this.mapBrowserEvent = i;
  }
}
class Op extends on {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e = e || {}, this.box_ = new Mp(e.className || "ol-dragbox"), this.minArea_ = e.minArea !== void 0 ? e.minArea : 64, e.onBoxEnd && (this.onBoxEnd = e.onBoxEnd), this.startPixel_ = null, this.condition_ = e.condition ? e.condition : fd, this.boxEndCondition_ = e.boxEndCondition ? e.boxEndCondition : this.defaultBoxEndCondition;
  }
  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */
  defaultBoxEndCondition(e, t, i) {
    const s = i[0] - t[0], r = i[1] - t[1];
    return s * s + r * r >= this.minArea_;
  }
  /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */
  getGeometry() {
    return this.box_.getGeometry();
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    this.box_.setPixels(this.startPixel_, e.pixel), this.dispatchEvent(
      new oa(
        Er.BOXDRAG,
        e.coordinate,
        e
      )
    );
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    this.box_.setMap(null);
    const t = this.boxEndCondition_(
      e,
      this.startPixel_,
      e.pixel
    );
    return t && this.onBoxEnd(e), this.dispatchEvent(
      new oa(
        t ? Er.BOXEND : Er.BOXCANCEL,
        e.coordinate,
        e
      )
    ), !1;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    return this.condition_(e) ? (this.startPixel_ = e.pixel, this.box_.setMap(e.map), this.box_.setPixels(this.startPixel_, this.startPixel_), this.dispatchEvent(
      new oa(
        Er.BOXSTART,
        e.coordinate,
        e
      )
    ), !0) : !1;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(e) {
  }
}
const Dp = Op;
class Np extends Dp {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = e.condition ? e.condition : gd;
    super({
      condition: t,
      className: e.className || "ol-dragzoom",
      minArea: e.minArea
    }), this.duration_ = e.duration !== void 0 ? e.duration : 200, this.out_ = e.out !== void 0 ? e.out : !1;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(e) {
    const i = (
      /** @type {!import("../View.js").default} */
      this.getMap().getView()
    );
    let s = this.getGeometry();
    if (this.out_) {
      const r = i.rotatedExtentForGeometry(s), o = i.getResolutionForExtentInternal(r), a = i.getResolution() / o;
      s = s.clone(), s.scale(a * a);
    }
    i.fitInternal(s, {
      duration: this.duration_,
      easing: nn
    });
  }
}
const kp = Np, Vi = {
  LEFT: "ArrowLeft",
  UP: "ArrowUp",
  RIGHT: "ArrowRight",
  DOWN: "ArrowDown"
};
class Gp extends sr {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.defaultCondition_ = function(t) {
      return Hl(t) && _d(t);
    }, this.condition_ = e.condition !== void 0 ? e.condition : this.defaultCondition_, this.duration_ = e.duration !== void 0 ? e.duration : 100, this.pixelDelta_ = e.pixelDelta !== void 0 ? e.pixelDelta : 128;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    let t = !1;
    if (e.type == G.KEYDOWN) {
      const i = (
        /** @type {KeyboardEvent} */
        e.originalEvent
      ), s = i.key;
      if (this.condition_(e) && (s == Vi.DOWN || s == Vi.LEFT || s == Vi.RIGHT || s == Vi.UP)) {
        const o = e.map.getView(), a = o.getResolution() * this.pixelDelta_;
        let l = 0, h = 0;
        s == Vi.DOWN ? h = -a : s == Vi.LEFT ? l = -a : s == Vi.RIGHT ? l = a : h = a;
        const c = [l, h];
        hl(c, o.getRotation()), xp(o, c, this.duration_), i.preventDefault(), t = !0;
      }
    }
    return !t;
  }
}
const zp = Gp;
class $p extends sr {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.condition_ = e.condition ? e.condition : function(t) {
      return !Pp(t) && _d(t);
    }, this.delta_ = e.delta ? e.delta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 100;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    let t = !1;
    if (e.type == G.KEYDOWN || e.type == G.KEYPRESS) {
      const i = (
        /** @type {KeyboardEvent} */
        e.originalEvent
      ), s = i.key;
      if (this.condition_(e) && (s === "+" || s === "-")) {
        const r = e.map, o = s === "+" ? this.delta_ : -this.delta_, a = r.getView();
        Kl(a, o, void 0, this.duration_), i.preventDefault(), t = !0;
      }
    }
    return !t;
  }
}
const Up = $p;
class Vp {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  constructor(e, t, i) {
    this.decay_ = e, this.minVelocity_ = t, this.delay_ = i, this.points_ = [], this.angle_ = 0, this.initialVelocity_ = 0;
  }
  /**
   * FIXME empty description for jsdoc
   */
  begin() {
    this.points_.length = 0, this.angle_ = 0, this.initialVelocity_ = 0;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   */
  update(e, t) {
    this.points_.push(e, t, Date.now());
  }
  /**
   * @return {boolean} Whether we should do kinetic animation.
   */
  end() {
    if (this.points_.length < 6)
      return !1;
    const e = Date.now() - this.delay_, t = this.points_.length - 3;
    if (this.points_[t + 2] < e)
      return !1;
    let i = t - 3;
    for (; i > 0 && this.points_[i + 2] > e; )
      i -= 3;
    const s = this.points_[t + 2] - this.points_[i + 2];
    if (s < 1e3 / 60)
      return !1;
    const r = this.points_[t] - this.points_[i], o = this.points_[t + 1] - this.points_[i + 1];
    return this.angle_ = Math.atan2(o, r), this.initialVelocity_ = Math.sqrt(r * r + o * o) / s, this.initialVelocity_ > this.minVelocity_;
  }
  /**
   * @return {number} Total distance travelled (pixels).
   */
  getDistance() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  }
  /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */
  getAngle() {
    return this.angle_;
  }
}
const jp = Vp;
class Yp extends sr {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      e
    ), this.totalDelta_ = 0, this.lastDelta_ = 0, this.maxDelta_ = e.maxDelta !== void 0 ? e.maxDelta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 250, this.timeout_ = e.timeout !== void 0 ? e.timeout : 80, this.useAnchor_ = e.useAnchor !== void 0 ? e.useAnchor : !0, this.constrainResolution_ = e.constrainResolution !== void 0 ? e.constrainResolution : !1;
    const t = e.condition ? e.condition : qr;
    this.condition_ = e.onFocusOnly ? $a(dd, t) : t, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_, this.mode_ = void 0, this.trackpadEventGap_ = 400, this.trackpadTimeoutId_, this.deltaPerZoom_ = 300;
  }
  /**
   * @private
   */
  endInteraction_() {
    this.trackpadTimeoutId_ = void 0;
    const e = this.getMap();
    if (!e)
      return;
    e.getView().endInteraction(
      void 0,
      this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0,
      this.lastAnchor_
    );
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    if (!this.condition_(e) || e.type !== G.WHEEL)
      return !0;
    const i = e.map, s = (
      /** @type {WheelEvent} */
      e.originalEvent
    );
    s.preventDefault(), this.useAnchor_ && (this.lastAnchor_ = e.coordinate);
    let r;
    if (e.type == G.WHEEL && (r = s.deltaY, Y_ && s.deltaMode === WheelEvent.DOM_DELTA_PIXEL && (r /= Uu), s.deltaMode === WheelEvent.DOM_DELTA_LINE && (r *= 40)), r === 0)
      return !1;
    this.lastDelta_ = r;
    const o = Date.now();
    this.startTime_ === void 0 && (this.startTime_ = o), (!this.mode_ || o - this.startTime_ > this.trackpadEventGap_) && (this.mode_ = Math.abs(r) < 4 ? "trackpad" : "wheel");
    const a = i.getView();
    if (this.mode_ === "trackpad" && !(a.getConstrainResolution() || this.constrainResolution_))
      return this.trackpadTimeoutId_ ? clearTimeout(this.trackpadTimeoutId_) : (a.getAnimating() && a.cancelAnimations(), a.beginInteraction()), this.trackpadTimeoutId_ = setTimeout(
        this.endInteraction_.bind(this),
        this.timeout_
      ), a.adjustZoom(-r / this.deltaPerZoom_, this.lastAnchor_), this.startTime_ = o, !1;
    this.totalDelta_ += r;
    const l = Math.max(this.timeout_ - (o - this.startTime_), 0);
    return clearTimeout(this.timeoutId_), this.timeoutId_ = setTimeout(
      this.handleWheelZoom_.bind(this, i),
      l
    ), !1;
  }
  /**
   * @private
   * @param {import("../Map.js").default} map Map.
   */
  handleWheelZoom_(e) {
    const t = e.getView();
    t.getAnimating() && t.cancelAnimations();
    let i = -_e(
      this.totalDelta_,
      -this.maxDelta_ * this.deltaPerZoom_,
      this.maxDelta_ * this.deltaPerZoom_
    ) / this.deltaPerZoom_;
    (t.getConstrainResolution() || this.constrainResolution_) && (i = i ? i > 0 ? 1 : -1 : 0), Kl(t, i, this.lastAnchor_, this.duration_), this.mode_ = void 0, this.totalDelta_ = 0, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_ = void 0;
  }
  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */
  setMouseAnchor(e) {
    this.useAnchor_ = e, e || (this.lastAnchor_ = null);
  }
}
const Jr = Yp;
class Xp extends on {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    t.stopDown || (t.stopDown = Hn), super(t), this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.threshold_ = e.threshold !== void 0 ? e.threshold : 0.3, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    let t = 0;
    const i = this.targetPointers[0], s = this.targetPointers[1], r = Math.atan2(
      s.clientY - i.clientY,
      s.clientX - i.clientX
    );
    if (this.lastAngle_ !== void 0) {
      const l = r - this.lastAngle_;
      this.rotationDelta_ += l, !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = !0), t = l;
    }
    this.lastAngle_ = r;
    const o = e.map, a = o.getView();
    a.getConstraints().rotation !== ml && (this.anchor_ = o.getCoordinateFromPixelInternal(
      o.getEventPixel(Zl(this.targetPointers))
    ), this.rotating_ && (o.render(), a.adjustRotationInternal(t, this.anchor_)));
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    return this.targetPointers.length < 2 ? (e.map.getView().endInteraction(this.duration_), !1) : !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (this.targetPointers.length >= 2) {
      const t = e.map;
      return this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.handlingDownUpSequence || t.getView().beginInteraction(), !0;
    }
    return !1;
  }
}
const Bp = Xp;
class Wp extends on {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    t.stopDown || (t.stopDown = Hn), super(t), this.anchor_ = null, this.duration_ = e.duration !== void 0 ? e.duration : 400, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    let t = 1;
    const i = this.targetPointers[0], s = this.targetPointers[1], r = i.clientX - s.clientX, o = i.clientY - s.clientY, a = Math.sqrt(r * r + o * o);
    this.lastDistance_ !== void 0 && (t = this.lastDistance_ / a), this.lastDistance_ = a;
    const l = e.map, h = l.getView();
    t != 1 && (this.lastScaleDelta_ = t), this.anchor_ = l.getCoordinateFromPixelInternal(
      l.getEventPixel(Zl(this.targetPointers))
    ), l.render(), h.adjustResolutionInternal(t, this.anchor_);
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    if (this.targetPointers.length < 2) {
      const i = e.map.getView(), s = this.lastScaleDelta_ > 1 ? 1 : -1;
      return i.endInteraction(this.duration_, s), !1;
    }
    return !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (this.targetPointers.length >= 2) {
      const t = e.map;
      return this.anchor_ = null, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1, this.handlingDownUpSequence || t.getView().beginInteraction(), !0;
    }
    return !1;
  }
}
const Kp = Wp;
function Zp(n) {
  n = n || {};
  const e = new ze(), t = new jp(-5e-3, 0.05, 100);
  return (n.altShiftDragRotate !== void 0 ? n.altShiftDragRotate : !0) && e.push(new Ap()), (n.doubleClickZoom !== void 0 ? n.doubleClickZoom : !0) && e.push(
    new Cp({
      delta: n.zoomDelta,
      duration: n.zoomDuration
    })
  ), (n.dragPan !== void 0 ? n.dragPan : !0) && e.push(
    new Ss({
      onFocusOnly: n.onFocusOnly,
      kinetic: t
    })
  ), (n.pinchRotate !== void 0 ? n.pinchRotate : !0) && e.push(new Bp()), (n.pinchZoom !== void 0 ? n.pinchZoom : !0) && e.push(
    new Kp({
      duration: n.zoomDuration
    })
  ), (n.keyboard !== void 0 ? n.keyboard : !0) && (e.push(new zp()), e.push(
    new Up({
      delta: n.zoomDelta,
      duration: n.zoomDuration
    })
  )), (n.mouseWheelZoom !== void 0 ? n.mouseWheelZoom : !0) && e.push(
    new Jr({
      onFocusOnly: n.onFocusOnly,
      duration: n.zoomDuration
    })
  ), (n.shiftDragZoom !== void 0 ? n.shiftDragZoom : !0) && e.push(
    new kp({
      duration: n.zoomDuration
    })
  ), e;
}
function pd(n) {
  if (n instanceof tr) {
    n.setMapInternal(null);
    return;
  }
  n instanceof en && n.getLayers().forEach(pd);
}
function yd(n, e) {
  if (n instanceof tr) {
    n.setMapInternal(e);
    return;
  }
  if (n instanceof en) {
    const t = n.getLayers().getArray();
    for (let i = 0, s = t.length; i < s; ++i)
      yd(t[i], e);
  }
}
let Hp = class extends vt {
  /**
   * @param {MapOptions} [options] Map options.
   */
  constructor(e) {
    super(), e = e || {}, this.on, this.once, this.un;
    const t = qp(e);
    this.renderComplete_, this.loaded_ = !0, this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this), this.maxTilesLoading_ = e.maxTilesLoading !== void 0 ? e.maxTilesLoading : 16, this.pixelRatio_ = e.pixelRatio !== void 0 ? e.pixelRatio : Uu, this.postRenderTimeoutHandle_, this.animationDelayKey_, this.animationDelay_ = this.animationDelay_.bind(this), this.coordinateToPixelTransform_ = at(), this.pixelToCoordinateTransform_ = at(), this.frameIndex_ = 0, this.frameState_ = null, this.previousExtent_ = null, this.viewPropertyListenerKey_ = null, this.viewChangeListenerKey_ = null, this.layerGroupPropertyListenerKeys_ = null, this.viewport_ = document.createElement("div"), this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : ""), this.viewport_.style.position = "relative", this.viewport_.style.overflow = "hidden", this.viewport_.style.width = "100%", this.viewport_.style.height = "100%", this.overlayContainer_ = document.createElement("div"), this.overlayContainer_.style.position = "absolute", this.overlayContainer_.style.zIndex = "0", this.overlayContainer_.style.width = "100%", this.overlayContainer_.style.height = "100%", this.overlayContainer_.style.pointerEvents = "none", this.overlayContainer_.className = "ol-overlaycontainer", this.viewport_.appendChild(this.overlayContainer_), this.overlayContainerStopEvent_ = document.createElement("div"), this.overlayContainerStopEvent_.style.position = "absolute", this.overlayContainerStopEvent_.style.zIndex = "0", this.overlayContainerStopEvent_.style.width = "100%", this.overlayContainerStopEvent_.style.height = "100%", this.overlayContainerStopEvent_.style.pointerEvents = "none", this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent", this.viewport_.appendChild(this.overlayContainerStopEvent_), this.mapBrowserEventHandler_ = null, this.moveTolerance_ = e.moveTolerance, this.keyboardEventTarget_ = t.keyboardEventTarget, this.targetChangeHandlerKeys_ = null, this.targetElement_ = null, this.resizeObserver_ = new ResizeObserver(() => this.updateSize()), this.controls = t.controls || ud(), this.interactions = t.interactions || Zp({
      onFocusOnly: !0
    }), this.overlays_ = t.overlays, this.overlayIdIndex_ = {}, this.renderer_ = null, this.postRenderFunctions_ = [], this.tileQueue_ = new dp(
      this.getTilePriority.bind(this),
      this.handleTileChange_.bind(this)
    ), this.addChangeListener(
      Ce.LAYERGROUP,
      this.handleLayerGroupChanged_
    ), this.addChangeListener(Ce.VIEW, this.handleViewChanged_), this.addChangeListener(Ce.SIZE, this.handleSizeChanged_), this.addChangeListener(Ce.TARGET, this.handleTargetChanged_), this.setProperties(t.values);
    const i = this;
    e.view && !(e.view instanceof pt) && e.view.then(function(s) {
      i.setView(new pt(s));
    }), this.controls.addEventListener(
      Fe.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
       */
      (s) => {
        s.element.setMap(this);
      }
    ), this.controls.addEventListener(
      Fe.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
       */
      (s) => {
        s.element.setMap(null);
      }
    ), this.interactions.addEventListener(
      Fe.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (s) => {
        s.element.setMap(this);
      }
    ), this.interactions.addEventListener(
      Fe.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (s) => {
        s.element.setMap(null);
      }
    ), this.overlays_.addEventListener(
      Fe.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (s) => {
        this.addOverlayInternal_(s.element);
      }
    ), this.overlays_.addEventListener(
      Fe.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (s) => {
        const r = s.element.getId();
        r !== void 0 && delete this.overlayIdIndex_[r.toString()], s.element.setMap(null);
      }
    ), this.controls.forEach(
      /**
       * @param {import("./control/Control.js").default} control Control.
       */
      (s) => {
        s.setMap(this);
      }
    ), this.interactions.forEach(
      /**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       */
      (s) => {
        s.setMap(this);
      }
    ), this.overlays_.forEach(this.addOverlayInternal_.bind(this));
  }
  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */
  addControl(e) {
    this.getControls().push(e);
  }
  /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteractions()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */
  addInteraction(e) {
    this.getInteractions().push(e);
  }
  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */
  addLayer(e) {
    this.getLayerGroup().getLayers().push(e);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
   * @private
   */
  handleLayerAdd_(e) {
    yd(e.layer, this);
  }
  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */
  addOverlay(e) {
    this.getOverlays().push(e);
  }
  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */
  addOverlayInternal_(e) {
    const t = e.getId();
    t !== void 0 && (this.overlayIdIndex_[t.toString()] = e), e.setMap(this);
  }
  /**
   *
   * Clean up.
   */
  disposeInternal() {
    this.controls.clear(), this.interactions.clear(), this.overlays_.clear(), this.resizeObserver_.disconnect(), this.setTarget(null), super.disposeInternal();
  }
  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `options`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature~Feature feature} or
   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template T
   * @api
   */
  forEachFeatureAtPixel(e, t, i) {
    if (!this.frameState_ || !this.renderer_)
      return;
    const s = this.getCoordinateFromPixelInternal(e);
    i = i !== void 0 ? i : {};
    const r = i.hitTolerance !== void 0 ? i.hitTolerance : 0, o = i.layerFilter !== void 0 ? i.layerFilter : kn, a = i.checkWrapped !== !1;
    return this.renderer_.forEachFeatureAtCoordinate(
      s,
      this.frameState_,
      r,
      a,
      t,
      null,
      o,
      null
    );
  }
  /**
   * Get all features that intersect a pixel on the viewport.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */
  getFeaturesAtPixel(e, t) {
    const i = [];
    return this.forEachFeatureAtPixel(
      e,
      function(s) {
        i.push(s);
      },
      t
    ), i;
  }
  /**
   * Get all layers from all layer groups.
   * @return {Array<import("./layer/Layer.js").default>} Layers.
   * @api
   */
  getAllLayers() {
    const e = [];
    function t(i) {
      i.forEach(function(s) {
        s instanceof en ? t(s.getLayers()) : e.push(s);
      });
    }
    return t(this.getLayers()), e;
  }
  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through the `layerFilter` option.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */
  hasFeatureAtPixel(e, t) {
    if (!this.frameState_ || !this.renderer_)
      return !1;
    const i = this.getCoordinateFromPixelInternal(e);
    t = t !== void 0 ? t : {};
    const s = t.layerFilter !== void 0 ? t.layerFilter : kn, r = t.hitTolerance !== void 0 ? t.hitTolerance : 0, o = t.checkWrapped !== !1;
    return this.renderer_.hasFeatureAtCoordinate(
      i,
      this.frameState_,
      r,
      o,
      s,
      null
    );
  }
  /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  getEventCoordinate(e) {
    return this.getCoordinateFromPixel(this.getEventPixel(e));
  }
  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */
  getEventCoordinateInternal(e) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(e));
  }
  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent|{clientX: number, clientY: number}} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */
  getEventPixel(e) {
    const i = this.viewport_.getBoundingClientRect(), s = this.getSize(), r = i.width / s[0], o = i.height / s[1], a = (
      //FIXME Are we really calling this with a TouchEvent anywhere?
      "changedTouches" in e ? (
        /** @type {TouchEvent} */
        e.changedTouches[0]
      ) : (
        /** @type {MouseEvent} */
        e
      )
    );
    return [
      (a.clientX - i.left) / r,
      (a.clientY - i.top) / o
    ];
  }
  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */
  getTarget() {
    return (
      /** @type {HTMLElement|string|undefined} */
      this.get(Ce.TARGET)
    );
  }
  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */
  getTargetElement() {
    return this.targetElement_;
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */
  getCoordinateFromPixel(e) {
    return Vn(
      this.getCoordinateFromPixelInternal(e),
      this.getView().getProjection()
    );
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */
  getCoordinateFromPixelInternal(e) {
    const t = this.frameState_;
    return t ? Se(t.pixelToCoordinateTransform, e.slice()) : null;
  }
  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */
  getControls() {
    return this.controls;
  }
  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */
  getOverlays() {
    return this.overlays_;
  }
  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default|null} Overlay.
   * @api
   */
  getOverlayById(e) {
    const t = this.overlayIdIndex_[e.toString()];
    return t !== void 0 ? t : null;
  }
  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */
  getInteractions() {
    return this.interactions;
  }
  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */
  getLayerGroup() {
    return (
      /** @type {LayerGroup} */
      this.get(Ce.LAYERGROUP)
    );
  }
  /**
   * Clear any existing layers and add layers to the map.
   * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
   * @api
   */
  setLayers(e) {
    const t = this.getLayerGroup();
    if (e instanceof ze) {
      t.setLayers(e);
      return;
    }
    const i = t.getLayers();
    i.clear(), i.extend(e);
  }
  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */
  getLayers() {
    return this.getLayerGroup().getLayers();
  }
  /**
   * @return {boolean} Layers have sources that are still loading.
   */
  getLoadingOrNotReady() {
    const e = this.getLayerGroup().getLayerStatesArray();
    for (let t = 0, i = e.length; t < i; ++t) {
      const s = e[t];
      if (!s.visible)
        continue;
      const r = s.layer.getRenderer();
      if (r && !r.ready)
        return !0;
      const o = s.layer.getSource();
      if (o && o.loading)
        return !0;
    }
    return !1;
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */
  getPixelFromCoordinate(e) {
    const t = pe(
      e,
      this.getView().getProjection()
    );
    return this.getPixelFromCoordinateInternal(t);
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */
  getPixelFromCoordinateInternal(e) {
    const t = this.frameState_;
    return t ? Se(
      t.coordinateToPixelTransform,
      e.slice(0, 2)
    ) : null;
  }
  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default|null} Renderer
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  getSize() {
    return (
      /** @type {import("./size.js").Size|undefined} */
      this.get(Ce.SIZE)
    );
  }
  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */
  getView() {
    return (
      /** @type {View} */
      this.get(Ce.VIEW)
    );
  }
  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */
  getViewport() {
    return this.viewport_;
  }
  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */
  getOverlayContainer() {
    return this.overlayContainer_;
  }
  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */
  getOverlayContainerStopEvent() {
    return this.overlayContainerStopEvent_;
  }
  /**
   * @return {!Document} The document where the map is displayed.
   */
  getOwnerDocument() {
    const e = this.getTargetElement();
    return e ? e.ownerDocument : document;
  }
  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  getTilePriority(e, t, i, s) {
    return fp(
      this.frameState_,
      e,
      t,
      i,
      s
    );
  }
  /**
   * @param {UIEvent} browserEvent Browser event.
   * @param {string} [type] Type.
   */
  handleBrowserEvent(e, t) {
    t = t || e.type;
    const i = new Wt(t, this, e);
    this.handleMapBrowserEvent(i);
  }
  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */
  handleMapBrowserEvent(e) {
    if (!this.frameState_)
      return;
    const t = (
      /** @type {PointerEvent} */
      e.originalEvent
    ), i = t.type;
    if (i === Lt.POINTERDOWN || i === G.WHEEL || i === G.KEYDOWN) {
      const s = this.getOwnerDocument(), r = this.viewport_.getRootNode ? this.viewport_.getRootNode() : s, o = (
        /** @type {Node} */
        t.target
      );
      if (
        // Abort if the target is a child of the container for elements whose events are not meant
        // to be handled by map interactions.
        this.overlayContainerStopEvent_.contains(o) || // Abort if the event target is a child of the container that is no longer in the page.
        // It's possible for the target to no longer be in the page if it has been removed in an
        // event listener, this might happen in a Control that recreates it's content based on
        // user interaction either manually or via a render in something like https://reactjs.org/
        !(r === s ? s.documentElement : r).contains(o)
      )
        return;
    }
    if (e.frameState = this.frameState_, this.dispatchEvent(e) !== !1) {
      const s = this.getInteractions().getArray().slice();
      for (let r = s.length - 1; r >= 0; r--) {
        const o = s[r];
        if (o.getMap() !== this || !o.getActive() || !this.getTargetElement())
          continue;
        if (!o.handleEvent(e) || e.propagationStopped)
          break;
      }
    }
  }
  /**
   * @protected
   */
  handlePostRender() {
    const e = this.frameState_, t = this.tileQueue_;
    if (!t.isEmpty()) {
      let s = this.maxTilesLoading_, r = s;
      if (e) {
        const o = e.viewHints;
        if (o[de.ANIMATING] || o[de.INTERACTING]) {
          const a = Date.now() - e.time > 8;
          s = a ? 0 : 8, r = a ? 0 : 2;
        }
      }
      t.getTilesLoading() < s && (t.reprioritize(), t.loadMoreTiles(s, r));
    }
    e && this.renderer_ && !e.animate && (this.renderComplete_ === !0 ? (this.hasListener(st.RENDERCOMPLETE) && this.renderer_.dispatchRenderEvent(
      st.RENDERCOMPLETE,
      e
    ), this.loaded_ === !1 && (this.loaded_ = !0, this.dispatchEvent(
      new wn(Pt.LOADEND, this, e)
    ))) : this.loaded_ === !0 && (this.loaded_ = !1, this.dispatchEvent(
      new wn(Pt.LOADSTART, this, e)
    )));
    const i = this.postRenderFunctions_;
    for (let s = 0, r = i.length; s < r; ++s)
      i[s](this, e);
    i.length = 0;
  }
  /**
   * @private
   */
  handleSizeChanged_() {
    this.getView() && !this.getView().getAnimating() && this.getView().resolveConstraints(0), this.render();
  }
  /**
   * @private
   */
  handleTargetChanged_() {
    if (this.mapBrowserEventHandler_) {
      for (let i = 0, s = this.targetChangeHandlerKeys_.length; i < s; ++i)
        he(this.targetChangeHandlerKeys_[i]);
      this.targetChangeHandlerKeys_ = null, this.viewport_.removeEventListener(
        G.CONTEXTMENU,
        this.boundHandleBrowserEvent_
      ), this.viewport_.removeEventListener(
        G.WHEEL,
        this.boundHandleBrowserEvent_
      ), this.mapBrowserEventHandler_.dispose(), this.mapBrowserEventHandler_ = null, Yr(this.viewport_);
    }
    if (this.targetElement_) {
      this.resizeObserver_.unobserve(this.targetElement_);
      const i = this.targetElement_.getRootNode();
      i instanceof ShadowRoot && this.resizeObserver_.unobserve(i.host), this.setSize(void 0);
    }
    const e = this.getTarget(), t = typeof e == "string" ? document.getElementById(e) : e;
    if (this.targetElement_ = t, !t)
      this.renderer_ && (clearTimeout(this.postRenderTimeoutHandle_), this.postRenderTimeoutHandle_ = void 0, this.postRenderFunctions_.length = 0, this.renderer_.dispose(), this.renderer_ = null), this.animationDelayKey_ && (cancelAnimationFrame(this.animationDelayKey_), this.animationDelayKey_ = void 0);
    else {
      t.appendChild(this.viewport_), this.renderer_ || (this.renderer_ = new sp(this)), this.mapBrowserEventHandler_ = new lp(
        this,
        this.moveTolerance_
      );
      for (const r in J)
        this.mapBrowserEventHandler_.addEventListener(
          J[r],
          this.handleMapBrowserEvent.bind(this)
        );
      this.viewport_.addEventListener(
        G.CONTEXTMENU,
        this.boundHandleBrowserEvent_,
        !1
      ), this.viewport_.addEventListener(
        G.WHEEL,
        this.boundHandleBrowserEvent_,
        ju ? { passive: !1 } : !1
      );
      const i = this.keyboardEventTarget_ ? this.keyboardEventTarget_ : t;
      this.targetChangeHandlerKeys_ = [
        Z(
          i,
          G.KEYDOWN,
          this.handleBrowserEvent,
          this
        ),
        Z(
          i,
          G.KEYPRESS,
          this.handleBrowserEvent,
          this
        )
      ];
      const s = t.getRootNode();
      s instanceof ShadowRoot && this.resizeObserver_.observe(s.host), this.resizeObserver_.observe(t);
    }
    this.updateSize();
  }
  /**
   * @private
   */
  handleTileChange_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewPropertyChanged_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewChanged_() {
    this.viewPropertyListenerKey_ && (he(this.viewPropertyListenerKey_), this.viewPropertyListenerKey_ = null), this.viewChangeListenerKey_ && (he(this.viewChangeListenerKey_), this.viewChangeListenerKey_ = null);
    const e = this.getView();
    e && (this.updateViewportSize_(this.getSize()), this.viewPropertyListenerKey_ = Z(
      e,
      Ji.PROPERTYCHANGE,
      this.handleViewPropertyChanged_,
      this
    ), this.viewChangeListenerKey_ = Z(
      e,
      G.CHANGE,
      this.handleViewPropertyChanged_,
      this
    ), e.resolveConstraints(0)), this.render();
  }
  /**
   * @private
   */
  handleLayerGroupChanged_() {
    this.layerGroupPropertyListenerKeys_ && (this.layerGroupPropertyListenerKeys_.forEach(he), this.layerGroupPropertyListenerKeys_ = null);
    const e = this.getLayerGroup();
    e && (this.handleLayerAdd_(new mi("addlayer", e)), this.layerGroupPropertyListenerKeys_ = [
      Z(e, Ji.PROPERTYCHANGE, this.render, this),
      Z(e, G.CHANGE, this.render, this),
      Z(e, "addlayer", this.handleLayerAdd_, this),
      Z(e, "removelayer", this.handleLayerRemove_, this)
    ]), this.render();
  }
  /**
   * @return {boolean} Is rendered.
   */
  isRendered() {
    return !!this.frameState_;
  }
  /**
   * @private
   */
  animationDelay_() {
    this.animationDelayKey_ = void 0, this.renderFrame_(Date.now());
  }
  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */
  renderSync() {
    this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_), this.animationDelay_();
  }
  /**
   * Redraws all text after new fonts have loaded
   */
  redrawText() {
    const e = this.getLayerGroup().getLayerStatesArray();
    for (let t = 0, i = e.length; t < i; ++t) {
      const s = e[t].layer;
      s.hasRenderer() && s.getRenderer().handleFontsChanged();
    }
  }
  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */
  render() {
    this.renderer_ && this.animationDelayKey_ === void 0 && (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_));
  }
  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */
  removeControl(e) {
    return this.getControls().remove(e);
  }
  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */
  removeInteraction(e) {
    return this.getInteractions().remove(e);
  }
  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */
  removeLayer(e) {
    return this.getLayerGroup().getLayers().remove(e);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
   * @private
   */
  handleLayerRemove_(e) {
    pd(e.layer);
  }
  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */
  removeOverlay(e) {
    return this.getOverlays().remove(e);
  }
  /**
   * @param {number} time Time.
   * @private
   */
  renderFrame_(e) {
    const t = this.getSize(), i = this.getView(), s = this.frameState_;
    let r = null;
    if (t !== void 0 && Jh(t) && i && i.isDef()) {
      const o = i.getHints(
        this.frameState_ ? this.frameState_.viewHints : void 0
      ), a = i.getState();
      if (r = {
        animate: !1,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutter: null,
        extent: Ms(
          a.center,
          a.resolution,
          a.rotation,
          t
        ),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size: t,
        tileQueue: this.tileQueue_,
        time: e,
        usedTiles: {},
        viewState: a,
        viewHints: o,
        wantedTiles: {},
        mapId: j(this),
        renderTargets: {}
      }, a.nextCenter && a.nextResolution) {
        const l = isNaN(a.nextRotation) ? a.rotation : a.nextRotation;
        r.nextExtent = Ms(
          a.nextCenter,
          a.nextResolution,
          l,
          t
        );
      }
    }
    this.frameState_ = r, this.renderer_.renderFrame(r), r && (r.animate && this.render(), Array.prototype.push.apply(
      this.postRenderFunctions_,
      r.postRenderFunctions
    ), s && (!this.previousExtent_ || !Jn(this.previousExtent_) && !Mi(r.extent, this.previousExtent_)) && (this.dispatchEvent(
      new wn(Pt.MOVESTART, this, s)
    ), this.previousExtent_ = qs(this.previousExtent_)), this.previousExtent_ && !r.viewHints[de.ANIMATING] && !r.viewHints[de.INTERACTING] && !Mi(r.extent, this.previousExtent_) && (this.dispatchEvent(
      new wn(Pt.MOVEEND, this, r)
    ), cu(r.extent, this.previousExtent_))), this.dispatchEvent(new wn(Pt.POSTRENDER, this, r)), this.renderComplete_ = this.hasListener(Pt.LOADSTART) || this.hasListener(Pt.LOADEND) || this.hasListener(st.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : void 0, this.postRenderTimeoutHandle_ || (this.postRenderTimeoutHandle_ = setTimeout(() => {
      this.postRenderTimeoutHandle_ = void 0, this.handlePostRender();
    }, 0));
  }
  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */
  setLayerGroup(e) {
    const t = this.getLayerGroup();
    t && this.handleLayerRemove_(new mi("removelayer", t)), this.set(Ce.LAYERGROUP, e);
  }
  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  setSize(e) {
    this.set(Ce.SIZE, e);
  }
  /**
   * Set the target element to render this map into.
   * @param {HTMLElement|string} [target] The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */
  setTarget(e) {
    this.set(Ce.TARGET, e);
  }
  /**
   * Set the view for this map.
   * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
   * It is also possible to pass a promise that resolves to options for constructing a view.  This
   * alternative allows view properties to be resolved by sources or other components that load
   * view-related metadata.
   * @observable
   * @api
   */
  setView(e) {
    if (!e || e instanceof pt) {
      this.set(Ce.VIEW, e);
      return;
    }
    this.set(Ce.VIEW, new pt());
    const t = this;
    e.then(function(i) {
      t.setView(new pt(i));
    });
  }
  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */
  updateSize() {
    const e = this.getTargetElement();
    let t;
    if (e) {
      const s = getComputedStyle(e), r = e.offsetWidth - parseFloat(s.borderLeftWidth) - parseFloat(s.paddingLeft) - parseFloat(s.paddingRight) - parseFloat(s.borderRightWidth), o = e.offsetHeight - parseFloat(s.borderTopWidth) - parseFloat(s.paddingTop) - parseFloat(s.paddingBottom) - parseFloat(s.borderBottomWidth);
      !isNaN(r) && !isNaN(o) && (t = [r, o], !Jh(t) && (e.offsetWidth || e.offsetHeight || e.getClientRects().length) && yu(
        "No map visible because the map container's width or height are 0."
      ));
    }
    const i = this.getSize();
    t && (!i || !ri(t, i)) && (this.setSize(t), this.updateViewportSize_(t));
  }
  /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @param {import("./size.js").Size|undefined} size The size.
   * @private
   */
  updateViewportSize_(e) {
    const t = this.getView();
    t && t.setViewportSize(e);
  }
};
function qp(n) {
  let e = null;
  n.keyboardEventTarget !== void 0 && (e = typeof n.keyboardEventTarget == "string" ? document.getElementById(n.keyboardEventTarget) : n.keyboardEventTarget);
  const t = {}, i = n.layers && typeof /** @type {?} */
  n.layers.getLayers == "function" ? (
    /** @type {LayerGroup} */
    n.layers
  ) : new en({
    layers: (
      /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
      n.layers
    )
  });
  t[Ce.LAYERGROUP] = i, t[Ce.TARGET] = n.target, t[Ce.VIEW] = n.view instanceof pt ? n.view : new pt();
  let s;
  n.controls !== void 0 && (Array.isArray(n.controls) ? s = new ze(n.controls.slice()) : (Q(
    typeof /** @type {?} */
    n.controls.getArray == "function",
    "Expected `controls` to be an array or an `ol/Collection.js`"
  ), s = n.controls));
  let r;
  n.interactions !== void 0 && (Array.isArray(n.interactions) ? r = new ze(n.interactions.slice()) : (Q(
    typeof /** @type {?} */
    n.interactions.getArray == "function",
    "Expected `interactions` to be an array or an `ol/Collection.js`"
  ), r = n.interactions));
  let o;
  return n.overlays !== void 0 ? Array.isArray(n.overlays) ? o = new ze(n.overlays.slice()) : (Q(
    typeof /** @type {?} */
    n.overlays.getArray == "function",
    "Expected `overlays` to be an array or an `ol/Collection.js`"
  ), o = n.overlays) : o = new ze(), {
    controls: s,
    interactions: r,
    keyboardEventTarget: e,
    overlays: o,
    values: t
  };
}
const xd = Hp, Jp = ':root,:host{--ol-background-color: white;--ol-accent-background-color: #F5F5F5;--ol-subtle-background-color: rgba(128, 128, 128, .25);--ol-partial-background-color: rgba(255, 255, 255, .75);--ol-foreground-color: #333333;--ol-subtle-foreground-color: #666666;--ol-brand-color: #00AAFF}.ol-box{box-sizing:border-box;border-radius:2px;border:1.5px solid var(--ol-background-color);background-color:var(--ol-partial-background-color)}.ol-mouse-position{top:8px;right:8px;position:absolute}.ol-scale-line{background:var(--ol-partial-background-color);border-radius:4px;bottom:8px;left:8px;padding:2px;position:absolute}.ol-scale-line-inner{border:1px solid var(--ol-subtle-foreground-color);border-top:none;color:var(--ol-foreground-color);font-size:10px;text-align:center;margin:1px;will-change:contents,width;transition:all .25s}.ol-scale-bar{position:absolute;bottom:8px;left:8px}.ol-scale-bar-inner{display:flex}.ol-scale-step-marker{width:1px;height:15px;background-color:var(--ol-foreground-color);float:right;z-index:10}.ol-scale-step-text{position:absolute;bottom:-5px;font-size:10px;z-index:11;color:var(--ol-foreground-color);text-shadow:-1.5px 0 var(--ol-partial-background-color),0 1.5px var(--ol-partial-background-color),1.5px 0 var(--ol-partial-background-color),0 -1.5px var(--ol-partial-background-color)}.ol-scale-text{position:absolute;font-size:12px;text-align:center;bottom:25px;color:var(--ol-foreground-color);text-shadow:-1.5px 0 var(--ol-partial-background-color),0 1.5px var(--ol-partial-background-color),1.5px 0 var(--ol-partial-background-color),0 -1.5px var(--ol-partial-background-color)}.ol-scale-singlebar{position:relative;height:10px;z-index:9;box-sizing:border-box;border:1px solid var(--ol-foreground-color)}.ol-scale-singlebar-even{background-color:var(--ol-subtle-foreground-color)}.ol-scale-singlebar-odd{background-color:var(--ol-background-color)}.ol-unsupported{display:none}.ol-viewport,.ol-unselectable{-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent}.ol-viewport canvas{all:unset;overflow:hidden}.ol-viewport{touch-action:pan-x pan-y}.ol-selectable{-webkit-touch-callout:default;-webkit-user-select:text;-moz-user-select:text;user-select:text}.ol-grabbing{cursor:-webkit-grabbing;cursor:-moz-grabbing;cursor:grabbing}.ol-grab{cursor:move;cursor:-webkit-grab;cursor:-moz-grab;cursor:grab}.ol-control{position:absolute;background-color:var(--ol-subtle-background-color);border-radius:4px}.ol-zoom{top:.5em;left:.5em}.ol-rotate{top:.5em;right:.5em;transition:opacity .25s linear,visibility 0s linear}.ol-rotate.ol-hidden{opacity:0;visibility:hidden;transition:opacity .25s linear,visibility 0s linear .25s}.ol-zoom-extent{top:4.643em;left:.5em}.ol-full-screen{right:.5em;top:.5em}.ol-control button{display:block;margin:1px;padding:0;color:var(--ol-subtle-foreground-color);font-weight:700;text-decoration:none;font-size:inherit;text-align:center;height:1.375em;width:1.375em;line-height:.4em;background-color:var(--ol-background-color);border:none;border-radius:2px}.ol-control button::-moz-focus-inner{border:none;padding:0}.ol-zoom-extent button{line-height:1.4em}.ol-compass{display:block;font-weight:400;will-change:transform}.ol-touch .ol-control button{font-size:1.5em}.ol-touch .ol-zoom-extent{top:5.5em}.ol-control button:hover,.ol-control button:focus{text-decoration:none;outline:1px solid var(--ol-subtle-foreground-color);color:var(--ol-foreground-color)}.ol-zoom .ol-zoom-in{border-radius:2px 2px 0 0}.ol-zoom .ol-zoom-out{border-radius:0 0 2px 2px}.ol-attribution{text-align:right;bottom:.5em;right:.5em;max-width:calc(100% - 1.3em);display:flex;flex-flow:row-reverse;align-items:center}.ol-attribution a{color:var(--ol-subtle-foreground-color);text-decoration:none}.ol-attribution ul{margin:0;padding:1px .5em;color:var(--ol-foreground-color);text-shadow:0 0 2px var(--ol-background-color);font-size:12px}.ol-attribution li{display:inline;list-style:none}.ol-attribution li:not(:last-child):after{content:" "}.ol-attribution img{max-height:2em;max-width:inherit;vertical-align:middle}.ol-attribution button{flex-shrink:0}.ol-attribution.ol-collapsed ul{display:none}.ol-attribution:not(.ol-collapsed){background:var(--ol-partial-background-color)}.ol-attribution.ol-uncollapsible{bottom:0;right:0;border-radius:4px 0 0}.ol-attribution.ol-uncollapsible img{margin-top:-.2em;max-height:1.6em}.ol-attribution.ol-uncollapsible button{display:none}.ol-zoomslider{top:4.5em;left:.5em;height:200px}.ol-zoomslider button{position:relative;height:10px}.ol-touch .ol-zoomslider{top:5.5em}.ol-overviewmap{left:.5em;bottom:.5em}.ol-overviewmap.ol-uncollapsible{bottom:0;left:0;border-radius:0 4px 0 0}.ol-overviewmap .ol-overviewmap-map,.ol-overviewmap button{display:block}.ol-overviewmap .ol-overviewmap-map{border:1px solid var(--ol-subtle-foreground-color);height:150px;width:150px}.ol-overviewmap:not(.ol-collapsed) button{bottom:0;left:0;position:absolute}.ol-overviewmap.ol-collapsed .ol-overviewmap-map,.ol-overviewmap.ol-uncollapsible button{display:none}.ol-overviewmap:not(.ol-collapsed){background:var(--ol-subtle-background-color)}.ol-overviewmap-box{border:1.5px dotted var(--ol-subtle-foreground-color)}.ol-overviewmap .ol-overviewmap-box:hover{cursor:move}';
class ql extends vt {
  /**
   * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
   *     You may pass a Geometry object directly, or an object literal containing
   *     properties. If you pass an object literal, you may include a Geometry
   *     associated with a `geometry` key.
   */
  constructor(e) {
    if (super(), this.on, this.once, this.un, this.id_ = void 0, this.geometryName_ = "geometry", this.style_ = null, this.styleFunction_ = void 0, this.geometryChangeKey_ = null, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), e)
      if (typeof /** @type {?} */
      e.getSimplifiedGeometry == "function") {
        const t = (
          /** @type {Geometry} */
          e
        );
        this.setGeometry(t);
      } else {
        const t = e;
        this.setProperties(t);
      }
  }
  /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature<Geometry>} The clone.
   * @api
   */
  clone() {
    const e = (
      /** @type {Feature<Geometry>} */
      new ql(this.hasProperties() ? this.getProperties() : null)
    );
    e.setGeometryName(this.getGeometryName());
    const t = this.getGeometry();
    t && e.setGeometry(
      /** @type {Geometry} */
      t.clone()
    );
    const i = this.getStyle();
    return i && e.setStyle(i), e;
  }
  /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {Geometry|undefined} The default geometry for the feature.
   * @api
   * @observable
   */
  getGeometry() {
    return (
      /** @type {Geometry|undefined} */
      this.get(this.geometryName_)
    );
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */
  getGeometryName() {
    return this.geometryName_;
  }
  /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @private
   */
  handleGeometryChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleGeometryChanged_() {
    this.geometryChangeKey_ && (he(this.geometryChangeKey_), this.geometryChangeKey_ = null);
    const e = this.getGeometry();
    e && (this.geometryChangeKey_ = Z(
      e,
      G.CHANGE,
      this.handleGeometryChange_,
      this
    )), this.changed();
  }
  /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {Geometry|undefined} geometry The new geometry.
   * @api
   * @observable
   */
  setGeometry(e) {
    this.set(this.geometryName_, e);
  }
  /**
   * Set the style for the feature to override the layer style.  This can be a
   * single style object, an array of styles, or a function that takes a
   * resolution and returns an array of styles. To unset the feature style, call
   * `setStyle()` without arguments or a falsey value.
   * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setStyle(e) {
    this.style_ = e, this.styleFunction_ = e ? Qp(e) : void 0, this.changed();
  }
  /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setId(e) {
    this.id_ = e, this.changed();
  }
  /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */
  setGeometryName(e) {
    this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_), this.geometryName_ = e, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), this.handleGeometryChanged_();
  }
}
function Qp(n) {
  if (typeof n == "function")
    return n;
  let e;
  return Array.isArray(n) ? e = n : (Q(
    typeof /** @type {?} */
    n.getZIndex == "function",
    "Expected an `ol/style/Style` or an array of `ol/style/Style.js`"
  ), e = [
    /** @type {import("./style/Style.js").default} */
    n
  ]), function() {
    return e;
  };
}
const yt = ql;
class Po extends ki {
  /**
   * @param {!import("../coordinate.js").Coordinate} center Center.
   *     For internal use, flat coordinates in combination with `layout` and no
   *     `radius` are also accepted.
   * @param {number} [radius] Radius in units of the projection.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t, i) {
    super(), i !== void 0 && t === void 0 ? this.setFlatCoordinates(i, e) : (t = t || 0, this.setCenterAndRadius(e, t, i));
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Circle} Clone.
   * @api
   */
  clone() {
    const e = new Po(
      this.flatCoordinates.slice(),
      void 0,
      this.layout
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, i, s) {
    const r = this.flatCoordinates, o = e - r[0], a = t - r[1], l = o * o + a * a;
    if (l < s) {
      if (l === 0)
        for (let h = 0; h < this.stride; ++h)
          i[h] = r[h];
      else {
        const h = this.getRadius() / Math.sqrt(l);
        i[0] = r[0] + h * o, i[1] = r[1] + h * a;
        for (let c = 2; c < this.stride; ++c)
          i[c] = r[c];
      }
      return i.length = this.stride, l;
    }
    return s;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    const i = this.flatCoordinates, s = e - i[0], r = t - i[1];
    return s * s + r * r <= this.getRadiusSquared_();
  }
  /**
   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @return {import("../coordinate.js").Coordinate} Center.
   * @api
   */
  getCenter() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    const t = this.flatCoordinates, i = t[this.stride] - t[0];
    return ii(
      t[0] - i,
      t[1] - i,
      t[0] + i,
      t[1] + i,
      e
    );
  }
  /**
   * Return the radius of the circle.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return Math.sqrt(this.getRadiusSquared_());
  }
  /**
   * @private
   * @return {number} Radius squared.
   */
  getRadiusSquared_() {
    const e = this.flatCoordinates[this.stride] - this.flatCoordinates[0], t = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
    return e * e + t * t;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Circle";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    const t = this.getExtent();
    if (ye(e, t)) {
      const i = this.getCenter();
      return e[0] <= i[0] && e[2] >= i[0] || e[1] <= i[1] && e[3] >= i[1] ? !0 : al(e, this.intersectsCoordinate.bind(this));
    }
    return !1;
  }
  /**
   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} center Center.
   * @api
   */
  setCenter(e) {
    const t = this.stride, i = this.flatCoordinates[t] - this.flatCoordinates[0], s = e.slice();
    s[t] = s[0] + i;
    for (let r = 1; r < t; ++r)
      s[t + r] = e[r];
    this.setFlatCoordinates(this.layout, s), this.changed();
  }
  /**
   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
   * number) of the circle.
   * @param {!import("../coordinate.js").Coordinate} center Center.
   * @param {number} radius Radius.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCenterAndRadius(e, t, i) {
    this.setLayout(i, e, 0), this.flatCoordinates || (this.flatCoordinates = []);
    const s = this.flatCoordinates;
    let r = Su(s, 0, e, this.stride);
    s[r++] = s[0] + t;
    for (let o = 1, a = this.stride; o < a; ++o)
      s[r++] = s[o];
    s.length = r, this.changed();
  }
  getCoordinates() {
    return null;
  }
  setCoordinates(e, t) {
  }
  /**
   * Set the radius of the circle. The radius is in the units of the projection.
   * @param {number} radius Radius.
   * @api
   */
  setRadius(e) {
    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + e, this.changed();
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, t) {
    const i = this.getCenter(), s = this.getStride();
    this.setCenter(
      xl(i, 0, i.length, s, e, t, i)
    ), this.changed();
  }
}
Po.prototype.transform;
const ey = Po;
class Qr extends wu {
  /**
   * @param {Array<Geometry>} geometries Geometries.
   */
  constructor(e) {
    super(), this.geometries_ = e, this.changeEventsKeys_ = [], this.listenGeometriesChange_();
  }
  /**
   * @private
   */
  unlistenGeometriesChange_() {
    this.changeEventsKeys_.forEach(he), this.changeEventsKeys_.length = 0;
  }
  /**
   * @private
   */
  listenGeometriesChange_() {
    const e = this.geometries_;
    for (let t = 0, i = e.length; t < i; ++t)
      this.changeEventsKeys_.push(
        Z(e[t], G.CHANGE, this.changed, this)
      );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!GeometryCollection} Clone.
   * @api
   */
  clone() {
    const e = new Qr(
      aa(this.geometries_)
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, i, s) {
    if (s < tn(this.getExtent(), e, t))
      return s;
    const r = this.geometries_;
    for (let o = 0, a = r.length; o < a; ++o)
      s = r[o].closestPointXY(
        e,
        t,
        i,
        s
      );
    return s;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    const i = this.geometries_;
    for (let s = 0, r = i.length; s < r; ++s)
      if (i[s].containsXY(e, t))
        return !0;
    return !1;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    qs(e);
    const t = this.geometries_;
    for (let i = 0, s = t.length; i < s; ++i)
      uu(e, t[i].getExtent());
    return e;
  }
  /**
   * Return the geometries that make up this geometry collection.
   * @return {Array<Geometry>} Geometries.
   * @api
   */
  getGeometries() {
    return aa(this.geometries_);
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArray() {
    return this.geometries_;
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArrayRecursive() {
    let e = [];
    const t = this.geometries_;
    for (let i = 0, s = t.length; i < s; ++i)
      t[i].getType() === this.getType() ? e = e.concat(
        /** @type {GeometryCollection} */
        t[i].getGeometriesArrayRecursive()
      ) : e.push(t[i]);
    return e;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {GeometryCollection} Simplified GeometryCollection.
   */
  getSimplifiedGeometry(e) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), e < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && e < this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const t = [], i = this.geometries_;
    let s = !1;
    for (let r = 0, o = i.length; r < o; ++r) {
      const a = i[r], l = a.getSimplifiedGeometry(e);
      t.push(l), l !== a && (s = !0);
    }
    return s ? new Qr(
      t
    ) : (this.simplifiedGeometryMaxMinSquaredTolerance = e, this);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "GeometryCollection";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    const t = this.geometries_;
    for (let i = 0, s = t.length; i < s; ++i)
      if (t[i].intersectsExtent(e))
        return !0;
    return !1;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.geometries_.length === 0;
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, t) {
    const i = this.geometries_;
    for (let s = 0, r = i.length; s < r; ++s)
      i[s].rotate(e, t);
    this.changed();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(e, t, i) {
    i || (i = Ot(this.getExtent()));
    const s = this.geometries_;
    for (let r = 0, o = s.length; r < o; ++r)
      s[r].scale(e, t, i);
    this.changed();
  }
  /**
   * Set the geometries that make up this geometry collection.
   * @param {Array<Geometry>} geometries Geometries.
   * @api
   */
  setGeometries(e) {
    this.setGeometriesArray(aa(e));
  }
  /**
   * @param {Array<Geometry>} geometries Geometries.
   */
  setGeometriesArray(e) {
    this.unlistenGeometriesChange_(), this.geometries_ = e, this.listenGeometriesChange_(), this.changed();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */
  applyTransform(e) {
    const t = this.geometries_;
    for (let i = 0, s = t.length; i < s; ++i)
      t[i].applyTransform(e);
    this.changed();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(e, t) {
    const i = this.geometries_;
    for (let s = 0, r = i.length; s < r; ++s)
      i[s].translate(e, t);
    this.changed();
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.unlistenGeometriesChange_(), super.disposeInternal();
  }
}
function aa(n) {
  return n.map((e) => e.clone());
}
const ei = Qr;
function eo(n, e, t, i, s, r, o) {
  let a, l;
  const h = (t - e) / i;
  if (h === 1)
    a = e;
  else if (h === 2)
    a = e, l = s;
  else if (h !== 0) {
    let c = n[e], u = n[e + 1], d = 0;
    const f = [0];
    for (let m = e + i; m < t; m += i) {
      const p = n[m], y = n[m + 1];
      d += Math.sqrt((p - c) * (p - c) + (y - u) * (y - u)), f.push(d), c = p, u = y;
    }
    const g = s * d, _ = ug(f, g);
    _ < 0 ? (l = (g - f[-_ - 2]) / (f[-_ - 1] - f[-_ - 2]), a = e + (-_ - 2) * i) : a = e + _ * i;
  }
  o = o > 1 ? o : 2, r = r || new Array(o);
  for (let c = 0; c < o; ++c)
    r[c] = a === void 0 ? NaN : l === void 0 ? n[a + c] : He(n[a + c], n[a + i + c], l);
  return r;
}
function Ua(n, e, t, i, s, r) {
  if (t == e)
    return null;
  let o;
  if (s < n[e + i - 1])
    return r ? (o = n.slice(e, e + i), o[i - 1] = s, o) : null;
  if (n[t - 1] < s)
    return r ? (o = n.slice(t - i, t), o[i - 1] = s, o) : null;
  if (s == n[e + i - 1])
    return n.slice(e, e + i);
  let a = e / i, l = t / i;
  for (; a < l; ) {
    const d = a + l >> 1;
    s < n[(d + 1) * i - 1] ? l = d : a = d + 1;
  }
  const h = n[a * i - 1];
  if (s == h)
    return n.slice((a - 1) * i, (a - 1) * i + i);
  const c = n[(a + 1) * i - 1], u = (s - h) / (c - h);
  o = [];
  for (let d = 0; d < i - 1; ++d)
    o.push(
      He(
        n[(a - 1) * i + d],
        n[a * i + d],
        u
      )
    );
  return o.push(s), o;
}
function ty(n, e, t, i, s, r, o) {
  if (o)
    return Ua(
      n,
      e,
      t[t.length - 1],
      i,
      s,
      r
    );
  let a;
  if (s < n[i - 1])
    return r ? (a = n.slice(0, i), a[i - 1] = s, a) : null;
  if (n[n.length - 1] < s)
    return r ? (a = n.slice(n.length - i), a[i - 1] = s, a) : null;
  for (let l = 0, h = t.length; l < h; ++l) {
    const c = t[l];
    if (e != c) {
      if (s < n[e + i - 1])
        return null;
      if (s <= n[c - 1])
        return Ua(
          n,
          e,
          c,
          i,
          s,
          !1
        );
      e = c;
    }
  }
  return null;
}
function Ed(n, e, t, i) {
  let s = n[e], r = n[e + 1], o = 0;
  for (let a = e + i; a < t; a += i) {
    const l = n[a], h = n[a + 1];
    o += Math.sqrt((l - s) * (l - s) + (h - r) * (h - r)), s = l, r = h;
  }
  return o;
}
class to extends ki {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), this.flatMidpoint_ = null, this.flatMidpointRevision_ = -1, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, t !== void 0 && !Array.isArray(e[0]) ? this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      e,
      t
    );
  }
  /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @api
   */
  appendCoordinate(e) {
    se(this.flatCoordinates, e), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LineString} Clone.
   * @api
   */
  clone() {
    const e = new to(
      this.flatCoordinates.slice(),
      this.layout
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, i, s) {
    return s < tn(this.getExtent(), e, t) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      El(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), wl(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !1,
      e,
      t,
      i,
      s
    ));
  }
  /**
   * Iterate over each segment, calling the provided callback.
   * If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   *
   * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
   * @return {T|boolean} Value.
   * @template T,S
   * @api
   */
  forEachSegment(e) {
    return Lu(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e
    );
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(e, t) {
    return this.layout != "XYM" && this.layout != "XYZM" ? null : (t = t !== void 0 ? t : !1, Ua(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t
    ));
  }
  /**
   * Return the coordinates of the linestring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return Ei(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinate at the provided fraction along the linestring.
   * The `fraction` is a number between 0 and 1, where 0 is the start of the
   * linestring and 1 is the end.
   * @param {number} fraction Fraction.
   * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
   *     be modified. If not provided, a new coordinate will be returned.
   * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
   * @api
   */
  getCoordinateAt(e, t) {
    return eo(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t,
      this.stride
    );
  }
  /**
   * Return the length of the linestring on projected plane.
   * @return {number} Length (on projected plane).
   * @api
   */
  getLength() {
    return Ed(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(
      0.5,
      this.flatMidpoint_ ?? void 0
    ), this.flatMidpointRevision_ = this.getRevision()), /** @type {Array<number>} */
    this.flatMidpoint_;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} Simplified LineString.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [];
    return t.length = wo(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t,
      0
    ), new to(t, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "LineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return So(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the linestring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Co(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
}
const ht = to;
class io extends ki {
  /**
   * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
   *     Coordinates or LineString geometries. (For internal use, flat coordinates in
   *     combination with `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Flat coordinate ends for internal use.
   */
  constructor(e, t, i) {
    if (super(), this.ends_ = [], this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, Array.isArray(e[0]))
      this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
        e,
        t
      );
    else if (t !== void 0 && i)
      this.setFlatCoordinates(
        t,
        /** @type {Array<number>} */
        e
      ), this.ends_ = i;
    else {
      const s = (
        /** @type {Array<LineString>} */
        e
      ), r = [], o = [];
      for (let l = 0, h = s.length; l < h; ++l) {
        const c = s[l];
        se(r, c.getFlatCoordinates()), o.push(r.length);
      }
      const a = s.length === 0 ? this.getLayout() : s[0].getLayout();
      this.setFlatCoordinates(a, r), this.ends_ = o;
    }
  }
  /**
   * Append the passed linestring to the multilinestring.
   * @param {LineString} lineString LineString.
   * @api
   */
  appendLineString(e) {
    se(this.flatCoordinates, e.getFlatCoordinates().slice()), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiLineString} Clone.
   * @api
   */
  clone() {
    const e = new io(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, i, s) {
    return s < tn(this.getExtent(), e, t) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      Cl(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), Sl(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !1,
      e,
      t,
      i,
      s
    ));
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * `interpolate` controls interpolation between consecutive LineStrings
   * within the MultiLineString. If `interpolate` is `true` the coordinates
   * will be linearly interpolated between the last coordinate of one LineString
   * and the first coordinate of the next LineString.  If `interpolate` is
   * `false` then the function will return `null` for Ms falling between
   * LineStrings.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @param {boolean} [interpolate] Interpolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(e, t, i) {
    return this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0 ? null : (t = t !== void 0 ? t : !1, i = i !== void 0 ? i : !1, ty(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      e,
      t,
      i
    ));
  }
  /**
   * Return the coordinates of the multilinestring.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates() {
    return Ds(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * Return the linestring at the specified index.
   * @param {number} index Index.
   * @return {LineString} LineString.
   * @api
   */
  getLineString(e) {
    return e < 0 || this.ends_.length <= e ? null : new ht(
      this.flatCoordinates.slice(
        e === 0 ? 0 : this.ends_[e - 1],
        this.ends_[e]
      ),
      this.layout
    );
  }
  /**
   * Return the linestrings of this multilinestring.
   * @return {Array<LineString>} LineStrings.
   * @api
   */
  getLineStrings() {
    const e = this.flatCoordinates, t = this.ends_, i = this.layout, s = [];
    let r = 0;
    for (let o = 0, a = t.length; o < a; ++o) {
      const l = t[o], h = new ht(
        e.slice(r, l),
        i
      );
      s.push(h), r = l;
    }
    return s;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    const e = [], t = this.flatCoordinates;
    let i = 0;
    const s = this.ends_, r = this.stride;
    for (let o = 0, a = s.length; o < a; ++o) {
      const l = s[o], h = eo(
        t,
        i,
        l,
        r,
        0.5
      );
      se(e, h), i = l;
    }
    return e;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiLineString} Simplified MultiLineString.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [], i = [];
    return t.length = Tu(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      e,
      t,
      0,
      i
    ), new io(t, "XY", i);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiLineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return x_(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the multilinestring.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const i = er(
      this.flatCoordinates,
      0,
      e,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = i.length === 0 ? 0 : i[i.length - 1], this.changed();
  }
}
const an = io;
class Jl extends ki {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), t && !Array.isArray(e[0]) ? this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      e,
      t
    );
  }
  /**
   * Append the passed point to this multipoint.
   * @param {Point} point Point.
   * @api
   */
  appendPoint(e) {
    se(this.flatCoordinates, e.getFlatCoordinates()), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPoint} Clone.
   * @api
   */
  clone() {
    const e = new Jl(
      this.flatCoordinates.slice(),
      this.layout
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, i, s) {
    if (s < tn(this.getExtent(), e, t))
      return s;
    const r = this.flatCoordinates, o = this.stride;
    for (let a = 0, l = r.length; a < l; a += o) {
      const h = Ht(
        e,
        t,
        r[a],
        r[a + 1]
      );
      if (h < s) {
        s = h;
        for (let c = 0; c < o; ++c)
          i[c] = r[a + c];
        i.length = o;
      }
    }
    return s;
  }
  /**
   * Return the coordinates of the multipoint.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return Ei(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the point at the specified index.
   * @param {number} index Index.
   * @return {Point} Point.
   * @api
   */
  getPoint(e) {
    const t = this.flatCoordinates.length / this.stride;
    return e < 0 || t <= e ? null : new lt(
      this.flatCoordinates.slice(
        e * this.stride,
        (e + 1) * this.stride
      ),
      this.layout
    );
  }
  /**
   * Return the points of this multipoint.
   * @return {Array<Point>} Points.
   * @api
   */
  getPoints() {
    const e = this.flatCoordinates, t = this.layout, i = this.stride, s = [];
    for (let r = 0, o = e.length; r < o; r += i) {
      const a = new lt(e.slice(r, r + i), t);
      s.push(a);
    }
    return s;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiPoint";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    const t = this.flatCoordinates, i = this.stride;
    for (let s = 0, r = t.length; s < r; s += i) {
      const o = t[s], a = t[s + 1];
      if (rl(e, o, a))
        return !0;
    }
    return !1;
  }
  /**
   * Set the coordinates of the multipoint.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Co(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
}
const ts = Jl;
function Cd(n, e, t, i) {
  const s = [];
  let r = Je();
  for (let o = 0, a = t.length; o < a; ++o) {
    const l = t[o];
    r = ol(
      n,
      e,
      l[0],
      i
    ), s.push((r[0] + r[2]) / 2, (r[1] + r[3]) / 2), e = l[l.length - 1];
  }
  return s;
}
class no extends ki {
  /**
   * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
   */
  constructor(e, t, i) {
    if (super(), this.endss_ = [], this.flatInteriorPointsRevision_ = -1, this.flatInteriorPoints_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, !i && !Array.isArray(e[0])) {
      const s = (
        /** @type {Array<Polygon>} */
        e
      ), r = [], o = [];
      for (let a = 0, l = s.length; a < l; ++a) {
        const h = s[a], c = r.length, u = h.getEnds();
        for (let d = 0, f = u.length; d < f; ++d)
          u[d] += c;
        se(r, h.getFlatCoordinates()), o.push(u);
      }
      t = s.length === 0 ? this.getLayout() : s[0].getLayout(), e = r, i = o;
    }
    t !== void 0 && i ? (this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ), this.endss_ = i) : this.setCoordinates(
      /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
      e,
      t
    );
  }
  /**
   * Append the passed polygon to this multipolygon.
   * @param {Polygon} polygon Polygon.
   * @api
   */
  appendPolygon(e) {
    let t;
    if (!this.flatCoordinates)
      this.flatCoordinates = e.getFlatCoordinates().slice(), t = e.getEnds().slice(), this.endss_.push();
    else {
      const i = this.flatCoordinates.length;
      se(this.flatCoordinates, e.getFlatCoordinates()), t = e.getEnds().slice();
      for (let s = 0, r = t.length; s < r; ++s)
        t[s] += i;
    }
    this.endss_.push(t), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPolygon} Clone.
   * @api
   */
  clone() {
    const e = this.endss_.length, t = new Array(e);
    for (let s = 0; s < e; ++s)
      t[s] = this.endss_[s].slice();
    const i = new no(
      this.flatCoordinates.slice(),
      this.layout,
      t
    );
    return i.applyProperties(this), i;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, i, s) {
    return s < tn(this.getExtent(), e, t) ? s : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      d_(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), f_(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      this.maxDelta_,
      !0,
      e,
      t,
      i,
      s
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    return y_(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      e,
      t
    );
  }
  /**
   * Return the area of the multipolygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return m_(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for multi-polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
   * @api
   */
  getCoordinates(e) {
    let t;
    return e !== void 0 ? (t = this.getOrientedFlatCoordinates().slice(), Ma(
      t,
      0,
      this.endss_,
      this.stride,
      e
    )) : t = this.flatCoordinates, Fa(
      t,
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * @return {Array<Array<number>>} Endss.
   */
  getEndss() {
    return this.endss_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (this.flatInteriorPointsRevision_ != this.getRevision()) {
      const e = Cd(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride
      );
      this.flatInteriorPoints_ = Pu(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        e
      ), this.flatInteriorPointsRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.flatInteriorPoints_
    );
  }
  /**
   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
   * @return {MultiPoint} Interior points as XYM coordinates, where M is
   * the length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoints() {
    return new ts(this.getFlatInteriorPoints().slice(), "XYM");
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const e = this.flatCoordinates;
      Fu(e, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = e : (this.orientedFlatCoordinates_ = e.slice(), this.orientedFlatCoordinates_.length = Ma(
        this.orientedFlatCoordinates_,
        0,
        this.endss_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.orientedFlatCoordinates_
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiPolygon} Simplified MultiPolygon.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [], i = [];
    return t.length = __(
      this.flatCoordinates,
      0,
      this.endss_,
      this.stride,
      Math.sqrt(e),
      t,
      0,
      i
    ), new no(t, "XY", i);
  }
  /**
   * Return the polygon at the specified index.
   * @param {number} index Index.
   * @return {Polygon} Polygon.
   * @api
   */
  getPolygon(e) {
    if (e < 0 || this.endss_.length <= e)
      return null;
    let t;
    if (e === 0)
      t = 0;
    else {
      const r = this.endss_[e - 1];
      t = r[r.length - 1];
    }
    const i = this.endss_[e].slice(), s = i[i.length - 1];
    if (t !== 0)
      for (let r = 0, o = i.length; r < o; ++r)
        i[r] -= t;
    return new Ne(
      this.flatCoordinates.slice(t, s),
      this.layout,
      i
    );
  }
  /**
   * Return the polygons of this multipolygon.
   * @return {Array<Polygon>} Polygons.
   * @api
   */
  getPolygons() {
    const e = this.layout, t = this.flatCoordinates, i = this.endss_, s = [];
    let r = 0;
    for (let o = 0, a = i.length; o < a; ++o) {
      const l = i[o].slice(), h = l[l.length - 1];
      if (r !== 0)
        for (let u = 0, d = l.length; u < d; ++u)
          l[u] -= r;
      const c = new Ne(
        t.slice(r, h),
        e,
        l
      );
      s.push(c), r = h;
    }
    return s;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiPolygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return E_(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the multipolygon.
   * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 3), this.flatCoordinates || (this.flatCoordinates = []);
    const i = vu(
      this.flatCoordinates,
      0,
      e,
      this.stride,
      this.endss_
    );
    if (i.length === 0)
      this.flatCoordinates.length = 0;
    else {
      const s = i[i.length - 1];
      this.flatCoordinates.length = s.length === 0 ? 0 : s[s.length - 1];
    }
    this.changed();
  }
}
const is = no, gc = at();
class Wn {
  /**
   * @param {Type} type Geometry type.
   * @param {Array<number>} flatCoordinates Flat coordinates. These always need
   *     to be right-handed for polygons.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Object<string, *>} properties Properties.
   * @param {number|string|undefined} id Feature id.
   */
  constructor(e, t, i, s, r, o) {
    this.styleFunction, this.extent_, this.id_ = o, this.type_ = e, this.flatCoordinates_ = t, this.flatInteriorPoints_ = null, this.flatMidpoints_ = null, this.ends_ = i || null, this.properties_ = r, this.squaredTolerance_, this.stride_ = s, this.simplifiedGeometry_;
  }
  /**
   * Get a feature property by its key.
   * @param {string} key Key
   * @return {*} Value for the requested key.
   * @api
   */
  get(e) {
    return this.properties_[e];
  }
  /**
   * Get the extent of this feature's geometry.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_ || (this.extent_ = this.type_ === "Point" ? Cs(this.flatCoordinates_) : ol(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2
    )), this.extent_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoint() {
    if (!this.flatInteriorPoints_) {
      const e = Ot(this.getExtent());
      this.flatInteriorPoints_ = Il(
        this.flatCoordinates_,
        0,
        this.ends_,
        2,
        e,
        0
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (!this.flatInteriorPoints_) {
      const e = Mu(this.flatCoordinates_, this.ends_), t = Cd(this.flatCoordinates_, 0, e, 2);
      this.flatInteriorPoints_ = Pu(
        this.flatCoordinates_,
        0,
        e,
        2,
        t
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpoints_ || (this.flatMidpoints_ = eo(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2,
      0.5
    )), this.flatMidpoints_;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = [];
      const e = this.flatCoordinates_;
      let t = 0;
      const i = (
        /** @type {Array<number>} */
        this.ends_
      );
      for (let s = 0, r = i.length; s < r; ++s) {
        const o = i[s], a = eo(e, t, o, 2, 0.5);
        se(this.flatMidpoints_, a), t = o;
      }
    }
    return this.flatMidpoints_;
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is set when reading data from a remote source.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getOrientedFlatCoordinates() {
    return this.flatCoordinates_;
  }
  /**
   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
   * determining the geometry type in style function (see {@link #getType}).
   * @return {RenderFeature} Feature.
   * @api
   */
  getGeometry() {
    return this;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {RenderFeature} Simplified geometry.
   */
  getSimplifiedGeometry(e) {
    return this;
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {RenderFeature} Simplified geometry.
   */
  simplifyTransformed(e, t) {
    return this;
  }
  /**
   * Get the feature properties.
   * @return {Object<string, *>} Feature properties.
   * @api
   */
  getProperties() {
    return this.properties_;
  }
  /**
   * Get an object of all property names and values.  This has the same behavior as getProperties,
   * but is here to conform with the {@link module:ol/Feature~Feature} interface.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.properties_;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride_;
  }
  /**
   * @return {import('../style/Style.js').StyleFunction|undefined} Style
   */
  getStyleFunction() {
    return this.styleFunction;
  }
  /**
   * Get the type of this feature's geometry.
   * @return {Type} Geometry type.
   * @api
   */
  getType() {
    return this.type_;
  }
  /**
   * Transform geometry coordinates from tile pixel space to projected.
   *
   * @param {import("../proj.js").ProjectionLike} projection The data projection
   */
  transform(e) {
    e = ce(e);
    const t = e.getExtent(), i = e.getWorldExtent();
    if (t && i) {
      const s = Te(i) / Te(t);
      wt(
        gc,
        i[0],
        i[3],
        s,
        -s,
        0,
        0,
        0
      ), bi(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2,
        gc,
        this.flatCoordinates_
      );
    }
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   */
  applyTransform(e) {
    e(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
  }
  /**
   * @return {RenderFeature} A cloned render feature.
   */
  clone() {
    var e;
    return new Wn(
      this.type_,
      this.flatCoordinates_.slice(),
      (e = this.ends_) == null ? void 0 : e.slice(),
      this.stride_,
      Object.assign({}, this.properties_),
      this.id_
    );
  }
  /**
   * @return {Array<number>|null} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * Add transform and resolution based geometry simplification to this instance.
   * @return {RenderFeature} This render feature.
   */
  enableSimplifyTransformed() {
    return this.simplifyTransformed = ou((e, t) => {
      if (e === this.squaredTolerance_)
        return this.simplifiedGeometry_;
      this.simplifiedGeometry_ = this.clone(), t && this.simplifiedGeometry_.applyTransform(t);
      const i = this.simplifiedGeometry_.getFlatCoordinates();
      let s;
      switch (this.type_) {
        case "LineString":
          i.length = wo(
            i,
            0,
            this.simplifiedGeometry_.flatCoordinates_.length,
            this.simplifiedGeometry_.stride_,
            e,
            i,
            0
          ), s = [i.length];
          break;
        case "MultiLineString":
          s = [], i.length = Tu(
            i,
            0,
            this.simplifiedGeometry_.ends_,
            this.simplifiedGeometry_.stride_,
            e,
            i,
            0,
            s
          );
          break;
        case "Polygon":
          s = [], i.length = vl(
            i,
            0,
            this.simplifiedGeometry_.ends_,
            this.simplifiedGeometry_.stride_,
            Math.sqrt(e),
            i,
            0,
            s
          );
          break;
      }
      return s && (this.simplifiedGeometry_ = new Wn(
        this.type_,
        i,
        s,
        2,
        this.properties_,
        this.id_
      )), this.squaredTolerance_ = e, this.simplifiedGeometry_;
    }), this;
  }
}
Wn.prototype.getFlatCoordinates = Wn.prototype.getOrientedFlatCoordinates;
const mt = Wn;
class Ql {
  constructor() {
    this.dataProjection = void 0, this.defaultFeatureProjection = void 0, this.featureClass = yt, this.supportedMediaTypes = null;
  }
  /**
   * Adds the data projection to the read options.
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Options.
   * @return {ReadOptions|undefined} Options.
   * @protected
   */
  getReadOptions(e, t) {
    if (t) {
      let i = t.dataProjection ? ce(t.dataProjection) : this.readProjection(e);
      t.extent && i && i.getUnits() === "tile-pixels" && (i = ce(i), i.setWorldExtent(t.extent)), t = {
        dataProjection: i,
        featureProjection: t.featureProjection
      };
    }
    return this.adaptOptions(t);
  }
  /**
   * Sets the `dataProjection` on the options, if no `dataProjection`
   * is set.
   * @param {WriteOptions|ReadOptions|undefined} options
   *     Options.
   * @protected
   * @return {WriteOptions|ReadOptions|undefined}
   *     Updated options.
   */
  adaptOptions(e) {
    return Object.assign(
      {
        dataProjection: this.dataProjection,
        featureProjection: this.defaultFeatureProjection,
        featureClass: this.featureClass
      },
      e
    );
  }
  /**
   * @abstract
   * @return {Type} The format type.
   */
  getType() {
    return B();
  }
  /**
   * Read a single feature from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../Feature.js").FeatureLike|Array<import("../render/Feature.js").default>} Feature.
   */
  readFeature(e, t) {
    return B();
  }
  /**
   * Read all features from a source.
   *
   * @abstract
   * @param {Document|Element|ArrayBuffer|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {Array<import('../Feature.js').FeatureLike|FeatureClassToFeature<T>>} Features.
   */
  readFeatures(e, t) {
    return B();
  }
  /**
   * Read a single geometry from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometry(e, t) {
    return B();
  }
  /**
   * Read the projection from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   */
  readProjection(e) {
    return B();
  }
  /**
   * Encode a feature in this format.
   *
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeFeature(e, t) {
    return B();
  }
  /**
   * Encode an array of features in this format.
   *
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeFeatures(e, t) {
    return B();
  }
  /**
   * Write a single geometry in this format.
   *
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeGeometry(e, t) {
    return B();
  }
}
function ln(n, e, t) {
  const i = t ? ce(t.featureProjection) : null, s = t ? ce(t.dataProjection) : null;
  let r = n;
  if (i && s && !Zt(i, s)) {
    e && (r = /** @type {T} */
    n.clone());
    const o = e ? i : s, a = e ? s : i;
    o.getUnits() === "tile-pixels" ? r.transform(o, a) : r.applyTransform(Os(o, a));
  }
  if (e && t && /** @type {WriteOptions} */
  t.decimals !== void 0) {
    const o = Math.pow(
      10,
      /** @type {WriteOptions} */
      t.decimals
    ), a = function(l) {
      for (let h = 0, c = l.length; h < c; ++h)
        l[h] = Math.round(l[h] * o) / o;
      return l;
    };
    r === n && (r = /** @type {T} */
    n.clone()), r.applyTransform(a);
  }
  return r;
}
const iy = {
  Point: lt,
  LineString: ht,
  Polygon: Ne,
  MultiPoint: ts,
  MultiLineString: an,
  MultiPolygon: is
};
function ny(n, e, t) {
  return Array.isArray(e[0]) ? (Fu(n, 0, e, t) || (n = n.slice(), Ma(n, 0, e, t)), n) : (Ll(n, 0, e, t) || (n = n.slice(), Vr(n, 0, e, t)), n);
}
function wd(n, e) {
  var r;
  const t = n.geometry;
  if (!t)
    return [];
  if (Array.isArray(t))
    return t.map((o) => wd({ ...n, geometry: o })).flat();
  const i = t.type === "MultiPolygon" ? "Polygon" : t.type;
  if (i === "GeometryCollection" || i === "Circle")
    throw new Error("Unsupported geometry type: " + i);
  const s = t.layout.length;
  return ln(
    new mt(
      i,
      i === "Polygon" ? ny(t.flatCoordinates, t.ends, s) : t.flatCoordinates,
      (r = t.ends) == null ? void 0 : r.flat(),
      s,
      n.properties || {},
      n.id
    ).enableSimplifyTransformed(),
    !1,
    e
  );
}
function eh(n, e) {
  if (!n)
    return null;
  if (Array.isArray(n)) {
    const i = n.map(
      (s) => eh(s, e)
    );
    return new ei(i);
  }
  const t = iy[n.type];
  return ln(
    new t(n.flatCoordinates, n.layout, n.ends),
    !1,
    e
  );
}
class sy extends Ql {
  constructor() {
    super();
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return "json";
  }
  /**
   * Read a feature.  Only works for a single feature. Use `readFeatures` to
   * read a feature collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import('./Feature.js').FeatureClassToFeature<T>} Feature.
   * @api
   */
  readFeature(e, t) {
    return (
      /** @type {import('./Feature.js').FeatureClassToFeature<T>} */
      this.readFeatureFromObject(
        Cr(e),
        this.getReadOptions(e, t)
      )
    );
  }
  /**
   * Read all features.  Works with both a single feature and a feature
   * collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import('./Feature.js').FeatureClassToFeature<T>>} Features.
   * @api
   */
  readFeatures(e, t) {
    return (
      /** @type {Array<import('./Feature.js').FeatureClassToFeature<T>>} */
      this.readFeaturesFromObject(
        Cr(e),
        this.getReadOptions(e, t)
      )
    );
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default|import("../render/Feature.js").default|Array<import("../render/Feature.js").default>} Feature.
   */
  readFeatureFromObject(e, t) {
    return B();
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<import("../Feature.js").default|import("../render/Feature.js").default>} Features.
   */
  readFeaturesFromObject(e, t) {
    return B();
  }
  /**
   * Read a geometry.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   */
  readGeometry(e, t) {
    return this.readGeometryFromObject(
      Cr(e),
      this.getReadOptions(e, t)
    );
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromObject(e, t) {
    return B();
  }
  /**
   * Read the projection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  readProjection(e) {
    return this.readProjectionFromObject(Cr(e));
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(e) {
    return B();
  }
  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   * @api
   */
  writeFeature(e, t) {
    return JSON.stringify(this.writeFeatureObject(e, t));
  }
  /**
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeatureObject(e, t) {
    return B();
  }
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded features.
   * @api
   */
  writeFeatures(e, t) {
    return JSON.stringify(this.writeFeaturesObject(e, t));
  }
  /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeaturesObject(e, t) {
    return B();
  }
  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   * @api
   */
  writeGeometry(e, t) {
    return JSON.stringify(this.writeGeometryObject(e, t));
  }
  /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeGeometryObject(e, t) {
    return B();
  }
}
function Cr(n) {
  if (typeof n == "string") {
    const e = JSON.parse(n);
    return e || null;
  }
  return n !== null ? n : null;
}
const Sd = sy;
class ry extends Sd {
  /**
   * @param {Options<T>} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(), this.dataProjection = ce(
      e.dataProjection ? e.dataProjection : "EPSG:4326"
    ), e.featureProjection && (this.defaultFeatureProjection = ce(e.featureProjection)), e.featureClass && (this.featureClass = e.featureClass), this.geometryName_ = e.geometryName, this.extractGeometryName_ = e.extractGeometryName, this.supportedMediaTypes = [
      "application/geo+json",
      "application/vnd.geo+json"
    ];
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Feature|RenderFeature|Array<RenderFeature>}.default} Feature.
   */
  readFeatureFromObject(e, t) {
    let i = null;
    e.type === "Feature" ? i = /** @type {GeoJSONFeature} */
    e : i = {
      type: "Feature",
      geometry: (
        /** @type {GeoJSONGeometry} */
        e
      ),
      properties: null
    };
    const s = th(i.geometry);
    if (this.featureClass === mt)
      return wd(
        {
          geometry: s,
          id: i.id,
          properties: i.properties
        },
        t
      );
    const r = new yt();
    return this.geometryName_ ? r.setGeometryName(this.geometryName_) : this.extractGeometryName_ && i.geometry_name && r.setGeometryName(i.geometry_name), r.setGeometry(eh(s, t)), "id" in i && r.setId(i.id), i.properties && r.setProperties(i.properties, !0), r;
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature|RenderFeature>} Features.
   */
  readFeaturesFromObject(e, t) {
    const i = (
      /** @type {GeoJSONObject} */
      e
    );
    let s = null;
    if (i.type === "FeatureCollection") {
      const r = (
        /** @type {GeoJSONFeatureCollection} */
        e
      );
      s = [];
      const o = r.features;
      for (let a = 0, l = o.length; a < l; ++a) {
        const h = this.readFeatureFromObject(
          o[a],
          t
        );
        h && s.push(h);
      }
    } else
      s = [this.readFeatureFromObject(e, t)];
    return s.flat();
  }
  /**
   * @param {GeoJSONGeometry} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromObject(e, t) {
    return oy(e, t);
  }
  /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(e) {
    const t = e.crs;
    let i;
    if (t)
      if (t.type == "name")
        i = ce(t.properties.name);
      else if (t.type === "EPSG")
        i = ce("EPSG:" + t.properties.code);
      else
        throw new Error("Unknown SRS type");
    else
      i = this.dataProjection;
    return (
      /** @type {import("../proj/Projection.js").default} */
      i
    );
  }
  /**
   * Encode a feature as a GeoJSON Feature object.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeature} Object.
   * @api
   */
  writeFeatureObject(e, t) {
    t = this.adaptOptions(t);
    const i = {
      type: "Feature",
      geometry: null,
      properties: null
    }, s = e.getId();
    if (s !== void 0 && (i.id = s), !e.hasProperties())
      return i;
    const r = e.getProperties(), o = e.getGeometry();
    return o && (i.geometry = Va(o, t), delete r[e.getGeometryName()]), Fi(r) || (i.properties = r), i;
  }
  /**
   * Encode an array of features as a GeoJSON object.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeatureCollection} GeoJSON Object.
   * @api
   */
  writeFeaturesObject(e, t) {
    t = this.adaptOptions(t);
    const i = [];
    for (let s = 0, r = e.length; s < r; ++s)
      i.push(this.writeFeatureObject(e[s], t));
    return {
      type: "FeatureCollection",
      features: i
    };
  }
  /**
   * Encode a geometry as a GeoJSON object.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
   * @api
   */
  writeGeometryObject(e, t) {
    return Va(e, this.adaptOptions(t));
  }
}
function th(n, e) {
  if (!n)
    return null;
  let t;
  switch (n.type) {
    case "Point": {
      t = ly(
        /** @type {GeoJSONPoint} */
        n
      );
      break;
    }
    case "LineString": {
      t = hy(
        /** @type {GeoJSONLineString} */
        n
      );
      break;
    }
    case "Polygon": {
      t = fy(
        /** @type {GeoJSONPolygon} */
        n
      );
      break;
    }
    case "MultiPoint": {
      t = uy(
        /** @type {GeoJSONMultiPoint} */
        n
      );
      break;
    }
    case "MultiLineString": {
      t = cy(
        /** @type {GeoJSONMultiLineString} */
        n
      );
      break;
    }
    case "MultiPolygon": {
      t = dy(
        /** @type {GeoJSONMultiPolygon} */
        n
      );
      break;
    }
    case "GeometryCollection": {
      t = ay(
        /** @type {GeoJSONGeometryCollection} */
        n
      );
      break;
    }
    default:
      throw new Error("Unsupported GeoJSON type: " + n.type);
  }
  return t;
}
function oy(n, e) {
  const t = th(n);
  return eh(t, e);
}
function ay(n, e) {
  return n.geometries.map(
    /**
     * @param {GeoJSONGeometry} geometry Geometry.
     * @return {import("./Feature.js").GeometryObject} geometry Geometry.
     */
    function(i) {
      return th(i);
    }
  );
}
function ly(n) {
  const e = n.coordinates;
  return {
    type: "Point",
    flatCoordinates: e,
    layout: sn(e.length)
  };
}
function hy(n) {
  var i;
  const e = n.coordinates, t = e.flat();
  return {
    type: "LineString",
    flatCoordinates: t,
    ends: [t.length],
    layout: sn(((i = e[0]) == null ? void 0 : i.length) || 2)
  };
}
function cy(n) {
  var r, o;
  const e = n.coordinates, t = ((o = (r = e[0]) == null ? void 0 : r[0]) == null ? void 0 : o.length) || 2, i = [], s = er(i, 0, e, t);
  return {
    type: "MultiLineString",
    flatCoordinates: i,
    ends: s,
    layout: sn(t)
  };
}
function uy(n) {
  var t;
  const e = n.coordinates;
  return {
    type: "MultiPoint",
    flatCoordinates: e.flat(),
    layout: sn(((t = e[0]) == null ? void 0 : t.length) || 2)
  };
}
function dy(n) {
  var r, o;
  const e = n.coordinates, t = [], i = ((o = (r = e[0]) == null ? void 0 : r[0]) == null ? void 0 : o[0].length) || 2, s = vu(
    t,
    0,
    e,
    i
  );
  return {
    type: "MultiPolygon",
    flatCoordinates: t,
    ends: s,
    layout: sn(i)
  };
}
function fy(n) {
  var r, o;
  const e = n.coordinates, t = [], i = (o = (r = e[0]) == null ? void 0 : r[0]) == null ? void 0 : o.length, s = er(t, 0, e, i);
  return {
    type: "Polygon",
    flatCoordinates: t,
    ends: s,
    layout: sn(i)
  };
}
function Va(n, e) {
  n = ln(n, !0, e);
  const t = n.getType();
  let i;
  switch (t) {
    case "Point": {
      i = xy(
        /** @type {import("../geom/Point.js").default} */
        n
      );
      break;
    }
    case "LineString": {
      i = _y(
        /** @type {import("../geom/LineString.js").default} */
        n
      );
      break;
    }
    case "Polygon": {
      i = Ey(
        /** @type {import("../geom/Polygon.js").default} */
        n,
        e
      );
      break;
    }
    case "MultiPoint": {
      i = py(
        /** @type {import("../geom/MultiPoint.js").default} */
        n
      );
      break;
    }
    case "MultiLineString": {
      i = my(
        /** @type {import("../geom/MultiLineString.js").default} */
        n
      );
      break;
    }
    case "MultiPolygon": {
      i = yy(
        /** @type {import("../geom/MultiPolygon.js").default} */
        n,
        e
      );
      break;
    }
    case "GeometryCollection": {
      i = gy(
        /** @type {import("../geom/GeometryCollection.js").default} */
        n,
        e
      );
      break;
    }
    case "Circle": {
      i = {
        type: "GeometryCollection",
        geometries: []
      };
      break;
    }
    default:
      throw new Error("Unsupported geometry type: " + t);
  }
  return i;
}
function gy(n, e) {
  return e = Object.assign({}, e), delete e.featureProjection, {
    type: "GeometryCollection",
    geometries: n.getGeometriesArray().map(function(i) {
      return Va(i, e);
    })
  };
}
function _y(n, e) {
  return {
    type: "LineString",
    coordinates: n.getCoordinates()
  };
}
function my(n, e) {
  return {
    type: "MultiLineString",
    coordinates: n.getCoordinates()
  };
}
function py(n, e) {
  return {
    type: "MultiPoint",
    coordinates: n.getCoordinates()
  };
}
function yy(n, e) {
  let t;
  return e && (t = e.rightHanded), {
    type: "MultiPolygon",
    coordinates: n.getCoordinates(t)
  };
}
function xy(n, e) {
  return {
    type: "Point",
    coordinates: n.getCoordinates()
  };
}
function Ey(n, e) {
  let t;
  return e && (t = e.rightHanded), {
    type: "Polygon",
    coordinates: n.getCoordinates(t)
  };
}
const Lo = ry, _c = "http://www.w3.org/2001/XMLSchema-instance";
function rr(n, e) {
  return bo().createElementNS(n, e);
}
function ai(n, e) {
  return vd(n, e, []).join("");
}
function vd(n, e, t) {
  if (n.nodeType == Node.CDATA_SECTION_NODE || n.nodeType == Node.TEXT_NODE)
    e ? t.push(String(n.nodeValue).replace(/(\r\n|\r|\n)/g, "")) : t.push(n.nodeValue);
  else {
    let i;
    for (i = n.firstChild; i; i = i.nextSibling)
      vd(i, e, t);
  }
  return t;
}
function Si(n) {
  return "documentElement" in n;
}
function vi(n) {
  return new DOMParser().parseFromString(n, "application/xml");
}
function mc(n, e) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(t, i) {
      const s = n.call(
        e !== void 0 ? e : this,
        t,
        i
      );
      if (s !== void 0) {
        const r = (
          /** @type {Array<*>} */
          i[i.length - 1]
        );
        se(r, s);
      }
    }
  );
}
function yi(n, e) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(t, i) {
      const s = n.call(
        e !== void 0 ? e : this,
        t,
        i
      );
      s !== void 0 && /** @type {Array<*>} */
      i[i.length - 1].push(s);
    }
  );
}
function ih(n, e) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(t, i) {
      const s = n.call(
        e !== void 0 ? e : this,
        t,
        i
      );
      s !== void 0 && (i[i.length - 1] = s);
    }
  );
}
function F(n, e, t) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(i, s) {
      const r = n.call(
        t !== void 0 ? t : this,
        i,
        s
      );
      if (r !== void 0) {
        const o = (
          /** @type {!Object} */
          s[s.length - 1]
        ), a = e !== void 0 ? e : i.localName;
        o[a] = r;
      }
    }
  );
}
function U(n, e) {
  return function(t, i, s) {
    n.call(
      e !== void 0 ? e : this,
      t,
      i,
      s
    ), /** @type {NodeStackItem} */
    s[s.length - 1].node.appendChild(t);
  };
}
function li(n, e) {
  return (
    /**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [newNodeName] Node name.
     * @return {Node} Node.
     */
    function(t, i, s) {
      const o = /** @type {NodeStackItem} */ i[i.length - 1].node;
      let a = n;
      a === void 0 && (a = s);
      const l = e !== void 0 ? e : o.namespaceURI;
      return rr(
        l,
        /** @type {string} */
        a
      );
    }
  );
}
const ct = li();
function St(n, e) {
  const t = e.length, i = new Array(t);
  for (let s = 0; s < t; ++s)
    i[s] = n[e[s]];
  return i;
}
function z(n, e, t) {
  t = t !== void 0 ? t : {};
  let i, s;
  for (i = 0, s = n.length; i < s; ++i)
    t[n[i]] = e;
  return t;
}
function ns(n, e, t, i) {
  let s;
  for (s = e.firstElementChild; s; s = s.nextElementSibling) {
    const r = n[s.namespaceURI];
    if (r !== void 0) {
      const o = r[s.localName];
      o !== void 0 && o.call(i, s, t);
    }
  }
}
function ue(n, e, t, i, s) {
  return i.push(n), ns(e, t, i, s), /** @type {T} */
  i.pop();
}
function Cy(n, e, t, i, s, r) {
  const o = (s !== void 0 ? s : t).length;
  let a, l;
  for (let h = 0; h < o; ++h)
    a = t[h], a !== void 0 && (l = e.call(
      r !== void 0 ? r : this,
      a,
      i,
      s !== void 0 ? s[h] : void 0
    ), l !== void 0 && n[l.namespaceURI][l.localName].call(
      r,
      l,
      a,
      i
    ));
}
function we(n, e, t, i, s, r, o) {
  return s.push(n), Cy(e, t, i, s, r, o), /** @type {O|undefined} */
  s.pop();
}
let la;
function wy() {
  return la === void 0 && typeof XMLSerializer < "u" && (la = new XMLSerializer()), la;
}
let ha;
function bo() {
  return ha === void 0 && typeof document < "u" && (ha = document.implementation.createDocument("", "", null)), ha;
}
class Sy extends Ql {
  constructor() {
    super(), this.xmlSerializer_ = wy();
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return "xml";
  }
  /**
   * Read a single feature.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */
  readFeature(e, t) {
    if (!e)
      return null;
    if (typeof e == "string") {
      const i = vi(e);
      return this.readFeatureFromDocument(i, t);
    }
    return Si(e) ? this.readFeatureFromDocument(
      /** @type {Document} */
      e,
      t
    ) : this.readFeatureFromNode(
      /** @type {Element} */
      e,
      t
    );
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromDocument(e, t) {
    const i = this.readFeaturesFromDocument(e, t);
    return i.length > 0 ? i[0] : null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromNode(e, t) {
    return null;
  }
  /**
   * Read all features from a feature collection.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  readFeatures(e, t) {
    if (!e)
      return [];
    if (typeof e == "string") {
      const i = vi(e);
      return this.readFeaturesFromDocument(i, t);
    }
    return Si(e) ? this.readFeaturesFromDocument(
      /** @type {Document} */
      e,
      t
    ) : this.readFeaturesFromNode(
      /** @type {Element} */
      e,
      t
    );
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromDocument(e, t) {
    const i = [];
    for (let s = e.firstChild; s; s = s.nextSibling)
      s.nodeType == Node.ELEMENT_NODE && se(
        i,
        this.readFeaturesFromNode(
          /** @type {Element} */
          s,
          t
        )
      );
    return i;
  }
  /**
   * @abstract
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(e, t) {
    return B();
  }
  /**
   * Read a single geometry from a source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometry(e, t) {
    if (!e)
      return null;
    if (typeof e == "string") {
      const i = vi(e);
      return this.readGeometryFromDocument(i, t);
    }
    return Si(e) ? this.readGeometryFromDocument(
      /** @type {Document} */
      e,
      t
    ) : this.readGeometryFromNode(
      /** @type {Element} */
      e,
      t
    );
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromDocument(e, t) {
    return null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromNode(e, t) {
    return null;
  }
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  readProjection(e) {
    if (!e)
      return null;
    if (typeof e == "string") {
      const t = vi(e);
      return this.readProjectionFromDocument(t);
    }
    return Si(e) ? this.readProjectionFromDocument(
      /** @type {Document} */
      e
    ) : this.readProjectionFromNode(
      /** @type {Element} */
      e
    );
  }
  /**
   * @param {Document} doc Document.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromDocument(e) {
    return this.dataProjection;
  }
  /**
   * @param {Element} node Node.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromNode(e) {
    return this.dataProjection;
  }
  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   */
  writeFeature(e, t) {
    const i = this.writeFeatureNode(e, t);
    return this.xmlSerializer_.serializeToString(i);
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @protected
   * @return {Node} Node.
   */
  writeFeatureNode(e, t) {
    return null;
  }
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Result.
   * @api
   */
  writeFeatures(e, t) {
    const i = this.writeFeaturesNode(e, t);
    return this.xmlSerializer_.serializeToString(i);
  }
  /**
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */
  writeFeaturesNode(e, t) {
    return null;
  }
  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   */
  writeGeometry(e, t) {
    const i = this.writeGeometryNode(e, t);
    return this.xmlSerializer_.serializeToString(i);
  }
  /**
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */
  writeGeometryNode(e, t) {
    return null;
  }
}
const vy = Sy;
function Ni(n) {
  const e = ai(n, !1);
  return Ty(e);
}
function Ty(n) {
  const e = /^\s*(true|1)|(false|0)\s*$/.exec(n);
  if (e)
    return e[1] !== void 0 || !1;
}
function ge(n) {
  const e = ai(n, !1);
  return Ry(e);
}
function Ry(n) {
  const e = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(n);
  if (e)
    return parseFloat(e[1]);
}
function Oe(n) {
  return ai(n, !1).trim();
}
function Kn(n, e) {
  xt(n, e ? "1" : "0");
}
function Iy(n, e) {
  n.appendChild(bo().createCDATASection(e));
}
function Wi(n, e) {
  const t = e.toPrecision();
  n.appendChild(bo().createTextNode(t));
}
function xt(n, e) {
  n.appendChild(bo().createTextNode(e));
}
const hi = ["http://www.google.com/kml/ext/2.2"], O = [
  null,
  "http://earth.google.com/kml/2.0",
  "http://earth.google.com/kml/2.1",
  "http://earth.google.com/kml/2.2",
  "http://www.opengis.net/kml/2.2"
], Py = "http://www.opengis.net/kml/2.2 https://developers.google.com/kml/schema/kml22gx.xsd", pc = {
  fraction: "fraction",
  pixels: "pixels",
  insetPixels: "pixels"
}, Ly = z(
  O,
  {
    ExtendedData: zd,
    Region: $d,
    MultiGeometry: F(Nd, "geometry"),
    LineString: F(Od, "geometry"),
    LinearRing: F(Dd, "geometry"),
    Point: F(kd, "geometry"),
    Polygon: F(Gd, "geometry"),
    Style: F(rh),
    StyleMap: d0,
    address: F(Oe),
    description: F(Oe),
    name: F(Oe),
    open: F(Ni),
    phoneNumber: F(Oe),
    styleUrl: F(Ld),
    visibility: F(Ni)
  },
  z(hi, {
    MultiTrack: F(Qy, "geometry"),
    Track: F(Md, "geometry")
  })
), by = z(O, {
  ExtendedData: zd,
  Region: $d,
  Link: v0,
  address: F(Oe),
  description: F(Oe),
  name: F(Oe),
  open: F(Ni),
  phoneNumber: F(Oe),
  visibility: F(Ni)
}), Ay = z(O, {
  href: F(Pd)
}), Fy = z(O, {
  Altitude: F(ge),
  Longitude: F(ge),
  Latitude: F(ge),
  Tilt: F(ge),
  AltitudeMode: F(Oe),
  Heading: F(ge),
  Roll: F(ge)
}), Td = z(O, {
  LatLonAltBox: p0,
  Lod: x0
}), My = z(O, ["Document", "Placemark"]), Oy = z(O, {
  Document: U(F0),
  Placemark: U(jd)
});
let An, Mr = null, ja, vs, Ts, Rs, so, Ya = null, nh, Xa = null, Ba, Ki = null, yc = null, Wa = null;
function ro(n) {
  return 32 / Math.min(n[0], n[1]);
}
function Dy() {
  An = [255, 255, 255, 1], Mr = new Di({
    color: An
  }), ja = [20, 2], vs = "pixels", Ts = "pixels", Rs = [64, 64], so = "https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png", Ya = new vo({
    anchor: ja,
    anchorOrigin: "bottom-left",
    anchorXUnits: vs,
    anchorYUnits: Ts,
    crossOrigin: "anonymous",
    rotation: 0,
    scale: ro(Rs),
    size: Rs,
    src: so
  }), nh = "NO_IMAGE", Xa = new Ai({
    color: An,
    width: 1
  }), Ba = new Ai({
    color: [51, 51, 51, 1],
    width: 2
  }), Ki = new Yl({
    font: "bold 16px Helvetica",
    fill: Mr,
    stroke: Ba,
    scale: 0.8
  }), yc = new Ft({
    fill: Mr,
    image: Ya,
    text: Ki,
    stroke: Xa,
    zIndex: 0
  }), Wa = [yc];
}
let wr;
function Ny(n) {
  return n;
}
class ky extends vy {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, Wa || Dy(), this.dataProjection = ce("EPSG:4326"), this.defaultStyle_ = e.defaultStyle ? e.defaultStyle : Wa, this.extractStyles_ = e.extractStyles !== void 0 ? e.extractStyles : !0, this.writeStyles_ = e.writeStyles !== void 0 ? e.writeStyles : !0, this.sharedStyles_ = {}, this.showPointNames_ = e.showPointNames !== void 0 ? e.showPointNames : !0, this.crossOrigin_ = e.crossOrigin !== void 0 ? e.crossOrigin : "anonymous", this.iconUrlFunction_ = e.iconUrlFunction ? e.iconUrlFunction : Ny, this.supportedMediaTypes = ["application/vnd.google-earth.kml+xml"];
  }
  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   * @return {Array<Feature>|undefined} Features.
   */
  readDocumentOrFolder_(e, t) {
    const i = z(O, {
      Document: mc(this.readDocumentOrFolder_, this),
      Folder: mc(this.readDocumentOrFolder_, this),
      Placemark: yi(this.readPlacemark_, this),
      Style: this.readSharedStyle_.bind(this),
      StyleMap: this.readSharedStyleMap_.bind(this)
    }), s = ue([], i, e, t, this);
    if (s)
      return s;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   * @return {Feature|undefined} Feature.
   */
  readPlacemark_(e, t) {
    const i = ue(
      { geometry: null },
      Ly,
      e,
      t,
      this
    );
    if (!i)
      return;
    const s = new yt(), r = e.getAttribute("id");
    r !== null && s.setId(r);
    const o = (
      /** @type {import("./Feature.js").ReadOptions} */
      t[0]
    ), a = i.geometry;
    if (a && ln(a, !1, o), s.setGeometry(a), delete i.geometry, this.extractStyles_) {
      const l = i.Style, h = i.styleUrl, c = zy(
        l,
        h,
        this.defaultStyle_,
        this.sharedStyles_,
        this.showPointNames_
      );
      s.setStyle(c);
    }
    return delete i.Style, s.setProperties(i, !0), s;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   */
  readSharedStyle_(e, t) {
    const i = e.getAttribute("id");
    if (i !== null) {
      const s = rh.call(this, e, t);
      if (s) {
        let r, o = e.baseURI;
        (!o || o == "about:blank") && (o = window.location.href), o ? r = new URL("#" + i, o).href : r = "#" + i, this.sharedStyles_[r] = s;
      }
    }
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @private
   */
  readSharedStyleMap_(e, t) {
    const i = e.getAttribute("id");
    if (i === null)
      return;
    const s = Ad.call(this, e, t);
    if (!s)
      return;
    let r, o = e.baseURI;
    (!o || o == "about:blank") && (o = window.location.href), o ? r = new URL("#" + i, o).href : r = "#" + i, this.sharedStyles_[r] = s;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromNode(e, t) {
    if (!O.includes(e.namespaceURI))
      return null;
    const i = this.readPlacemark_(e, [
      this.getReadOptions(e, t)
    ]);
    return i || null;
  }
  /**
   * @protected
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(e, t) {
    if (!O.includes(e.namespaceURI))
      return [];
    let i;
    const s = e.localName;
    if (s == "Document" || s == "Folder")
      return i = this.readDocumentOrFolder_(e, [
        this.getReadOptions(e, t)
      ]), i || [];
    if (s == "Placemark") {
      const r = this.readPlacemark_(e, [
        this.getReadOptions(e, t)
      ]);
      return r ? [r] : [];
    }
    if (s == "kml") {
      i = [];
      for (let r = e.firstElementChild; r; r = r.nextElementSibling) {
        const o = this.readFeaturesFromNode(r, t);
        o && se(i, o);
      }
      return i;
    }
    return [];
  }
  /**
   * Read the name of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {string|undefined} Name.
   * @api
   */
  readName(e) {
    if (e) {
      if (typeof e == "string") {
        const t = vi(e);
        return this.readNameFromDocument(t);
      }
      return Si(e) ? this.readNameFromDocument(
        /** @type {Document} */
        e
      ) : this.readNameFromNode(
        /** @type {Element} */
        e
      );
    }
  }
  /**
   * @param {Document} doc Document.
   * @return {string|undefined} Name.
   */
  readNameFromDocument(e) {
    for (let t = (
      /** @type {Node} */
      e.firstChild
    ); t; t = t.nextSibling)
      if (t.nodeType == Node.ELEMENT_NODE) {
        const i = this.readNameFromNode(
          /** @type {Element} */
          t
        );
        if (i)
          return i;
      }
  }
  /**
   * @param {Element} node Node.
   * @return {string|undefined} Name.
   */
  readNameFromNode(e) {
    for (let t = e.firstElementChild; t; t = t.nextElementSibling)
      if (O.includes(t.namespaceURI) && t.localName == "name")
        return Oe(t);
    for (let t = e.firstElementChild; t; t = t.nextElementSibling) {
      const i = t.localName;
      if (O.includes(t.namespaceURI) && (i == "Document" || i == "Folder" || i == "Placemark" || i == "kml")) {
        const s = this.readNameFromNode(t);
        if (s)
          return s;
      }
    }
  }
  /**
   * Read the network links of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {Array<Object>} Network links.
   * @api
   */
  readNetworkLinks(e) {
    const t = [];
    if (typeof e == "string") {
      const i = vi(e);
      se(t, this.readNetworkLinksFromDocument(i));
    } else
      Si(e) ? se(
        t,
        this.readNetworkLinksFromDocument(
          /** @type {Document} */
          e
        )
      ) : se(
        t,
        this.readNetworkLinksFromNode(
          /** @type {Element} */
          e
        )
      );
    return t;
  }
  /**
   * @param {Document} doc Document.
   * @return {Array<Object>} Network links.
   */
  readNetworkLinksFromDocument(e) {
    const t = [];
    for (let i = (
      /** @type {Node} */
      e.firstChild
    ); i; i = i.nextSibling)
      i.nodeType == Node.ELEMENT_NODE && se(
        t,
        this.readNetworkLinksFromNode(
          /** @type {Element} */
          i
        )
      );
    return t;
  }
  /**
   * @param {Element} node Node.
   * @return {Array<Object>} Network links.
   */
  readNetworkLinksFromNode(e) {
    const t = [];
    for (let i = e.firstElementChild; i; i = i.nextElementSibling)
      if (O.includes(i.namespaceURI) && i.localName == "NetworkLink") {
        const s = ue({}, by, i, []);
        t.push(s);
      }
    for (let i = e.firstElementChild; i; i = i.nextElementSibling) {
      const s = i.localName;
      O.includes(i.namespaceURI) && (s == "Document" || s == "Folder" || s == "kml") && se(t, this.readNetworkLinksFromNode(i));
    }
    return t;
  }
  /**
   * Read the regions of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {Array<Object>} Regions.
   * @api
   */
  readRegion(e) {
    const t = [];
    if (typeof e == "string") {
      const i = vi(e);
      se(t, this.readRegionFromDocument(i));
    } else
      Si(e) ? se(
        t,
        this.readRegionFromDocument(
          /** @type {Document} */
          e
        )
      ) : se(t, this.readRegionFromNode(
        /** @type {Element} */
        e
      ));
    return t;
  }
  /**
   * @param {Document} doc Document.
   * @return {Array<Object>} Region.
   */
  readRegionFromDocument(e) {
    const t = [];
    for (let i = (
      /** @type {Node} */
      e.firstChild
    ); i; i = i.nextSibling)
      i.nodeType == Node.ELEMENT_NODE && se(t, this.readRegionFromNode(
        /** @type {Element} */
        i
      ));
    return t;
  }
  /**
   * @param {Element} node Node.
   * @return {Array<Object>} Region.
   * @api
   */
  readRegionFromNode(e) {
    const t = [];
    for (let i = e.firstElementChild; i; i = i.nextElementSibling)
      if (O.includes(i.namespaceURI) && i.localName == "Region") {
        const s = ue({}, Td, i, []);
        t.push(s);
      }
    for (let i = e.firstElementChild; i; i = i.nextElementSibling) {
      const s = i.localName;
      O.includes(i.namespaceURI) && (s == "Document" || s == "Folder" || s == "kml") && se(t, this.readRegionFromNode(i));
    }
    return t;
  }
  /**
   * @typedef {Object} KMLCamera Specifies the observer's viewpoint and associated view parameters.
   * @property {number} [Latitude] Latitude of the camera.
   * @property {number} [Longitude] Longitude of the camera.
   * @property {number} [Altitude] Altitude of the camera.
   * @property {string} [AltitudeMode] Floor-related altitude mode.
   * @property {number} [Heading] Horizontal camera rotation.
   * @property {number} [Tilt] Lateral camera rotation.
   * @property {number} [Roll] Vertical camera rotation.
   */
  /**
   * Read the cameras of the KML.
   *
   * @param {Document|Element|string} source Source.
   * @return {Array<KMLCamera>} Cameras.
   * @api
   */
  readCamera(e) {
    const t = [];
    if (typeof e == "string") {
      const i = vi(e);
      se(t, this.readCameraFromDocument(i));
    } else
      Si(e) ? se(
        t,
        this.readCameraFromDocument(
          /** @type {Document} */
          e
        )
      ) : se(t, this.readCameraFromNode(
        /** @type {Element} */
        e
      ));
    return t;
  }
  /**
   * @param {Document} doc Document.
   * @return {Array<KMLCamera>} Cameras.
   */
  readCameraFromDocument(e) {
    const t = [];
    for (let i = (
      /** @type {Node} */
      e.firstChild
    ); i; i = i.nextSibling)
      i.nodeType === Node.ELEMENT_NODE && se(t, this.readCameraFromNode(
        /** @type {Element} */
        i
      ));
    return t;
  }
  /**
   * @param {Element} node Node.
   * @return {Array<KMLCamera>} Cameras.
   * @api
   */
  readCameraFromNode(e) {
    const t = [];
    for (let i = e.firstElementChild; i; i = i.nextElementSibling)
      if (O.includes(i.namespaceURI) && i.localName === "Camera") {
        const s = ue({}, Fy, i, []);
        t.push(s);
      }
    for (let i = e.firstElementChild; i; i = i.nextElementSibling) {
      const s = i.localName;
      O.includes(i.namespaceURI) && (s === "Document" || s === "Folder" || s === "Placemark" || s === "kml") && se(t, this.readCameraFromNode(i));
    }
    return t;
  }
  /**
   * Encode an array of features in the KML format as an XML node. GeometryCollections,
   * MultiPoints, MultiLineStrings, and MultiPolygons are output as MultiGeometries.
   *
   * @param {Array<Feature>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   * @api
   */
  writeFeaturesNode(e, t) {
    t = this.adaptOptions(t);
    const i = rr(O[4], "kml"), s = "http://www.w3.org/2000/xmlns/";
    i.setAttributeNS(s, "xmlns:gx", hi[0]), i.setAttributeNS(s, "xmlns:xsi", _c), i.setAttributeNS(
      _c,
      "xsi:schemaLocation",
      Py
    );
    const r = {
      node: i
    }, o = {};
    e.length > 1 ? o.Document = e : e.length == 1 && (o.Placemark = e[0]);
    const a = My[i.namespaceURI], l = St(o, a);
    return we(
      r,
      Oy,
      ct,
      l,
      [t],
      a,
      this
    ), i;
  }
}
function Gy(n, e) {
  const t = [0, 0];
  let i = "start";
  const s = n.getImage();
  if (s) {
    const a = s.getSize();
    if (a && a.length == 2) {
      const l = s.getScaleArray(), h = s.getAnchor();
      t[0] = l[0] * (a[0] - h[0]), t[1] = l[1] * (a[1] / 2 - h[1]), i = "left";
    }
  }
  let r = n.getText();
  return r ? (r = r.clone(), r.setFont(r.getFont() || Ki.getFont()), r.setScale(r.getScale() || Ki.getScale()), r.setFill(r.getFill() || Ki.getFill()), r.setStroke(r.getStroke() || Ba)) : r = Ki.clone(), r.setText(e), r.setOffsetX(t[0]), r.setOffsetY(t[1]), r.setTextAlign(i), new Ft({
    image: s,
    text: r
  });
}
function zy(n, e, t, i, s) {
  return (
    /**
     * @param {Feature} feature feature.
     * @param {number} resolution Resolution.
     * @return {Array<Style>|Style} Style.
     */
    function(r, o) {
      let a = s, l = "", h = [];
      if (a) {
        const u = r.getGeometry();
        if (u)
          if (u instanceof ei)
            h = u.getGeometriesArrayRecursive().filter(function(d) {
              const f = d.getType();
              return f === "Point" || f === "MultiPoint";
            }), a = h.length > 0;
          else {
            const d = u.getType();
            a = d === "Point" || d === "MultiPoint";
          }
      }
      a && (l = /** @type {string} */
      r.get("name"), a = a && !!l, a && /&[^&]+;/.test(l) && (wr || (wr = document.createElement("textarea")), wr.innerHTML = l, l = wr.value));
      let c = t;
      if (n ? c = n : e && (c = Rd(e, t, i)), a) {
        const u = Gy(c[0], l);
        if (h.length > 0) {
          u.setGeometry(new ei(h));
          const d = new Ft({
            geometry: c[0].getGeometry(),
            image: null,
            fill: c[0].getFill(),
            stroke: c[0].getStroke(),
            text: null
          });
          return [u, d].concat(c.slice(1));
        }
        return u;
      }
      return c;
    }
  );
}
function Rd(n, e, t) {
  return Array.isArray(n) ? n : typeof n == "string" ? Rd(t[n], e, t) : e;
}
function Ao(n) {
  const e = ai(n, !1), t = /^\s*#?\s*([0-9A-Fa-f]{8})\s*$/.exec(e);
  if (t) {
    const i = t[1];
    return [
      parseInt(i.substr(6, 2), 16),
      parseInt(i.substr(4, 2), 16),
      parseInt(i.substr(2, 2), 16),
      parseInt(i.substr(0, 2), 16) / 255
    ];
  }
}
function Id(n) {
  let e = ai(n, !1);
  const t = [];
  e = e.replace(/\s*,\s*/g, ",");
  const i = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?),([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|,|$)(?:([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)(?:\s+|$))?\s*/i;
  let s;
  for (; s = i.exec(e); ) {
    const r = parseFloat(s[1]), o = parseFloat(s[2]), a = s[3] ? parseFloat(s[3]) : 0;
    t.push(r, o, a), e = e.substr(s[0].length);
  }
  if (e === "")
    return t;
}
function Pd(n) {
  const e = ai(n, !1).trim();
  let t = n.baseURI;
  return (!t || t == "about:blank") && (t = window.location.href), t ? new URL(e, t).href : e;
}
function Ld(n) {
  const e = ai(n, !1).trim().replace(/^(?!.*#)/, "#");
  let t = n.baseURI;
  return (!t || t == "about:blank") && (t = window.location.href), t ? new URL(e, t).href : e;
}
function $y(n) {
  const e = n.getAttribute("xunits"), t = n.getAttribute("yunits");
  let i;
  return e !== "insetPixels" ? t !== "insetPixels" ? i = "bottom-left" : i = "top-left" : t !== "insetPixels" ? i = "bottom-right" : i = "top-right", {
    x: parseFloat(n.getAttribute("x")),
    xunits: pc[e],
    y: parseFloat(n.getAttribute("y")),
    yunits: pc[t],
    origin: i
  };
}
function bd(n) {
  return ge(n);
}
const Uy = z(O, {
  Pair: u0
});
function Ad(n, e) {
  return ue(void 0, Uy, n, e, this);
}
const Vy = z(O, {
  Icon: F(i0),
  color: F(Ao),
  heading: F(ge),
  hotSpot: F($y),
  scale: F(bd)
});
function jy(n, e) {
  const t = ue({}, Vy, n, e);
  if (!t)
    return;
  const i = (
    /** @type {Object} */
    e[e.length - 1]
  ), s = "Icon" in t ? t.Icon : {}, r = !("Icon" in t) || Object.keys(s).length > 0;
  let o;
  const a = (
    /** @type {string|undefined} */
    s.href
  );
  a ? o = a : r && (o = so);
  let l, h, c, u = "bottom-left";
  const d = (
    /** @type {Vec2|undefined} */
    t.hotSpot
  );
  d ? (l = [d.x, d.y], h = d.xunits, c = d.yunits, u = d.origin) : /^https?:\/\/maps\.(?:google|gstatic)\.com\//.test(o) && (o.includes("pushpin") ? (l = ja, h = vs, c = Ts) : o.includes("arrow-reverse") ? (l = [54, 42], h = vs, c = Ts) : o.includes("paddle") && (l = [32, 1], h = vs, c = Ts));
  let f;
  const g = (
    /** @type {number|undefined} */
    s.x
  ), _ = (
    /** @type {number|undefined} */
    s.y
  );
  g !== void 0 && _ !== void 0 && (f = [g, _]);
  let m;
  const p = (
    /** @type {number|undefined} */
    s.w
  ), y = (
    /** @type {number|undefined} */
    s.h
  );
  p !== void 0 && y !== void 0 && (m = [p, y]);
  let x;
  const E = (
    /** @type {number} */
    t.heading
  );
  E !== void 0 && (x = Li(E));
  const C = (
    /** @type {number|undefined} */
    t.scale
  ), w = (
    /** @type {Array<number>|undefined} */
    t.color
  );
  if (r) {
    o == so && (m = Rs);
    const S = new vo({
      anchor: l,
      anchorOrigin: u,
      anchorXUnits: h,
      anchorYUnits: c,
      crossOrigin: this.crossOrigin_,
      offset: f,
      offsetOrigin: "bottom-left",
      rotation: x,
      scale: C,
      size: m,
      src: this.iconUrlFunction_(o),
      color: w
    }), v = S.getScaleArray()[0], R = S.getSize();
    if (R === null) {
      const b = S.getImageState();
      if (b === M.IDLE || b === M.LOADING) {
        const A = function() {
          const N = S.getImageState();
          if (!(N === M.IDLE || N === M.LOADING)) {
            const $ = S.getSize();
            if ($ && $.length == 2) {
              const V = ro($);
              S.setScale(v * V);
            }
            S.unlistenImageChange(A);
          }
        };
        S.listenImageChange(A), b === M.IDLE && S.load();
      }
    } else if (R.length == 2) {
      const b = ro(R);
      S.setScale(v * b);
    }
    i.imageStyle = S;
  } else
    i.imageStyle = nh;
}
const Yy = z(O, {
  color: F(Ao),
  scale: F(bd)
});
function Xy(n, e) {
  const t = ue({}, Yy, n, e);
  if (!t)
    return;
  const i = e[e.length - 1], s = new Yl({
    fill: new Di({
      color: (
        /** @type {import("../color.js").Color} */
        "color" in t ? t.color : An
      )
    }),
    scale: (
      /** @type {number|undefined} */
      t.scale
    )
  });
  i.textStyle = s;
}
const By = z(O, {
  color: F(Ao),
  width: F(ge)
});
function Wy(n, e) {
  const t = ue({}, By, n, e);
  if (!t)
    return;
  const i = e[e.length - 1], s = new Ai({
    color: (
      /** @type {import("../color.js").Color} */
      "color" in t ? t.color : An
    ),
    width: (
      /** @type {number} */
      "width" in t ? t.width : 1
    )
  });
  i.strokeStyle = s;
}
const Ky = z(O, {
  color: F(Ao),
  fill: F(Ni),
  outline: F(Ni)
});
function Zy(n, e) {
  const t = ue({}, Ky, n, e);
  if (!t)
    return;
  const i = e[e.length - 1], s = new Di({
    color: (
      /** @type {import("../color.js").Color} */
      "color" in t ? t.color : An
    )
  });
  i.fillStyle = s;
  const r = (
    /** @type {boolean|undefined} */
    t.fill
  );
  r !== void 0 && (i.fill = r);
  const o = (
    /** @type {boolean|undefined} */
    t.outline
  );
  o !== void 0 && (i.outline = o);
}
const Hy = z(O, {
  coordinates: ih(Id)
});
function Fd(n, e) {
  return ue(null, Hy, n, e);
}
function qy(n, e) {
  const i = /** @type {GxTrackObject} */ e[e.length - 1].coordinates, s = ai(n, !1), o = /^\s*([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s+([+\-]?\d+(?:\.\d*)?(?:e[+\-]?\d*)?)\s*$/i.exec(s);
  if (o) {
    const a = parseFloat(o[1]), l = parseFloat(o[2]), h = parseFloat(o[3]);
    i.push([a, l, h]);
  } else
    i.push([]);
}
const Jy = z(hi, {
  Track: yi(Md)
});
function Qy(n, e) {
  const t = ue(
    [],
    Jy,
    n,
    e
  );
  if (t)
    return new an(t);
}
const e0 = z(
  O,
  {
    when: T0
  },
  z(hi, {
    coord: qy
  })
);
function Md(n, e) {
  const t = ue(
    /** @type {GxTrackObject} */
    {
      coordinates: [],
      whens: []
    },
    e0,
    n,
    e
  );
  if (!t)
    return;
  const i = [], s = t.coordinates, r = t.whens;
  for (let o = 0, a = Math.min(s.length, r.length); o < a; ++o)
    s[o].length == 3 && i.push(
      s[o][0],
      s[o][1],
      s[o][2],
      r[o]
    );
  return new ht(i, "XYZM");
}
const t0 = z(
  O,
  {
    href: F(Pd)
  },
  z(hi, {
    x: F(ge),
    y: F(ge),
    w: F(ge),
    h: F(ge)
  })
);
function i0(n, e) {
  const t = ue({}, t0, n, e);
  return t || null;
}
const n0 = z(O, {
  coordinates: ih(Id)
});
function sh(n, e) {
  return ue(
    null,
    n0,
    n,
    e
  );
}
const Fo = z(O, {
  extrude: F(Ni),
  tessellate: F(Ni),
  altitudeMode: F(Oe)
});
function Od(n, e) {
  const t = ue(
    {},
    Fo,
    n,
    e
  ), i = sh(n, e);
  if (i) {
    const s = new ht(i, "XYZ");
    return s.setProperties(t, !0), s;
  }
}
function Dd(n, e) {
  const t = ue(
    {},
    Fo,
    n,
    e
  ), i = sh(n, e);
  if (i) {
    const s = new Ne(i, "XYZ", [
      i.length
    ]);
    return s.setProperties(t, !0), s;
  }
}
const s0 = z(O, {
  LineString: yi(Od),
  LinearRing: yi(Dd),
  MultiGeometry: yi(Nd),
  Point: yi(kd),
  Polygon: yi(Gd)
});
function Nd(n, e) {
  const t = ue(
    [],
    s0,
    n,
    e
  );
  if (!t)
    return null;
  if (t.length === 0)
    return new ei(t);
  let i, s = !0;
  const r = t[0].getType();
  let o;
  for (let a = 1, l = t.length; a < l; ++a)
    if (o = t[a], o.getType() != r) {
      s = !1;
      break;
    }
  if (s) {
    let a, l;
    if (r == "Point") {
      const h = t[0];
      a = h.getLayout(), l = h.getFlatCoordinates();
      for (let c = 1, u = t.length; c < u; ++c)
        o = t[c], se(l, o.getFlatCoordinates());
      i = new ts(l, a), ca(i, t);
    } else if (r == "LineString")
      i = new an(t), ca(i, t);
    else if (r == "Polygon")
      i = new is(t), ca(i, t);
    else if (r == "GeometryCollection")
      i = new ei(t);
    else
      throw new Error("Unknown geometry type found");
  } else
    i = new ei(t);
  return (
    /** @type {import("../geom/Geometry.js").default} */
    i
  );
}
function kd(n, e) {
  const t = ue(
    {},
    Fo,
    n,
    e
  ), i = sh(n, e);
  if (i) {
    const s = new lt(i, "XYZ");
    return s.setProperties(t, !0), s;
  }
}
const r0 = z(O, {
  innerBoundaryIs: C0,
  outerBoundaryIs: S0
});
function Gd(n, e) {
  const t = ue(
    /** @type {Object<string,*>} */
    {},
    Fo,
    n,
    e
  ), i = ue(
    [null],
    r0,
    n,
    e
  );
  if (i && i[0]) {
    const s = i[0], r = [s.length];
    for (let a = 1, l = i.length; a < l; ++a)
      se(s, i[a]), r.push(s.length);
    const o = new Ne(s, "XYZ", r);
    return o.setProperties(t, !0), o;
  }
}
const o0 = z(O, {
  IconStyle: jy,
  LabelStyle: Xy,
  LineStyle: Wy,
  PolyStyle: Zy
});
function rh(n, e) {
  const t = ue(
    {},
    o0,
    n,
    e,
    this
  );
  if (!t)
    return null;
  let i = (
    /** @type {Fill} */
    "fillStyle" in t ? t.fillStyle : Mr
  );
  const s = (
    /** @type {boolean|undefined} */
    t.fill
  );
  s !== void 0 && !s && (i = null);
  let r;
  "imageStyle" in t ? t.imageStyle != nh && (r = /** @type {import("../style/Image.js").default} */
  t.imageStyle) : r = Ya;
  const o = (
    /** @type {Text} */
    "textStyle" in t ? t.textStyle : Ki
  ), a = (
    /** @type {Stroke} */
    "strokeStyle" in t ? t.strokeStyle : Xa
  ), l = (
    /** @type {boolean|undefined} */
    t.outline
  );
  return l !== void 0 && !l ? [
    new Ft({
      geometry: function(h) {
        const c = h.getGeometry(), u = c.getType();
        if (u === "GeometryCollection") {
          const d = (
            /** @type {import("../geom/GeometryCollection").default} */
            c
          );
          return new ei(
            d.getGeometriesArrayRecursive().filter(function(f) {
              const g = f.getType();
              return g !== "Polygon" && g !== "MultiPolygon";
            })
          );
        }
        if (u !== "Polygon" && u !== "MultiPolygon")
          return c;
      },
      fill: i,
      image: r,
      stroke: a,
      text: o,
      zIndex: void 0
      // FIXME
    }),
    new Ft({
      geometry: function(h) {
        const c = h.getGeometry(), u = c.getType();
        if (u === "GeometryCollection") {
          const d = (
            /** @type {import("../geom/GeometryCollection").default} */
            c
          );
          return new ei(
            d.getGeometriesArrayRecursive().filter(function(f) {
              const g = f.getType();
              return g === "Polygon" || g === "MultiPolygon";
            })
          );
        }
        if (u === "Polygon" || u === "MultiPolygon")
          return c;
      },
      fill: i,
      stroke: null,
      zIndex: void 0
      // FIXME
    })
  ] : [
    new Ft({
      fill: i,
      image: r,
      stroke: a,
      text: o,
      zIndex: void 0
      // FIXME
    })
  ];
}
function ca(n, e) {
  const t = e.length, i = new Array(e.length), s = new Array(e.length), r = new Array(e.length);
  let o, a, l;
  o = !1, a = !1, l = !1;
  for (let h = 0; h < t; ++h) {
    const c = e[h];
    i[h] = c.get("extrude"), s[h] = c.get("tessellate"), r[h] = c.get("altitudeMode"), o = o || i[h] !== void 0, a = a || s[h] !== void 0, l = l || r[h];
  }
  o && n.set("extrude", i), a && n.set("tessellate", s), l && n.set("altitudeMode", r);
}
const a0 = z(O, {
  displayName: F(Oe),
  value: F(Oe)
});
function l0(n, e) {
  const t = n.getAttribute("name");
  ns(a0, n, e);
  const i = (
    /** @type {Object} */
    e[e.length - 1]
  );
  t && i.displayName ? i[t] = {
    value: i.value,
    displayName: i.displayName,
    toString: function() {
      return i.value;
    }
  } : t !== null ? i[t] = i.value : i.displayName !== null && (i[i.displayName] = i.value), delete i.value;
}
const h0 = z(O, {
  Data: l0,
  SchemaData: g0
});
function zd(n, e) {
  ns(h0, n, e);
}
function $d(n, e) {
  ns(Td, n, e);
}
const c0 = z(O, {
  Style: F(rh),
  key: F(Oe),
  styleUrl: F(Ld)
});
function u0(n, e) {
  const t = ue({}, c0, n, e, this);
  if (!t)
    return;
  const i = (
    /** @type {string|undefined} */
    t.key
  );
  if (i && i == "normal") {
    const s = (
      /** @type {string|undefined} */
      t.styleUrl
    );
    s && (e[e.length - 1] = s);
    const r = (
      /** @type {Style} */
      t.Style
    );
    r && (e[e.length - 1] = r);
  }
}
function d0(n, e) {
  const t = Ad.call(this, n, e);
  if (!t)
    return;
  const i = e[e.length - 1];
  if (Array.isArray(t))
    i.Style = t;
  else if (typeof t == "string")
    i.styleUrl = t;
  else
    throw new Error("`styleMapValue` has an unknown type");
}
const f0 = z(O, {
  SimpleData: _0
});
function g0(n, e) {
  ns(f0, n, e);
}
function _0(n, e) {
  const t = n.getAttribute("name");
  if (t !== null) {
    const i = Oe(n), s = (
      /** @type {Object} */
      e[e.length - 1]
    );
    s[t] = i;
  }
}
const m0 = z(O, {
  altitudeMode: F(Oe),
  minAltitude: F(ge),
  maxAltitude: F(ge),
  north: F(ge),
  south: F(ge),
  east: F(ge),
  west: F(ge)
});
function p0(n, e) {
  const t = ue(
    {},
    m0,
    n,
    e
  );
  if (!t)
    return;
  const i = (
    /** @type {Object} */
    e[e.length - 1]
  ), s = [
    parseFloat(t.west),
    parseFloat(t.south),
    parseFloat(t.east),
    parseFloat(t.north)
  ];
  i.extent = s, i.altitudeMode = t.altitudeMode, i.minAltitude = parseFloat(t.minAltitude), i.maxAltitude = parseFloat(t.maxAltitude);
}
const y0 = z(O, {
  minLodPixels: F(ge),
  maxLodPixels: F(ge),
  minFadeExtent: F(ge),
  maxFadeExtent: F(ge)
});
function x0(n, e) {
  const t = ue({}, y0, n, e);
  if (!t)
    return;
  const i = (
    /** @type {Object} */
    e[e.length - 1]
  );
  i.minLodPixels = parseFloat(t.minLodPixels), i.maxLodPixels = parseFloat(t.maxLodPixels), i.minFadeExtent = parseFloat(t.minFadeExtent), i.maxFadeExtent = parseFloat(t.maxFadeExtent);
}
const E0 = z(O, {
  // KML spec only allows one LinearRing  per innerBoundaryIs, but Google Earth
  // allows multiple, so we parse multiple here too.
  LinearRing: yi(Fd)
});
function C0(n, e) {
  const t = ue(
    /** @type {Array<Array<number>>} */
    [],
    E0,
    n,
    e
  );
  t.length > 0 && /** @type {Array<Array<number>>} */
  e[e.length - 1].push(...t);
}
const w0 = z(O, {
  LinearRing: ih(Fd)
});
function S0(n, e) {
  const t = ue(
    void 0,
    w0,
    n,
    e
  );
  if (t) {
    const i = (
      /** @type {Array<Array<number>>} */
      e[e.length - 1]
    );
    i[0] = t;
  }
}
function v0(n, e) {
  ns(Ay, n, e);
}
function T0(n, e) {
  const i = /** @type {GxTrackObject} */ e[e.length - 1].whens, s = ai(n, !1), r = Date.parse(s);
  i.push(isNaN(r) ? 0 : r);
}
function Mo(n, e) {
  const t = jn(e), s = [(t.length == 4 ? t[3] : 1) * 255, t[2], t[1], t[0]];
  for (let r = 0; r < 4; ++r) {
    const o = Math.floor(
      /** @type {number} */
      s[r]
    ).toString(16);
    s[r] = o.length == 1 ? "0" + o : o;
  }
  xt(n, s.join(""));
}
function R0(n, e, t) {
  const i = t[t.length - 1], s = i.layout, r = i.stride;
  let o;
  if (s == "XY" || s == "XYM")
    o = 2;
  else if (s == "XYZ" || s == "XYZM")
    o = 3;
  else
    throw new Error("Invalid geometry layout");
  const a = e.length;
  let l = "";
  if (a > 0) {
    l += e[0];
    for (let h = 1; h < o; ++h)
      l += "," + e[h];
    for (let h = r; h < a; h += r) {
      l += " " + e[h];
      for (let c = 1; c < o; ++c)
        l += "," + e[h + c];
    }
  }
  xt(n, l);
}
const Or = z(O, {
  Data: U(I0),
  value: U(L0),
  displayName: U(P0)
});
function I0(n, e, t) {
  n.setAttribute("name", e.name);
  const i = { node: n }, s = e.value;
  typeof s == "object" ? (s !== null && s.displayName && we(
    i,
    Or,
    ct,
    [s.displayName],
    t,
    ["displayName"]
  ), s !== null && s.value && we(
    i,
    Or,
    ct,
    [s.value],
    t,
    ["value"]
  )) : we(
    i,
    Or,
    ct,
    [s],
    t,
    ["value"]
  );
}
function P0(n, e) {
  Iy(n, e);
}
function L0(n, e) {
  xt(n, e);
}
const b0 = z(O, {
  Placemark: U(jd)
}), A0 = function(n, e, t) {
  const i = e[e.length - 1].node;
  return rr(i.namespaceURI, "Placemark");
};
function F0(n, e, t) {
  we(
    { node: n },
    b0,
    A0,
    e,
    t,
    void 0,
    this
  );
}
const M0 = li("Data");
function O0(n, e, t) {
  const i = { node: n }, s = e.names, r = e.values, o = s.length;
  for (let a = 0; a < o; a++)
    we(
      i,
      Or,
      M0,
      [{ name: s[a], value: r[a] }],
      t
    );
}
const xc = z(
  O,
  ["href"],
  z(hi, ["x", "y", "w", "h"])
), Ec = z(
  O,
  {
    href: U(xt)
  },
  z(hi, {
    x: U(Wi),
    y: U(Wi),
    w: U(Wi),
    h: U(Wi)
  })
), D0 = function(n, e, t) {
  return rr(hi[0], "gx:" + t);
};
function N0(n, e, t) {
  const i = { node: n }, s = t[t.length - 1].node;
  let r = xc[s.namespaceURI], o = St(e, r);
  we(
    i,
    Ec,
    ct,
    o,
    t,
    r
  ), r = xc[hi[0]], o = St(e, r), we(
    i,
    Ec,
    D0,
    o,
    t,
    r
  );
}
const k0 = z(O, [
  "scale",
  "heading",
  "Icon",
  "color",
  "hotSpot"
]), G0 = z(O, {
  Icon: U(N0),
  color: U(Mo),
  heading: U(Wi),
  hotSpot: U(ux),
  scale: U(Xd)
});
function z0(n, e, t) {
  const i = { node: n }, s = {}, r = e.getSrc(), o = e.getSize(), a = e.getImageSize(), l = {
    href: r
  };
  if (o) {
    l.w = o[0], l.h = o[1];
    const m = e.getAnchor(), p = e.getOrigin();
    if (p && a && p[0] !== 0 && p[1] !== o[1] && (l.x = p[0], l.y = a[1] - (p[1] + o[1])), m && (m[0] !== o[0] / 2 || m[1] !== o[1] / 2)) {
      const y = {
        x: m[0],
        xunits: "pixels",
        y: o[1] - m[1],
        yunits: "pixels"
      };
      s.hotSpot = y;
    }
  }
  s.Icon = l;
  let h = e.getScaleArray()[0], c = o;
  if (c === null && (c = Rs), c.length == 2) {
    const m = ro(c);
    h = h / m;
  }
  h !== 1 && (s.scale = h);
  const u = e.getRotation();
  u !== 0 && (s.heading = u);
  const d = e.getColor();
  d && (s.color = d);
  const f = t[t.length - 1].node, g = k0[f.namespaceURI], _ = St(s, g);
  we(
    i,
    G0,
    ct,
    _,
    t,
    g
  );
}
const $0 = z(O, [
  "color",
  "scale"
]), U0 = z(O, {
  color: U(Mo),
  scale: U(Xd)
});
function V0(n, e, t) {
  const i = { node: n }, s = {}, r = e.getFill();
  r && (s.color = r.getColor());
  const o = e.getScale();
  o && o !== 1 && (s.scale = o);
  const a = t[t.length - 1].node, l = $0[a.namespaceURI], h = St(s, l);
  we(
    i,
    U0,
    ct,
    h,
    t,
    l
  );
}
const j0 = z(O, ["color", "width"]), Y0 = z(O, {
  color: U(Mo),
  width: U(Wi)
});
function X0(n, e, t) {
  const i = { node: n }, s = {
    color: e.getColor(),
    width: Number(e.getWidth()) || 1
  }, r = t[t.length - 1].node, o = j0[r.namespaceURI], a = St(s, o);
  we(
    i,
    Y0,
    ct,
    a,
    t,
    o
  );
}
const B0 = {
  Point: "Point",
  LineString: "LineString",
  LinearRing: "LinearRing",
  Polygon: "Polygon",
  MultiPoint: "MultiGeometry",
  MultiLineString: "MultiGeometry",
  MultiPolygon: "MultiGeometry",
  GeometryCollection: "MultiGeometry"
}, Ud = function(n, e, t) {
  if (n) {
    const i = e[e.length - 1].node;
    return rr(
      i.namespaceURI,
      B0[
        /** @type {import("../geom/Geometry.js").default} */
        n.getType()
      ]
    );
  }
}, W0 = li("Point"), K0 = li("LineString"), Z0 = li("LinearRing"), H0 = li("Polygon"), q0 = z(O, {
  LineString: U(Fn),
  Point: U(Fn),
  Polygon: U(Yd),
  GeometryCollection: U(Vd)
});
function Vd(n, e, t) {
  const i = { node: n }, s = e.getType();
  let r = [], o;
  if (s === "GeometryCollection")
    e.getGeometriesArrayRecursive().forEach(function(a) {
      const l = a.getType();
      if (l === "MultiPoint")
        r = r.concat(
          /** @type {MultiPoint} */
          a.getPoints()
        );
      else if (l === "MultiLineString")
        r = r.concat(
          /** @type {MultiLineString} */
          a.getLineStrings()
        );
      else if (l === "MultiPolygon")
        r = r.concat(
          /** @type {MultiPolygon} */
          a.getPolygons()
        );
      else if (l === "Point" || l === "LineString" || l === "Polygon")
        r.push(a);
      else
        throw new Error("Unknown geometry type");
    }), o = Ud;
  else if (s === "MultiPoint")
    r = /** @type {MultiPoint} */
    e.getPoints(), o = W0;
  else if (s === "MultiLineString")
    r = /** @type {MultiLineString} */
    e.getLineStrings(), o = K0;
  else if (s === "MultiPolygon")
    r = /** @type {MultiPolygon} */
    e.getPolygons(), o = H0;
  else
    throw new Error("Unknown geometry type");
  we(
    i,
    q0,
    o,
    r,
    t
  );
}
const J0 = z(O, {
  LinearRing: U(Fn)
});
function Cc(n, e, t) {
  we(
    { node: n },
    J0,
    Z0,
    [e],
    t
  );
}
const ua = z(O, {
  ExtendedData: U(O0),
  MultiGeometry: U(Vd),
  LineString: U(Fn),
  LinearRing: U(Fn),
  Point: U(Fn),
  Polygon: U(Yd),
  Style: U(cx),
  address: U(xt),
  description: U(xt),
  name: U(xt),
  open: U(Kn),
  phoneNumber: U(xt),
  styleUrl: U(xt),
  visibility: U(Kn)
}), Q0 = z(O, [
  "name",
  "open",
  "visibility",
  "address",
  "phoneNumber",
  "description",
  "styleUrl",
  "Style"
]), ex = li("ExtendedData");
function jd(n, e, t) {
  const i = { node: n };
  e.getId() && n.setAttribute(
    "id",
    /** @type {string} */
    e.getId()
  );
  const s = e.getProperties(), r = {
    address: 1,
    description: 1,
    name: 1,
    open: 1,
    phoneNumber: 1,
    styleUrl: 1,
    visibility: 1
  };
  r[e.getGeometryName()] = 1;
  const o = Object.keys(s || {}).sort().filter(function(f) {
    return !r[f];
  }), a = e.getStyleFunction();
  if (a) {
    const f = a(e, 0);
    if (f) {
      const g = Array.isArray(f) ? f : [f];
      let _ = g;
      if (e.getGeometry() && (_ = g.filter(function(m) {
        const p = m.getGeometryFunction()(e);
        if (p) {
          const y = p.getType();
          return y === "GeometryCollection" ? (
            /** @type {GeometryCollection} */
            p.getGeometriesArrayRecursive().filter(function(x) {
              const E = x.getType();
              return E === "Point" || E === "MultiPoint";
            }).length
          ) : y === "Point" || y === "MultiPoint";
        }
      })), this.writeStyles_) {
        let m = g, p = g;
        e.getGeometry() && (m = g.filter(function(y) {
          const x = y.getGeometryFunction()(e);
          if (x) {
            const E = x.getType();
            return E === "GeometryCollection" ? (
              /** @type {GeometryCollection} */
              x.getGeometriesArrayRecursive().filter(function(C) {
                const w = C.getType();
                return w === "LineString" || w === "MultiLineString";
              }).length
            ) : E === "LineString" || E === "MultiLineString";
          }
        }), p = g.filter(function(y) {
          const x = y.getGeometryFunction()(e);
          if (x) {
            const E = x.getType();
            return E === "GeometryCollection" ? (
              /** @type {GeometryCollection} */
              x.getGeometriesArrayRecursive().filter(function(C) {
                const w = C.getType();
                return w === "Polygon" || w === "MultiPolygon";
              }).length
            ) : E === "Polygon" || E === "MultiPolygon";
          }
        })), s.Style = {
          pointStyles: _,
          lineStyles: m,
          polyStyles: p
        };
      }
      if (_.length && s.name === void 0) {
        const m = _[0].getText();
        m && (s.name = m.getText());
      }
    }
  }
  const l = t[t.length - 1].node, h = Q0[l.namespaceURI], c = St(s, h);
  if (we(
    i,
    ua,
    ct,
    c,
    t,
    h
  ), o.length > 0) {
    const f = St(s, o);
    we(
      i,
      ua,
      ex,
      [{ names: o, values: f }],
      t
    );
  }
  const u = (
    /** @type {import("./Feature.js").WriteOptions} */
    t[0]
  );
  let d = e.getGeometry();
  d && (d = ln(d, !0, u)), we(
    i,
    ua,
    Ud,
    [d],
    t
  );
}
const tx = z(O, [
  "extrude",
  "tessellate",
  "altitudeMode",
  "coordinates"
]), ix = z(O, {
  extrude: U(Kn),
  tessellate: U(Kn),
  altitudeMode: U(xt),
  coordinates: U(R0)
});
function Fn(n, e, t) {
  const i = e.getFlatCoordinates(), s = { node: n };
  s.layout = e.getLayout(), s.stride = e.getStride();
  const r = e.getProperties();
  r.coordinates = i;
  const o = t[t.length - 1].node, a = tx[o.namespaceURI], l = St(r, a);
  we(
    s,
    ix,
    ct,
    l,
    t,
    a
  );
}
const nx = z(O, [
  "color",
  "fill",
  "outline"
]), wc = z(O, {
  outerBoundaryIs: U(Cc),
  innerBoundaryIs: U(Cc)
}), sx = li("innerBoundaryIs"), rx = li("outerBoundaryIs");
function Yd(n, e, t) {
  const i = e.getLinearRings(), s = i.shift(), r = { node: n };
  we(
    r,
    wc,
    sx,
    i,
    t
  ), we(
    r,
    wc,
    rx,
    [s],
    t
  );
}
const ox = z(O, {
  color: U(Mo),
  fill: U(Kn),
  outline: U(Kn)
});
function ax(n, e, t) {
  const i = { node: n }, s = e.getFill(), r = e.getStroke(), o = {
    color: s ? s.getColor() : void 0,
    fill: s ? void 0 : !1,
    outline: r ? void 0 : !1
  }, a = t[t.length - 1].node, l = nx[a.namespaceURI], h = St(o, l);
  we(
    i,
    ox,
    ct,
    h,
    t,
    l
  );
}
function Xd(n, e) {
  Wi(n, Math.round(e * 1e6) / 1e6);
}
const lx = z(O, [
  "IconStyle",
  "LabelStyle",
  "LineStyle",
  "PolyStyle"
]), hx = z(O, {
  IconStyle: U(z0),
  LabelStyle: U(V0),
  LineStyle: U(X0),
  PolyStyle: U(ax)
});
function cx(n, e, t) {
  const i = { node: n }, s = {};
  if (e.pointStyles.length) {
    const l = e.pointStyles[0].getText();
    l && (s.LabelStyle = l);
    const h = e.pointStyles[0].getImage();
    h && typeof /** @type {?} */
    h.getSrc == "function" && (s.IconStyle = h);
  }
  if (e.lineStyles.length) {
    const l = e.lineStyles[0].getStroke();
    l && (s.LineStyle = l);
  }
  if (e.polyStyles.length) {
    const l = e.polyStyles[0].getStroke();
    l && !s.LineStyle && (s.LineStyle = l), s.PolyStyle = e.polyStyles[0];
  }
  const r = t[t.length - 1].node, o = lx[r.namespaceURI], a = St(s, o);
  we(
    i,
    hx,
    ct,
    a,
    t,
    o
  );
}
function ux(n, e) {
  n.setAttribute("x", String(e.x)), n.setAttribute("y", String(e.y)), n.setAttribute("xunits", e.xunits), n.setAttribute("yunits", e.yunits);
}
const dx = ky;
var oh = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
oh.read = function(n, e, t, i, s) {
  var r, o, a = s * 8 - i - 1, l = (1 << a) - 1, h = l >> 1, c = -7, u = t ? s - 1 : 0, d = t ? -1 : 1, f = n[e + u];
  for (u += d, r = f & (1 << -c) - 1, f >>= -c, c += a; c > 0; r = r * 256 + n[e + u], u += d, c -= 8)
    ;
  for (o = r & (1 << -c) - 1, r >>= -c, c += i; c > 0; o = o * 256 + n[e + u], u += d, c -= 8)
    ;
  if (r === 0)
    r = 1 - h;
  else {
    if (r === l)
      return o ? NaN : (f ? -1 : 1) * (1 / 0);
    o = o + Math.pow(2, i), r = r - h;
  }
  return (f ? -1 : 1) * o * Math.pow(2, r - i);
};
oh.write = function(n, e, t, i, s, r) {
  var o, a, l, h = r * 8 - s - 1, c = (1 << h) - 1, u = c >> 1, d = s === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = i ? 0 : r - 1, g = i ? 1 : -1, _ = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, o = c) : (o = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), o + u >= 1 ? e += d / l : e += d * Math.pow(2, 1 - u), e * l >= 2 && (o++, l /= 2), o + u >= c ? (a = 0, o = c) : o + u >= 1 ? (a = (e * l - 1) * Math.pow(2, s), o = o + u) : (a = e * Math.pow(2, u - 1) * Math.pow(2, s), o = 0)); s >= 8; n[t + f] = a & 255, f += g, a /= 256, s -= 8)
    ;
  for (o = o << s | a, h += s; h > 0; n[t + f] = o & 255, f += g, o /= 256, h -= 8)
    ;
  n[t + f - g] |= _ * 128;
};
var fx = ne, Sr = oh;
function ne(n) {
  this.buf = ArrayBuffer.isView && ArrayBuffer.isView(n) ? n : new Uint8Array(n || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
}
ne.Varint = 0;
ne.Fixed64 = 1;
ne.Bytes = 2;
ne.Fixed32 = 5;
var Ka = 65536 * 65536, Sc = 1 / Ka, gx = 12, Bd = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
ne.prototype = {
  destroy: function() {
    this.buf = null;
  },
  // === READING =================================================================
  readFields: function(n, e, t) {
    for (t = t || this.length; this.pos < t; ) {
      var i = this.readVarint(), s = i >> 3, r = this.pos;
      this.type = i & 7, n(s, e, this), this.pos === r && this.skip(i);
    }
    return e;
  },
  readMessage: function(n, e) {
    return this.readFields(n, e, this.readVarint() + this.pos);
  },
  readFixed32: function() {
    var n = vr(this.buf, this.pos);
    return this.pos += 4, n;
  },
  readSFixed32: function() {
    var n = Tc(this.buf, this.pos);
    return this.pos += 4, n;
  },
  // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
  readFixed64: function() {
    var n = vr(this.buf, this.pos) + vr(this.buf, this.pos + 4) * Ka;
    return this.pos += 8, n;
  },
  readSFixed64: function() {
    var n = vr(this.buf, this.pos) + Tc(this.buf, this.pos + 4) * Ka;
    return this.pos += 8, n;
  },
  readFloat: function() {
    var n = Sr.read(this.buf, this.pos, !0, 23, 4);
    return this.pos += 4, n;
  },
  readDouble: function() {
    var n = Sr.read(this.buf, this.pos, !0, 52, 8);
    return this.pos += 8, n;
  },
  readVarint: function(n) {
    var e = this.buf, t, i;
    return i = e[this.pos++], t = i & 127, i < 128 || (i = e[this.pos++], t |= (i & 127) << 7, i < 128) || (i = e[this.pos++], t |= (i & 127) << 14, i < 128) || (i = e[this.pos++], t |= (i & 127) << 21, i < 128) ? t : (i = e[this.pos], t |= (i & 15) << 28, _x(t, n, this));
  },
  readVarint64: function() {
    return this.readVarint(!0);
  },
  readSVarint: function() {
    var n = this.readVarint();
    return n % 2 === 1 ? (n + 1) / -2 : n / 2;
  },
  readBoolean: function() {
    return !!this.readVarint();
  },
  readString: function() {
    var n = this.readVarint() + this.pos, e = this.pos;
    return this.pos = n, n - e >= gx && Bd ? Lx(this.buf, e, n) : Px(this.buf, e, n);
  },
  readBytes: function() {
    var n = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, n);
    return this.pos = n, e;
  },
  // verbose for performance reasons; doesn't affect gzipped size
  readPackedVarint: function(n, e) {
    if (this.type !== ne.Bytes)
      return n.push(this.readVarint(e));
    var t = jt(this);
    for (n = n || []; this.pos < t; )
      n.push(this.readVarint(e));
    return n;
  },
  readPackedSVarint: function(n) {
    if (this.type !== ne.Bytes)
      return n.push(this.readSVarint());
    var e = jt(this);
    for (n = n || []; this.pos < e; )
      n.push(this.readSVarint());
    return n;
  },
  readPackedBoolean: function(n) {
    if (this.type !== ne.Bytes)
      return n.push(this.readBoolean());
    var e = jt(this);
    for (n = n || []; this.pos < e; )
      n.push(this.readBoolean());
    return n;
  },
  readPackedFloat: function(n) {
    if (this.type !== ne.Bytes)
      return n.push(this.readFloat());
    var e = jt(this);
    for (n = n || []; this.pos < e; )
      n.push(this.readFloat());
    return n;
  },
  readPackedDouble: function(n) {
    if (this.type !== ne.Bytes)
      return n.push(this.readDouble());
    var e = jt(this);
    for (n = n || []; this.pos < e; )
      n.push(this.readDouble());
    return n;
  },
  readPackedFixed32: function(n) {
    if (this.type !== ne.Bytes)
      return n.push(this.readFixed32());
    var e = jt(this);
    for (n = n || []; this.pos < e; )
      n.push(this.readFixed32());
    return n;
  },
  readPackedSFixed32: function(n) {
    if (this.type !== ne.Bytes)
      return n.push(this.readSFixed32());
    var e = jt(this);
    for (n = n || []; this.pos < e; )
      n.push(this.readSFixed32());
    return n;
  },
  readPackedFixed64: function(n) {
    if (this.type !== ne.Bytes)
      return n.push(this.readFixed64());
    var e = jt(this);
    for (n = n || []; this.pos < e; )
      n.push(this.readFixed64());
    return n;
  },
  readPackedSFixed64: function(n) {
    if (this.type !== ne.Bytes)
      return n.push(this.readSFixed64());
    var e = jt(this);
    for (n = n || []; this.pos < e; )
      n.push(this.readSFixed64());
    return n;
  },
  skip: function(n) {
    var e = n & 7;
    if (e === ne.Varint)
      for (; this.buf[this.pos++] > 127; )
        ;
    else if (e === ne.Bytes)
      this.pos = this.readVarint() + this.pos;
    else if (e === ne.Fixed32)
      this.pos += 4;
    else if (e === ne.Fixed64)
      this.pos += 8;
    else
      throw new Error("Unimplemented type: " + e);
  },
  // === WRITING =================================================================
  writeTag: function(n, e) {
    this.writeVarint(n << 3 | e);
  },
  realloc: function(n) {
    for (var e = this.length || 16; e < this.pos + n; )
      e *= 2;
    if (e !== this.length) {
      var t = new Uint8Array(e);
      t.set(this.buf), this.buf = t, this.length = e;
    }
  },
  finish: function() {
    return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
  },
  writeFixed32: function(n) {
    this.realloc(4), _n(this.buf, n, this.pos), this.pos += 4;
  },
  writeSFixed32: function(n) {
    this.realloc(4), _n(this.buf, n, this.pos), this.pos += 4;
  },
  writeFixed64: function(n) {
    this.realloc(8), _n(this.buf, n & -1, this.pos), _n(this.buf, Math.floor(n * Sc), this.pos + 4), this.pos += 8;
  },
  writeSFixed64: function(n) {
    this.realloc(8), _n(this.buf, n & -1, this.pos), _n(this.buf, Math.floor(n * Sc), this.pos + 4), this.pos += 8;
  },
  writeVarint: function(n) {
    if (n = +n || 0, n > 268435455 || n < 0) {
      mx(n, this);
      return;
    }
    this.realloc(4), this.buf[this.pos++] = n & 127 | (n > 127 ? 128 : 0), !(n <= 127) && (this.buf[this.pos++] = (n >>>= 7) & 127 | (n > 127 ? 128 : 0), !(n <= 127) && (this.buf[this.pos++] = (n >>>= 7) & 127 | (n > 127 ? 128 : 0), !(n <= 127) && (this.buf[this.pos++] = n >>> 7 & 127)));
  },
  writeSVarint: function(n) {
    this.writeVarint(n < 0 ? -n * 2 - 1 : n * 2);
  },
  writeBoolean: function(n) {
    this.writeVarint(!!n);
  },
  writeString: function(n) {
    n = String(n), this.realloc(n.length * 4), this.pos++;
    var e = this.pos;
    this.pos = bx(this.buf, n, this.pos);
    var t = this.pos - e;
    t >= 128 && vc(e, t, this), this.pos = e - 1, this.writeVarint(t), this.pos += t;
  },
  writeFloat: function(n) {
    this.realloc(4), Sr.write(this.buf, n, this.pos, !0, 23, 4), this.pos += 4;
  },
  writeDouble: function(n) {
    this.realloc(8), Sr.write(this.buf, n, this.pos, !0, 52, 8), this.pos += 8;
  },
  writeBytes: function(n) {
    var e = n.length;
    this.writeVarint(e), this.realloc(e);
    for (var t = 0; t < e; t++)
      this.buf[this.pos++] = n[t];
  },
  writeRawMessage: function(n, e) {
    this.pos++;
    var t = this.pos;
    n(e, this);
    var i = this.pos - t;
    i >= 128 && vc(t, i, this), this.pos = t - 1, this.writeVarint(i), this.pos += i;
  },
  writeMessage: function(n, e, t) {
    this.writeTag(n, ne.Bytes), this.writeRawMessage(e, t);
  },
  writePackedVarint: function(n, e) {
    e.length && this.writeMessage(n, xx, e);
  },
  writePackedSVarint: function(n, e) {
    e.length && this.writeMessage(n, Ex, e);
  },
  writePackedBoolean: function(n, e) {
    e.length && this.writeMessage(n, Sx, e);
  },
  writePackedFloat: function(n, e) {
    e.length && this.writeMessage(n, Cx, e);
  },
  writePackedDouble: function(n, e) {
    e.length && this.writeMessage(n, wx, e);
  },
  writePackedFixed32: function(n, e) {
    e.length && this.writeMessage(n, vx, e);
  },
  writePackedSFixed32: function(n, e) {
    e.length && this.writeMessage(n, Tx, e);
  },
  writePackedFixed64: function(n, e) {
    e.length && this.writeMessage(n, Rx, e);
  },
  writePackedSFixed64: function(n, e) {
    e.length && this.writeMessage(n, Ix, e);
  },
  writeBytesField: function(n, e) {
    this.writeTag(n, ne.Bytes), this.writeBytes(e);
  },
  writeFixed32Field: function(n, e) {
    this.writeTag(n, ne.Fixed32), this.writeFixed32(e);
  },
  writeSFixed32Field: function(n, e) {
    this.writeTag(n, ne.Fixed32), this.writeSFixed32(e);
  },
  writeFixed64Field: function(n, e) {
    this.writeTag(n, ne.Fixed64), this.writeFixed64(e);
  },
  writeSFixed64Field: function(n, e) {
    this.writeTag(n, ne.Fixed64), this.writeSFixed64(e);
  },
  writeVarintField: function(n, e) {
    this.writeTag(n, ne.Varint), this.writeVarint(e);
  },
  writeSVarintField: function(n, e) {
    this.writeTag(n, ne.Varint), this.writeSVarint(e);
  },
  writeStringField: function(n, e) {
    this.writeTag(n, ne.Bytes), this.writeString(e);
  },
  writeFloatField: function(n, e) {
    this.writeTag(n, ne.Fixed32), this.writeFloat(e);
  },
  writeDoubleField: function(n, e) {
    this.writeTag(n, ne.Fixed64), this.writeDouble(e);
  },
  writeBooleanField: function(n, e) {
    this.writeVarintField(n, !!e);
  }
};
function _x(n, e, t) {
  var i = t.buf, s, r;
  if (r = i[t.pos++], s = (r & 112) >> 4, r < 128 || (r = i[t.pos++], s |= (r & 127) << 3, r < 128) || (r = i[t.pos++], s |= (r & 127) << 10, r < 128) || (r = i[t.pos++], s |= (r & 127) << 17, r < 128) || (r = i[t.pos++], s |= (r & 127) << 24, r < 128) || (r = i[t.pos++], s |= (r & 1) << 31, r < 128))
    return gn(n, s, e);
  throw new Error("Expected varint not more than 10 bytes");
}
function jt(n) {
  return n.type === ne.Bytes ? n.readVarint() + n.pos : n.pos + 1;
}
function gn(n, e, t) {
  return t ? e * 4294967296 + (n >>> 0) : (e >>> 0) * 4294967296 + (n >>> 0);
}
function mx(n, e) {
  var t, i;
  if (n >= 0 ? (t = n % 4294967296 | 0, i = n / 4294967296 | 0) : (t = ~(-n % 4294967296), i = ~(-n / 4294967296), t ^ 4294967295 ? t = t + 1 | 0 : (t = 0, i = i + 1 | 0)), n >= 18446744073709552e3 || n < -18446744073709552e3)
    throw new Error("Given varint doesn't fit into 10 bytes");
  e.realloc(10), px(t, i, e), yx(i, e);
}
function px(n, e, t) {
  t.buf[t.pos++] = n & 127 | 128, n >>>= 7, t.buf[t.pos++] = n & 127 | 128, n >>>= 7, t.buf[t.pos++] = n & 127 | 128, n >>>= 7, t.buf[t.pos++] = n & 127 | 128, n >>>= 7, t.buf[t.pos] = n & 127;
}
function yx(n, e) {
  var t = (n & 7) << 4;
  e.buf[e.pos++] |= t | ((n >>>= 3) ? 128 : 0), n && (e.buf[e.pos++] = n & 127 | ((n >>>= 7) ? 128 : 0), n && (e.buf[e.pos++] = n & 127 | ((n >>>= 7) ? 128 : 0), n && (e.buf[e.pos++] = n & 127 | ((n >>>= 7) ? 128 : 0), n && (e.buf[e.pos++] = n & 127 | ((n >>>= 7) ? 128 : 0), n && (e.buf[e.pos++] = n & 127)))));
}
function vc(n, e, t) {
  var i = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (Math.LN2 * 7));
  t.realloc(i);
  for (var s = t.pos - 1; s >= n; s--)
    t.buf[s + i] = t.buf[s];
}
function xx(n, e) {
  for (var t = 0; t < n.length; t++)
    e.writeVarint(n[t]);
}
function Ex(n, e) {
  for (var t = 0; t < n.length; t++)
    e.writeSVarint(n[t]);
}
function Cx(n, e) {
  for (var t = 0; t < n.length; t++)
    e.writeFloat(n[t]);
}
function wx(n, e) {
  for (var t = 0; t < n.length; t++)
    e.writeDouble(n[t]);
}
function Sx(n, e) {
  for (var t = 0; t < n.length; t++)
    e.writeBoolean(n[t]);
}
function vx(n, e) {
  for (var t = 0; t < n.length; t++)
    e.writeFixed32(n[t]);
}
function Tx(n, e) {
  for (var t = 0; t < n.length; t++)
    e.writeSFixed32(n[t]);
}
function Rx(n, e) {
  for (var t = 0; t < n.length; t++)
    e.writeFixed64(n[t]);
}
function Ix(n, e) {
  for (var t = 0; t < n.length; t++)
    e.writeSFixed64(n[t]);
}
function vr(n, e) {
  return (n[e] | n[e + 1] << 8 | n[e + 2] << 16) + n[e + 3] * 16777216;
}
function _n(n, e, t) {
  n[t] = e, n[t + 1] = e >>> 8, n[t + 2] = e >>> 16, n[t + 3] = e >>> 24;
}
function Tc(n, e) {
  return (n[e] | n[e + 1] << 8 | n[e + 2] << 16) + (n[e + 3] << 24);
}
function Px(n, e, t) {
  for (var i = "", s = e; s < t; ) {
    var r = n[s], o = null, a = r > 239 ? 4 : r > 223 ? 3 : r > 191 ? 2 : 1;
    if (s + a > t)
      break;
    var l, h, c;
    a === 1 ? r < 128 && (o = r) : a === 2 ? (l = n[s + 1], (l & 192) === 128 && (o = (r & 31) << 6 | l & 63, o <= 127 && (o = null))) : a === 3 ? (l = n[s + 1], h = n[s + 2], (l & 192) === 128 && (h & 192) === 128 && (o = (r & 15) << 12 | (l & 63) << 6 | h & 63, (o <= 2047 || o >= 55296 && o <= 57343) && (o = null))) : a === 4 && (l = n[s + 1], h = n[s + 2], c = n[s + 3], (l & 192) === 128 && (h & 192) === 128 && (c & 192) === 128 && (o = (r & 15) << 18 | (l & 63) << 12 | (h & 63) << 6 | c & 63, (o <= 65535 || o >= 1114112) && (o = null))), o === null ? (o = 65533, a = 1) : o > 65535 && (o -= 65536, i += String.fromCharCode(o >>> 10 & 1023 | 55296), o = 56320 | o & 1023), i += String.fromCharCode(o), s += a;
  }
  return i;
}
function Lx(n, e, t) {
  return Bd.decode(n.subarray(e, t));
}
function bx(n, e, t) {
  for (var i = 0, s, r; i < e.length; i++) {
    if (s = e.charCodeAt(i), s > 55295 && s < 57344)
      if (r)
        if (s < 56320) {
          n[t++] = 239, n[t++] = 191, n[t++] = 189, r = s;
          continue;
        } else
          s = r - 55296 << 10 | s - 56320 | 65536, r = null;
      else {
        s > 56319 || i + 1 === e.length ? (n[t++] = 239, n[t++] = 191, n[t++] = 189) : r = s;
        continue;
      }
    else
      r && (n[t++] = 239, n[t++] = 191, n[t++] = 189, r = null);
    s < 128 ? n[t++] = s : (s < 2048 ? n[t++] = s >> 6 | 192 : (s < 65536 ? n[t++] = s >> 12 | 224 : (n[t++] = s >> 18 | 240, n[t++] = s >> 12 & 63 | 128), n[t++] = s >> 6 & 63 | 128), n[t++] = s & 63 | 128);
  }
  return t;
}
const Ax = /* @__PURE__ */ Gu(fx);
class Fx extends Ql {
  /**
   * @param {Options<T>} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.dataProjection = new sl({
      code: "",
      units: "tile-pixels"
    }), this.featureClass_ = e.featureClass ? e.featureClass : mt, this.geometryName_ = e.geometryName, this.layerName_ = e.layerName ? e.layerName : "layer", this.layers_ = e.layers ? e.layers : null, this.idProperty_ = e.idProperty, this.supportedMediaTypes = [
      "application/vnd.mapbox-vector-tile",
      "application/x-protobuf"
    ];
  }
  /**
   * Read the raw geometry from the pbf offset stored in a raw feature's geometry
   * property.
   * @param {PBF} pbf PBF.
   * @param {Object} feature Raw feature.
   * @param {Array<number>} flatCoordinates Array to store flat coordinates in.
   * @param {Array<number>} ends Array to store ends in.
   * @private
   */
  readRawGeometry_(e, t, i, s) {
    e.pos = t.geometry;
    const r = e.readVarint() + e.pos;
    let o = 1, a = 0, l = 0, h = 0, c = 0, u = 0;
    for (; e.pos < r; ) {
      if (!a) {
        const d = e.readVarint();
        o = d & 7, a = d >> 3;
      }
      if (a--, o === 1 || o === 2)
        l += e.readSVarint(), h += e.readSVarint(), o === 1 && c > u && (s.push(c), u = c), i.push(l, h), c += 2;
      else if (o === 7)
        c > u && (i.push(
          i[u],
          i[u + 1]
        ), c += 2);
      else
        throw new Error("Invalid command found in the PBF");
    }
    c > u && (s.push(c), u = c);
  }
  /**
   * @private
   * @param {PBF} pbf PBF
   * @param {Object} rawFeature Raw Mapbox feature.
   * @param {import("./Feature.js").ReadOptions} options Read options.
   * @return {import("../Feature.js").FeatureLike|null} Feature.
   */
  createFeature_(e, t, i) {
    const s = t.type;
    if (s === 0)
      return null;
    let r;
    const o = t.properties;
    let a;
    this.idProperty_ ? (a = o[this.idProperty_], delete o[this.idProperty_]) : a = t.id, o[this.layerName_] = t.layer.name;
    const l = (
      /** @type {Array<number>} */
      []
    ), h = (
      /** @type {Array<number>} */
      []
    );
    this.readRawGeometry_(e, t, l, h);
    const c = kx(s, h.length);
    if (this.featureClass_ === mt)
      r = new this.featureClass_(
        c,
        l,
        h,
        2,
        o,
        a
      ), r.transform(i.dataProjection);
    else {
      let u;
      if (c == "Polygon") {
        const g = Mu(l, h);
        u = g.length > 1 ? new is(l, "XY", g) : new Ne(l, "XY", h);
      } else
        u = c === "Point" ? new lt(l, "XY") : c === "LineString" ? new ht(l, "XY") : c === "MultiPoint" ? new ts(l, "XY") : c === "MultiLineString" ? new an(l, "XY", h) : null;
      const d = (
        /** @type {typeof import("../Feature.js").default} */
        this.featureClass_
      );
      r = new d(), this.geometryName_ && r.setGeometryName(this.geometryName_);
      const f = ln(u, !1, i);
      r.setGeometry(f), a !== void 0 && r.setId(a), r.setProperties(o, !0);
    }
    return r;
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return "arraybuffer";
  }
  /**
   * Read all features.
   *
   * @param {ArrayBuffer} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import('./Feature.js').FeatureClassToFeature<T>>} Features.
   * @api
   */
  readFeatures(e, t) {
    const i = this.layers_;
    t = this.adaptOptions(t);
    const s = ce(t.dataProjection);
    s.setWorldExtent(t.extent), t.dataProjection = s;
    const r = new Ax(
      /** @type {ArrayBuffer} */
      e
    ), o = r.readFields(Mx, {}), a = [];
    for (const l in o) {
      if (i && !i.includes(l))
        continue;
      const h = o[l], c = h ? [0, 0, h.extent, h.extent] : null;
      s.setExtent(c);
      for (let u = 0, d = h.length; u < d; ++u) {
        const f = Nx(r, h, u), g = this.createFeature_(r, f, t);
        g !== null && a.push(g);
      }
    }
    return (
      /** @type {Array<import('./Feature.js').FeatureClassToFeature<T>>} */
      a
    );
  }
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  readProjection(e) {
    return this.dataProjection;
  }
  /**
   * Sets the layers that features will be read from.
   * @param {Array<string>} layers Layers.
   * @api
   */
  setLayers(e) {
    this.layers_ = e;
  }
}
function Mx(n, e, t) {
  if (n === 3) {
    const i = {
      keys: [],
      values: [],
      features: []
    }, s = t.readVarint() + t.pos;
    t.readFields(Ox, i, s), i.length = i.features.length, i.length && (e[i.name] = i);
  }
}
function Ox(n, e, t) {
  if (n === 15)
    e.version = t.readVarint();
  else if (n === 1)
    e.name = t.readString();
  else if (n === 5)
    e.extent = t.readVarint();
  else if (n === 2)
    e.features.push(t.pos);
  else if (n === 3)
    e.keys.push(t.readString());
  else if (n === 4) {
    let i = null;
    const s = t.readVarint() + t.pos;
    for (; t.pos < s; )
      n = t.readVarint() >> 3, i = n === 1 ? t.readString() : n === 2 ? t.readFloat() : n === 3 ? t.readDouble() : n === 4 ? t.readVarint64() : n === 5 ? t.readVarint() : n === 6 ? t.readSVarint() : n === 7 ? t.readBoolean() : null;
    e.values.push(i);
  }
}
function Dx(n, e, t) {
  if (n == 1)
    e.id = t.readVarint();
  else if (n == 2) {
    const i = t.readVarint() + t.pos;
    for (; t.pos < i; ) {
      const s = e.layer.keys[t.readVarint()], r = e.layer.values[t.readVarint()];
      e.properties[s] = r;
    }
  } else
    n == 3 ? e.type = t.readVarint() : n == 4 && (e.geometry = t.pos);
}
function Nx(n, e, t) {
  n.pos = e.features[t];
  const i = n.readVarint() + n.pos, s = {
    layer: e,
    type: 0,
    properties: {}
  };
  return n.readFields(Dx, s, i), s;
}
function kx(n, e) {
  let t;
  return n === 1 ? t = e === 1 ? "Point" : "MultiPoint" : n === 2 ? t = e === 1 ? "LineString" : "MultiLineString" : n === 3 && (t = "Polygon"), t;
}
const Gx = Fx;
class zx extends Sd {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.layerName_ = e.layerName, this.layers_ = e.layers ? e.layers : null, this.dataProjection = ce(
      e.dataProjection ? e.dataProjection : "EPSG:4326"
    );
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */
  readFeaturesFromObject(e, t) {
    if (e.type == "Topology") {
      const i = (
        /** @type {TopoJSONTopology} */
        e
      );
      let s, r = null, o = null;
      i.transform && (s = i.transform, r = s.scale, o = s.translate);
      const a = i.arcs;
      s && Kx(a, r, o);
      const l = [], h = i.objects, c = this.layerName_;
      let u;
      for (const d in h)
        this.layers_ && !this.layers_.includes(d) || (h[d].type === "GeometryCollection" ? (u = /** @type {TopoJSONGeometryCollection} */
        h[d], l.push.apply(
          l,
          Wx(
            u,
            a,
            r,
            o,
            c,
            d,
            t
          )
        )) : (u = /** @type {TopoJSONGeometry} */
        h[d], l.push(
          Wd(
            u,
            a,
            r,
            o,
            c,
            d,
            t
          )
        )));
      return l;
    }
    return [];
  }
  /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(e) {
    return this.dataProjection;
  }
}
const $x = {
  Point: Ux,
  LineString: jx,
  Polygon: Xx,
  MultiPoint: Vx,
  MultiLineString: Yx,
  MultiPolygon: Bx
};
function Oo(n, e) {
  const t = [];
  let i;
  for (let s = 0, r = n.length; s < r; ++s)
    if (i = n[s], s > 0 && t.pop(), i >= 0) {
      const o = e[i];
      for (let a = 0, l = o.length; a < l; ++a)
        t.push(o[a].slice(0));
    } else {
      const o = e[~i];
      for (let a = o.length - 1; a >= 0; --a)
        t.push(o[a].slice(0));
    }
  return t;
}
function Ux(n, e, t) {
  const i = n.coordinates;
  return e && t && ah(i, e, t), new lt(i);
}
function Vx(n, e, t) {
  const i = n.coordinates;
  if (e && t)
    for (let s = 0, r = i.length; s < r; ++s)
      ah(i[s], e, t);
  return new ts(i);
}
function jx(n, e) {
  const t = Oo(n.arcs, e);
  return new ht(t);
}
function Yx(n, e) {
  const t = [];
  for (let i = 0, s = n.arcs.length; i < s; ++i)
    t[i] = Oo(n.arcs[i], e);
  return new an(t);
}
function Xx(n, e) {
  const t = [];
  for (let i = 0, s = n.arcs.length; i < s; ++i)
    t[i] = Oo(n.arcs[i], e);
  return new Ne(t);
}
function Bx(n, e) {
  const t = [];
  for (let i = 0, s = n.arcs.length; i < s; ++i) {
    const r = n.arcs[i], o = [];
    for (let a = 0, l = r.length; a < l; ++a)
      o[a] = Oo(r[a], e);
    t[i] = o;
  }
  return new is(t);
}
function Wx(n, e, t, i, s, r, o) {
  const a = n.geometries, l = [];
  for (let h = 0, c = a.length; h < c; ++h)
    l[h] = Wd(
      a[h],
      e,
      t,
      i,
      s,
      r,
      o
    );
  return l;
}
function Wd(n, e, t, i, s, r, o) {
  let a = null;
  const l = n.type;
  if (l) {
    const u = $x[l];
    l === "Point" || l === "MultiPoint" ? a = u(n, t, i) : a = u(n, e), a = ln(a, !1, o);
  }
  const h = new yt({ geometry: a });
  n.id !== void 0 && h.setId(n.id);
  let c = n.properties;
  return s && (c || (c = {}), c[s] = r), c && h.setProperties(c, !0), h;
}
function Kx(n, e, t) {
  for (let i = 0, s = n.length; i < s; ++i)
    Zx(n[i], e, t);
}
function Zx(n, e, t) {
  let i = 0, s = 0;
  for (let r = 0, o = n.length; r < o; ++r) {
    const a = n[r];
    i += a[0], s += a[1], a[0] = i, a[1] = s, ah(a, e, t);
  }
}
function ah(n, e, t) {
  n[0] = n[0] * e[0] + t[0], n[1] = n[1] * e[1] + t[1];
}
const Hx = zx, or = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
}, Tr = [or.FILL], Ti = [or.STROKE], Zi = [or.BEGIN_PATH], Rc = [or.CLOSE_PATH], X = or;
class qx {
  /**
   * Render a geometry with a custom renderer.
   *
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   * @param {number} [index] Render order index.
   */
  drawCustom(e, t, i, s, r) {
  }
  /**
   * Render a geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
   */
  drawGeometry(e) {
  }
  /**
   * Set the rendering style.
   *
   * @param {import("../style/Style.js").default} style The rendering style.
   */
  setStyle(e) {
  }
  /**
   * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawCircle(e, t, i) {
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   * @param {number} [index] Render order index.
   */
  drawFeature(e, t, i) {
  }
  /**
   * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawGeometryCollection(e, t, i) {
  }
  /**
   * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawLineString(e, t, i) {
  }
  /**
   * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiLineString(e, t, i) {
  }
  /**
   * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPoint(e, t, i) {
  }
  /**
   * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPolygon(e, t, i) {
  }
  /**
   * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPoint(e, t, i) {
  }
  /**
   * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPolygon(e, t, i) {
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawText(e, t, i) {
  }
  /**
   * @param {import("../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(e, t) {
  }
  /**
   * @param {import("../style/Image.js").default} imageStyle Image style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
   */
  setImageStyle(e, t) {
  }
  /**
   * @param {import("../style/Text.js").default} textStyle Text style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
   */
  setTextStyle(e, t) {
  }
}
const Kd = qx;
class Jx extends Kd {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, i, s) {
    super(), this.tolerance = e, this.maxExtent = t, this.pixelRatio = s, this.maxLineWidth = 0, this.resolution = i, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_ = null, this.bufferedMaxExtent_ = null, this.instructions = [], this.coordinates = [], this.tmpCoordinate_ = [], this.hitDetectionInstructions = [], this.state = /** @type {import("../canvas.js").FillStrokeState} */
    {};
  }
  /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */
  applyPixelRatio(e) {
    const t = this.pixelRatio;
    return t == 1 ? e : e.map(function(i) {
      return i * t;
    });
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} stride Stride.
   * @protected
   * @return {number} My end
   */
  appendFlatPointCoordinates(e, t) {
    const i = this.getBufferedMaxExtent(), s = this.tmpCoordinate_, r = this.coordinates;
    let o = r.length;
    for (let a = 0, l = e.length; a < l; a += t)
      s[0] = e[a], s[1] = e[a + 1], Qi(i, s) && (r[o++] = s[0], r[o++] = s[1]);
    return o;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */
  appendFlatLineCoordinates(e, t, i, s, r, o) {
    const a = this.coordinates;
    let l = a.length;
    const h = this.getBufferedMaxExtent();
    o && (t += s);
    let c = e[t], u = e[t + 1];
    const d = this.tmpCoordinate_;
    let f = !0, g, _, m;
    for (g = t + s; g < i; g += s)
      d[0] = e[g], d[1] = e[g + 1], m = Ia(h, d), m !== _ ? (f && (a[l++] = c, a[l++] = u, f = !1), a[l++] = d[0], a[l++] = d[1]) : m === Re.INTERSECTING ? (a[l++] = d[0], a[l++] = d[1], f = !1) : f = !0, c = d[0], u = d[1], _ = m;
    return (r && f || g === t + s) && (a[l++] = c, a[l++] = u), l;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} builderEnds Builder ends.
   * @return {number} Offset.
   */
  drawCustomCoordinates_(e, t, i, s, r) {
    for (let o = 0, a = i.length; o < a; ++o) {
      const l = i[o], h = this.appendFlatLineCoordinates(
        e,
        t,
        l,
        s,
        !1,
        !1
      );
      r.push(h), t = l;
    }
    return t;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   * @param {number} [index] Render order index.
   */
  drawCustom(e, t, i, s, r) {
    this.beginGeometry(e, t, r);
    const o = e.getType(), a = e.getStride(), l = this.coordinates.length;
    let h, c, u, d, f;
    switch (o) {
      case "MultiPolygon":
        h = /** @type {import("../../geom/MultiPolygon.js").default} */
        e.getOrientedFlatCoordinates(), d = [];
        const g = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e.getEndss()
        );
        f = 0;
        for (let _ = 0, m = g.length; _ < m; ++_) {
          const p = [];
          f = this.drawCustomCoordinates_(
            h,
            f,
            g[_],
            a,
            p
          ), d.push(p);
        }
        this.instructions.push([
          X.CUSTOM,
          l,
          d,
          e,
          i,
          Fa,
          r
        ]), this.hitDetectionInstructions.push([
          X.CUSTOM,
          l,
          d,
          e,
          s || i,
          Fa,
          r
        ]);
        break;
      case "Polygon":
      case "MultiLineString":
        u = [], h = o == "Polygon" ? (
          /** @type {import("../../geom/Polygon.js").default} */
          e.getOrientedFlatCoordinates()
        ) : e.getFlatCoordinates(), f = this.drawCustomCoordinates_(
          h,
          0,
          /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
          e.getEnds(),
          a,
          u
        ), this.instructions.push([
          X.CUSTOM,
          l,
          u,
          e,
          i,
          Ds,
          r
        ]), this.hitDetectionInstructions.push([
          X.CUSTOM,
          l,
          u,
          e,
          s || i,
          Ds,
          r
        ]);
        break;
      case "LineString":
      case "Circle":
        h = e.getFlatCoordinates(), c = this.appendFlatLineCoordinates(
          h,
          0,
          h.length,
          a,
          !1,
          !1
        ), this.instructions.push([
          X.CUSTOM,
          l,
          c,
          e,
          i,
          Ei,
          r
        ]), this.hitDetectionInstructions.push([
          X.CUSTOM,
          l,
          c,
          e,
          s || i,
          Ei,
          r
        ]);
        break;
      case "MultiPoint":
        h = e.getFlatCoordinates(), c = this.appendFlatPointCoordinates(h, a), c > l && (this.instructions.push([
          X.CUSTOM,
          l,
          c,
          e,
          i,
          Ei,
          r
        ]), this.hitDetectionInstructions.push([
          X.CUSTOM,
          l,
          c,
          e,
          s || i,
          Ei,
          r
        ]));
        break;
      case "Point":
        h = e.getFlatCoordinates(), this.coordinates.push(h[0], h[1]), c = this.coordinates.length, this.instructions.push([
          X.CUSTOM,
          l,
          c,
          e,
          i,
          void 0,
          r
        ]), this.hitDetectionInstructions.push([
          X.CUSTOM,
          l,
          c,
          e,
          s || i,
          void 0,
          r
        ]);
        break;
    }
    this.endGeometry(t);
  }
  /**
   * @protected
   * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} index Render order index
   */
  beginGeometry(e, t, i) {
    this.beginGeometryInstruction1_ = [
      X.BEGIN_GEOMETRY,
      t,
      0,
      e,
      i
    ], this.instructions.push(this.beginGeometryInstruction1_), this.beginGeometryInstruction2_ = [
      X.BEGIN_GEOMETRY,
      t,
      0,
      e,
      i
    ], this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return {
      instructions: this.instructions,
      hitDetectionInstructions: this.hitDetectionInstructions,
      coordinates: this.coordinates
    };
  }
  /**
   * Reverse the hit detection instructions.
   */
  reverseHitDetectionInstructions() {
    const e = this.hitDetectionInstructions;
    e.reverse();
    let t;
    const i = e.length;
    let s, r, o = -1;
    for (t = 0; t < i; ++t)
      s = e[t], r = /** @type {import("./Instruction.js").default} */
      s[0], r == X.END_GEOMETRY ? o = t : r == X.BEGIN_GEOMETRY && (s[2] = t, dg(this.hitDetectionInstructions, o, t), o = -1);
  }
  /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(e, t) {
    const i = this.state;
    if (e) {
      const s = e.getColor();
      i.fillPatternScale = s && typeof s == "object" && "src" in s ? this.pixelRatio : 1, i.fillStyle = At(
        s || Ye
      );
    } else
      i.fillStyle = void 0;
    if (t) {
      const s = t.getColor();
      i.strokeStyle = At(
        s || Gs
      );
      const r = t.getLineCap();
      i.lineCap = r !== void 0 ? r : Xn;
      const o = t.getLineDash();
      i.lineDash = o ? o.slice() : Jt;
      const a = t.getLineDashOffset();
      i.lineDashOffset = a || Qt;
      const l = t.getLineJoin();
      i.lineJoin = l !== void 0 ? l : Bn;
      const h = t.getWidth();
      i.lineWidth = h !== void 0 ? h : $s;
      const c = t.getMiterLimit();
      i.miterLimit = c !== void 0 ? c : ks, i.lineWidth > this.maxLineWidth && (this.maxLineWidth = i.lineWidth, this.bufferedMaxExtent_ = null);
    } else
      i.strokeStyle = void 0, i.lineCap = void 0, i.lineDash = null, i.lineDashOffset = void 0, i.lineJoin = void 0, i.lineWidth = void 0, i.miterLimit = void 0;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Fill instruction.
   */
  createFill(e) {
    const t = e.fillStyle, i = [X.SET_FILL_STYLE, t];
    return typeof t != "string" && i.push(e.fillPatternScale), i;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(e) {
    this.instructions.push(this.createStroke(e));
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */
  createStroke(e) {
    return [
      X.SET_STROKE_STYLE,
      e.strokeStyle,
      e.lineWidth * this.pixelRatio,
      e.lineCap,
      e.lineJoin,
      e.miterLimit,
      this.applyPixelRatio(e.lineDash),
      e.lineDashOffset * this.pixelRatio
    ];
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
   */
  updateFillStyle(e, t) {
    const i = e.fillStyle;
    (typeof i != "string" || e.currentFillStyle != i) && (i !== void 0 && this.instructions.push(t.call(this, e)), e.currentFillStyle = i);
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
   */
  updateStrokeStyle(e, t) {
    const i = e.strokeStyle, s = e.lineCap, r = e.lineDash, o = e.lineDashOffset, a = e.lineJoin, l = e.lineWidth, h = e.miterLimit;
    (e.currentStrokeStyle != i || e.currentLineCap != s || r != e.currentLineDash && !ri(e.currentLineDash, r) || e.currentLineDashOffset != o || e.currentLineJoin != a || e.currentLineWidth != l || e.currentMiterLimit != h) && (i !== void 0 && t.call(this, e), e.currentStrokeStyle = i, e.currentLineCap = s, e.currentLineDash = r, e.currentLineDashOffset = o, e.currentLineJoin = a, e.currentLineWidth = l, e.currentMiterLimit = h);
  }
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  endGeometry(e) {
    this.beginGeometryInstruction1_[2] = this.instructions.length, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length, this.beginGeometryInstruction2_ = null;
    const t = [X.END_GEOMETRY, e];
    this.instructions.push(t), this.hitDetectionInstructions.push(t);
  }
  /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */
  getBufferedMaxExtent() {
    if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = cu(this.maxExtent), this.maxLineWidth > 0)) {
      const e = this.resolution * (this.maxLineWidth + 1) / 2;
      ot(this.bufferedMaxExtent_, e, this.bufferedMaxExtent_);
    }
    return this.bufferedMaxExtent_;
  }
}
const ar = Jx;
class Qx extends ar {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, i, s) {
    super(e, t, i, s), this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.anchorX_ = void 0, this.anchorY_ = void 0, this.height_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.scale_ = void 0, this.width_ = void 0, this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
  }
  /**
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPoint(e, t, i) {
    if (!this.image_ || this.maxExtent && !Qi(this.maxExtent, e.getFlatCoordinates()))
      return;
    this.beginGeometry(e, t, i);
    const s = e.getFlatCoordinates(), r = e.getStride(), o = this.coordinates.length, a = this.appendFlatPointCoordinates(s, r);
    this.instructions.push([
      X.DRAW_IMAGE,
      o,
      a,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      X.DRAW_IMAGE,
      o,
      a,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPoint(e, t, i) {
    if (!this.image_)
      return;
    this.beginGeometry(e, t, i);
    const s = e.getFlatCoordinates(), r = [];
    for (let l = 0, h = s.length; l < h; l += e.getStride())
      (!this.maxExtent || Qi(this.maxExtent, s.slice(l, l + 2))) && r.push(
        s[l],
        s[l + 1]
      );
    const o = this.coordinates.length, a = this.appendFlatPointCoordinates(r, 2);
    this.instructions.push([
      X.DRAW_IMAGE,
      o,
      a,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      X.DRAW_IMAGE,
      o,
      a,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(t);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.width_ = void 0, super.finish();
  }
  /**
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @param {Object} [sharedData] Shared data.
   */
  setImageStyle(e, t) {
    const i = e.getAnchor(), s = e.getSize(), r = e.getOrigin();
    this.imagePixelRatio_ = e.getPixelRatio(this.pixelRatio), this.anchorX_ = i[0], this.anchorY_ = i[1], this.hitDetectionImage_ = e.getHitDetectionImage(), this.image_ = e.getImage(this.pixelRatio), this.height_ = s[1], this.opacity_ = e.getOpacity(), this.originX_ = r[0], this.originY_ = r[1], this.rotateWithView_ = e.getRotateWithView(), this.rotation_ = e.getRotation(), this.scale_ = e.getScaleArray(), this.width_ = s[0], this.declutterMode_ = e.getDeclutterMode(), this.declutterImageWithText_ = t;
  }
}
const eE = Qx;
class tE extends ar {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, i, s) {
    super(e, t, i, s);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */
  drawFlatCoordinates_(e, t, i, s) {
    const r = this.coordinates.length, o = this.appendFlatLineCoordinates(
      e,
      t,
      i,
      s,
      !1,
      !1
    ), a = [
      X.MOVE_TO_LINE_TO,
      r,
      o
    ];
    return this.instructions.push(a), this.hitDetectionInstructions.push(a), i;
  }
  /**
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawLineString(e, t, i) {
    const s = this.state, r = s.strokeStyle, o = s.lineWidth;
    if (r === void 0 || o === void 0)
      return;
    this.updateStrokeStyle(s, this.applyStroke), this.beginGeometry(e, t, i), this.hitDetectionInstructions.push(
      [
        X.SET_STROKE_STYLE,
        s.strokeStyle,
        s.lineWidth,
        s.lineCap,
        s.lineJoin,
        s.miterLimit,
        Jt,
        Qt
      ],
      Zi
    );
    const a = e.getFlatCoordinates(), l = e.getStride();
    this.drawFlatCoordinates_(
      a,
      0,
      a.length,
      l
    ), this.hitDetectionInstructions.push(Ti), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiLineString(e, t, i) {
    const s = this.state, r = s.strokeStyle, o = s.lineWidth;
    if (r === void 0 || o === void 0)
      return;
    this.updateStrokeStyle(s, this.applyStroke), this.beginGeometry(e, t, i), this.hitDetectionInstructions.push(
      [
        X.SET_STROKE_STYLE,
        s.strokeStyle,
        s.lineWidth,
        s.lineCap,
        s.lineJoin,
        s.miterLimit,
        Jt,
        Qt
      ],
      Zi
    );
    const a = e.getEnds(), l = e.getFlatCoordinates(), h = e.getStride();
    let c = 0;
    for (let u = 0, d = a.length; u < d; ++u)
      c = this.drawFlatCoordinates_(
        l,
        c,
        /** @type {number} */
        a[u],
        h
      );
    this.hitDetectionInstructions.push(Ti), this.endGeometry(t);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const e = this.state;
    return e.lastStroke != null && e.lastStroke != this.coordinates.length && this.instructions.push(Ti), this.reverseHitDetectionInstructions(), this.state = null, super.finish();
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(e) {
    e.lastStroke != null && e.lastStroke != this.coordinates.length && (this.instructions.push(Ti), e.lastStroke = this.coordinates.length), e.lastStroke = 0, super.applyStroke(e), this.instructions.push(Zi);
  }
}
const iE = tE;
class nE extends ar {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, i, s) {
    super(e, t, i, s);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawFlatCoordinatess_(e, t, i, s) {
    const r = this.state, o = r.fillStyle !== void 0, a = r.strokeStyle !== void 0, l = i.length;
    this.instructions.push(Zi), this.hitDetectionInstructions.push(Zi);
    for (let h = 0; h < l; ++h) {
      const c = i[h], u = this.coordinates.length, d = this.appendFlatLineCoordinates(
        e,
        t,
        c,
        s,
        !0,
        !a
      ), f = [
        X.MOVE_TO_LINE_TO,
        u,
        d
      ];
      this.instructions.push(f), this.hitDetectionInstructions.push(f), a && (this.instructions.push(Rc), this.hitDetectionInstructions.push(Rc)), t = c;
    }
    return o && (this.instructions.push(Tr), this.hitDetectionInstructions.push(Tr)), a && (this.instructions.push(Ti), this.hitDetectionInstructions.push(Ti)), t;
  }
  /**
   * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawCircle(e, t, i) {
    const s = this.state, r = s.fillStyle, o = s.strokeStyle;
    if (r === void 0 && o === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, t, i), s.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      X.SET_FILL_STYLE,
      Ye
    ]), s.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      X.SET_STROKE_STYLE,
      s.strokeStyle,
      s.lineWidth,
      s.lineCap,
      s.lineJoin,
      s.miterLimit,
      Jt,
      Qt
    ]);
    const a = e.getFlatCoordinates(), l = e.getStride(), h = this.coordinates.length;
    this.appendFlatLineCoordinates(
      a,
      0,
      a.length,
      l,
      !1,
      !1
    );
    const c = [X.CIRCLE, h];
    this.instructions.push(Zi, c), this.hitDetectionInstructions.push(Zi, c), s.fillStyle !== void 0 && (this.instructions.push(Tr), this.hitDetectionInstructions.push(Tr)), s.strokeStyle !== void 0 && (this.instructions.push(Ti), this.hitDetectionInstructions.push(Ti)), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPolygon(e, t, i) {
    const s = this.state, r = s.fillStyle, o = s.strokeStyle;
    if (r === void 0 && o === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, t, i), s.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      X.SET_FILL_STYLE,
      Ye
    ]), s.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      X.SET_STROKE_STYLE,
      s.strokeStyle,
      s.lineWidth,
      s.lineCap,
      s.lineJoin,
      s.miterLimit,
      Jt,
      Qt
    ]);
    const a = e.getEnds(), l = e.getOrientedFlatCoordinates(), h = e.getStride();
    this.drawFlatCoordinatess_(
      l,
      0,
      /** @type {Array<number>} */
      a,
      h
    ), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPolygon(e, t, i) {
    const s = this.state, r = s.fillStyle, o = s.strokeStyle;
    if (r === void 0 && o === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, t, i), s.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      X.SET_FILL_STYLE,
      Ye
    ]), s.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      X.SET_STROKE_STYLE,
      s.strokeStyle,
      s.lineWidth,
      s.lineCap,
      s.lineJoin,
      s.miterLimit,
      Jt,
      Qt
    ]);
    const a = e.getEndss(), l = e.getOrientedFlatCoordinates(), h = e.getStride();
    let c = 0;
    for (let u = 0, d = a.length; u < d; ++u)
      c = this.drawFlatCoordinatess_(
        l,
        c,
        a[u],
        h
      );
    this.endGeometry(t);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    this.reverseHitDetectionInstructions(), this.state = null;
    const e = this.tolerance;
    if (e !== 0) {
      const t = this.coordinates;
      for (let i = 0, s = t.length; i < s; ++i)
        t[i] = ji(t[i], e);
    }
    return super.finish();
  }
  /**
   * @private
   */
  setFillStrokeStyles_() {
    const e = this.state;
    e.fillStyle !== void 0 && this.updateFillStyle(e, this.createFill), e.strokeStyle !== void 0 && this.updateStrokeStyle(e, this.applyStroke);
  }
}
const Ic = nE;
function sE(n, e, t, i, s) {
  const r = [];
  let o = t, a = 0, l = e.slice(t, 2);
  for (; a < n && o + s < i; ) {
    const [h, c] = l.slice(-2), u = e[o + s], d = e[o + s + 1], f = Math.sqrt(
      (u - h) * (u - h) + (d - c) * (d - c)
    );
    if (a += f, a >= n) {
      const g = (n - a + f) / f, _ = He(h, u, g), m = He(c, d, g);
      l.push(_, m), r.push(l), l = [_, m], a == n && (o += s), a = 0;
    } else if (a < n)
      l.push(
        e[o + s],
        e[o + s + 1]
      ), o += s;
    else {
      const g = f - a, _ = He(h, u, g / f), m = He(c, d, g / f);
      l.push(_, m), r.push(l), l = [_, m], a = 0, o += s;
    }
  }
  return a > 0 && r.push(l), r;
}
function rE(n, e, t, i, s) {
  let r = t, o = t, a = 0, l = 0, h = t, c, u, d, f, g, _, m, p, y, x;
  for (u = t; u < i; u += s) {
    const E = e[u], C = e[u + 1];
    g !== void 0 && (y = E - g, x = C - _, f = Math.sqrt(y * y + x * x), m !== void 0 && (l += d, c = Math.acos((m * y + p * x) / (d * f)), c > n && (l > a && (a = l, r = h, o = u), l = 0, h = u - s)), d = f, m = y, p = x), g = E, _ = C;
  }
  return l += f, l > a ? [h, u] : [r, o];
}
const oo = {
  left: 0,
  center: 0.5,
  right: 1,
  top: 0,
  middle: 0.5,
  hanging: 0.2,
  alphabetic: 0.8,
  ideographic: 0.8,
  bottom: 1
};
class oE extends ar {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, i, s) {
    super(e, t, i, s), this.labels_ = null, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = void 0, this.textRotation_ = 0, this.textFillState_ = null, this.fillStates = {}, this.fillStates[Ye] = { fillStyle: Ye }, this.textStrokeState_ = null, this.strokeStates = {}, this.textState_ = /** @type {import("../canvas.js").TextState} */
    {}, this.textStates = {}, this.textKey_ = "", this.fillKey_ = "", this.strokeKey_ = "", this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const e = super.finish();
    return e.textStates = this.textStates, e.fillStates = this.fillStates, e.strokeStates = this.strokeStates, e;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawText(e, t, i) {
    const s = this.textFillState_, r = this.textStrokeState_, o = this.textState_;
    if (this.text_ === "" || !o || !s && !r)
      return;
    const a = this.coordinates;
    let l = a.length;
    const h = e.getType();
    let c = null, u = e.getStride();
    if (o.placement === "line" && (h == "LineString" || h == "MultiLineString" || h == "Polygon" || h == "MultiPolygon")) {
      if (!ye(this.maxExtent, e.getExtent()))
        return;
      let d;
      if (c = e.getFlatCoordinates(), h == "LineString")
        d = [c.length];
      else if (h == "MultiLineString")
        d = /** @type {import("../../geom/MultiLineString.js").default} */
        e.getEnds();
      else if (h == "Polygon")
        d = /** @type {import("../../geom/Polygon.js").default} */
        e.getEnds().slice(0, 1);
      else if (h == "MultiPolygon") {
        const m = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e.getEndss()
        );
        d = [];
        for (let p = 0, y = m.length; p < y; ++p)
          d.push(m[p][0]);
      }
      this.beginGeometry(e, t, i);
      const f = o.repeat, g = f ? void 0 : o.textAlign;
      let _ = 0;
      for (let m = 0, p = d.length; m < p; ++m) {
        let y;
        f ? y = sE(
          f * this.resolution,
          c,
          _,
          d[m],
          u
        ) : y = [c.slice(_, d[m])];
        for (let x = 0, E = y.length; x < E; ++x) {
          const C = y[x];
          let w = 0, S = C.length;
          if (g == null) {
            const R = rE(
              o.maxAngle,
              C,
              0,
              C.length,
              2
            );
            w = R[0], S = R[1];
          }
          for (let R = w; R < S; R += u)
            a.push(C[R], C[R + 1]);
          const v = a.length;
          _ = d[m], this.drawChars_(l, v), l = v;
        }
      }
      this.endGeometry(t);
    } else {
      let d = o.overflow ? null : [];
      switch (h) {
        case "Point":
        case "MultiPoint":
          c = /** @type {import("../../geom/MultiPoint.js").default} */
          e.getFlatCoordinates();
          break;
        case "LineString":
          c = /** @type {import("../../geom/LineString.js").default} */
          e.getFlatMidpoint();
          break;
        case "Circle":
          c = /** @type {import("../../geom/Circle.js").default} */
          e.getCenter();
          break;
        case "MultiLineString":
          c = /** @type {import("../../geom/MultiLineString.js").default} */
          e.getFlatMidpoints(), u = 2;
          break;
        case "Polygon":
          c = /** @type {import("../../geom/Polygon.js").default} */
          e.getFlatInteriorPoint(), o.overflow || d.push(c[2] / this.resolution), u = 3;
          break;
        case "MultiPolygon":
          const y = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            e.getFlatInteriorPoints()
          );
          c = [];
          for (let x = 0, E = y.length; x < E; x += 3)
            o.overflow || d.push(y[x + 2] / this.resolution), c.push(y[x], y[x + 1]);
          if (c.length === 0)
            return;
          u = 2;
          break;
      }
      const f = this.appendFlatPointCoordinates(c, u);
      if (f === l)
        return;
      if (d && (f - l) / 2 !== c.length / u) {
        let y = l / 2;
        d = d.filter((x, E) => {
          const C = a[(y + E) * 2] === c[E * u] && a[(y + E) * 2 + 1] === c[E * u + 1];
          return C || --y, C;
        });
      }
      this.saveTextStates_(), (o.backgroundFill || o.backgroundStroke) && (this.setFillStrokeStyle(
        o.backgroundFill,
        o.backgroundStroke
      ), o.backgroundFill && this.updateFillStyle(this.state, this.createFill), o.backgroundStroke && (this.updateStrokeStyle(this.state, this.applyStroke), this.hitDetectionInstructions.push(this.createStroke(this.state)))), this.beginGeometry(e, t, i);
      let g = o.padding;
      if (g != Bi && (o.scale[0] < 0 || o.scale[1] < 0)) {
        let y = o.padding[0], x = o.padding[1], E = o.padding[2], C = o.padding[3];
        o.scale[0] < 0 && (x = -x, C = -C), o.scale[1] < 0 && (y = -y, E = -E), g = [y, x, E, C];
      }
      const _ = this.pixelRatio;
      this.instructions.push([
        X.DRAW_IMAGE,
        l,
        f,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [1, 1],
        NaN,
        this.declutterMode_,
        this.declutterImageWithText_,
        g == Bi ? Bi : g.map(function(y) {
          return y * _;
        }),
        !!o.backgroundFill,
        !!o.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        d
      ]);
      const m = 1 / _, p = this.state.fillStyle;
      o.backgroundFill && (this.state.fillStyle = Ye, this.hitDetectionInstructions.push(this.createFill(this.state))), this.hitDetectionInstructions.push([
        X.DRAW_IMAGE,
        l,
        f,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [m, m],
        NaN,
        this.declutterMode_,
        this.declutterImageWithText_,
        g,
        !!o.backgroundFill,
        !!o.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_ ? Ye : this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        d
      ]), o.backgroundFill && (this.state.fillStyle = p, this.hitDetectionInstructions.push(this.createFill(this.state))), this.endGeometry(t);
    }
  }
  /**
   * @private
   */
  saveTextStates_() {
    const e = this.textStrokeState_, t = this.textState_, i = this.textFillState_, s = this.strokeKey_;
    e && (s in this.strokeStates || (this.strokeStates[s] = {
      strokeStyle: e.strokeStyle,
      lineCap: e.lineCap,
      lineDashOffset: e.lineDashOffset,
      lineWidth: e.lineWidth,
      lineJoin: e.lineJoin,
      miterLimit: e.miterLimit,
      lineDash: e.lineDash
    }));
    const r = this.textKey_;
    r in this.textStates || (this.textStates[r] = {
      font: t.font,
      textAlign: t.textAlign || zs,
      justify: t.justify,
      textBaseline: t.textBaseline || Br,
      scale: t.scale
    });
    const o = this.fillKey_;
    i && (o in this.fillStates || (this.fillStates[o] = {
      fillStyle: i.fillStyle
    }));
  }
  /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   */
  drawChars_(e, t) {
    const i = this.textStrokeState_, s = this.textState_, r = this.strokeKey_, o = this.textKey_, a = this.fillKey_;
    this.saveTextStates_();
    const l = this.pixelRatio, h = oo[s.textBaseline], c = this.textOffsetY_ * l, u = this.text_, d = i ? i.lineWidth * Math.abs(s.scale[0]) / 2 : 0;
    this.instructions.push([
      X.DRAW_CHARS,
      e,
      t,
      h,
      s.overflow,
      a,
      s.maxAngle,
      l,
      c,
      r,
      d * l,
      u,
      o,
      1,
      this.declutterMode_
    ]), this.hitDetectionInstructions.push([
      X.DRAW_CHARS,
      e,
      t,
      h,
      s.overflow,
      a && Ye,
      s.maxAngle,
      l,
      c,
      r,
      d * l,
      u,
      o,
      1 / l,
      this.declutterMode_
    ]);
  }
  /**
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @param {Object} [sharedData] Shared data.
   */
  setTextStyle(e, t) {
    let i, s, r;
    if (!e)
      this.text_ = "";
    else {
      const o = e.getFill();
      o ? (s = this.textFillState_, s || (s = /** @type {import("../canvas.js").FillState} */
      {}, this.textFillState_ = s), s.fillStyle = At(
        o.getColor() || Ye
      )) : (s = null, this.textFillState_ = s);
      const a = e.getStroke();
      if (!a)
        r = null, this.textStrokeState_ = r;
      else {
        r = this.textStrokeState_, r || (r = /** @type {import("../canvas.js").StrokeState} */
        {}, this.textStrokeState_ = r);
        const g = a.getLineDash(), _ = a.getLineDashOffset(), m = a.getWidth(), p = a.getMiterLimit();
        r.lineCap = a.getLineCap() || Xn, r.lineDash = g ? g.slice() : Jt, r.lineDashOffset = _ === void 0 ? Qt : _, r.lineJoin = a.getLineJoin() || Bn, r.lineWidth = m === void 0 ? $s : m, r.miterLimit = p === void 0 ? ks : p, r.strokeStyle = At(
          a.getColor() || Gs
        );
      }
      i = this.textState_;
      const l = e.getFont() || Zu;
      sm(l);
      const h = e.getScaleArray();
      i.overflow = e.getOverflow(), i.font = l, i.maxAngle = e.getMaxAngle(), i.placement = e.getPlacement(), i.textAlign = e.getTextAlign(), i.repeat = e.getRepeat(), i.justify = e.getJustify(), i.textBaseline = e.getTextBaseline() || Br, i.backgroundFill = e.getBackgroundFill(), i.backgroundStroke = e.getBackgroundStroke(), i.padding = e.getPadding() || Bi, i.scale = h === void 0 ? [1, 1] : h;
      const c = e.getOffsetX(), u = e.getOffsetY(), d = e.getRotateWithView(), f = e.getRotation();
      this.text_ = e.getText() || "", this.textOffsetX_ = c === void 0 ? 0 : c, this.textOffsetY_ = u === void 0 ? 0 : u, this.textRotateWithView_ = d === void 0 ? !1 : d, this.textRotation_ = f === void 0 ? 0 : f, this.strokeKey_ = r ? (typeof r.strokeStyle == "string" ? r.strokeStyle : j(r.strokeStyle)) + r.lineCap + r.lineDashOffset + "|" + r.lineWidth + r.lineJoin + r.miterLimit + "[" + r.lineDash.join() + "]" : "", this.textKey_ = i.font + i.scale + (i.textAlign || "?") + (i.repeat || "?") + (i.justify || "?") + (i.textBaseline || "?"), this.fillKey_ = s && s.fillStyle ? typeof s.fillStyle == "string" ? s.fillStyle : "|" + j(s.fillStyle) : "";
    }
    this.declutterMode_ = e.getDeclutterMode(), this.declutterImageWithText_ = t;
  }
}
const aE = {
  Circle: Ic,
  Default: ar,
  Image: eE,
  LineString: iE,
  Polygon: Ic,
  Text: oE
};
class lE {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, i, s) {
    this.tolerance_ = e, this.maxExtent_ = t, this.pixelRatio_ = s, this.resolution_ = i, this.buildersByZIndex_ = {};
  }
  /**
   * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */
  finish() {
    const e = {};
    for (const t in this.buildersByZIndex_) {
      e[t] = e[t] || {};
      const i = this.buildersByZIndex_[t];
      for (const s in i) {
        const r = i[s].finish();
        e[t][s] = r;
      }
    }
    return e;
  }
  /**
   * @param {number|undefined} zIndex Z index.
   * @param {import("../canvas.js").BuilderType} builderType Replay type.
   * @return {import("../VectorContext.js").default} Replay.
   */
  getBuilder(e, t) {
    const i = e !== void 0 ? e.toString() : "0";
    let s = this.buildersByZIndex_[i];
    s === void 0 && (s = {}, this.buildersByZIndex_[i] = s);
    let r = s[t];
    if (r === void 0) {
      const o = aE[t];
      r = new o(
        this.tolerance_,
        this.maxExtent_,
        this.resolution_,
        this.pixelRatio_
      ), s[t] = r;
    }
    return r;
  }
}
const Zd = lE;
class hE extends au {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(e) {
    super(), this.ready = !0, this.boundHandleImageChange_ = this.handleImageChange_.bind(this), this.layer_ = e, this.declutterExecutorGroup = null;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(e) {
    return B();
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(e) {
    return null;
  }
  /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    return B();
  }
  /**
   * Render the layer.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement|null} The rendered element.
   */
  renderFrame(e, t) {
    return B();
  }
  /**
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(e, t, i) {
    e[t] || (e[t] = {}), e[t][i.tileCoord.toString()] = i;
  }
  /**
   * Create a function that adds loaded tiles to the tile lookup.
   * @param {import("../source/Tile.js").default} source Tile source.
   * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
   *     called with a zoom level and a tile range to add loaded tiles to the lookup.
   * @protected
   */
  createLoadedTileFinder(e, t, i) {
    return (
      /**
       * @param {number} zoom Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @return {boolean} The tile range is fully loaded.
       */
      (s, r) => {
        const o = this.loadedTileCallback.bind(this, i, s);
        return e.forEachLoadedTile(t, s, r, o);
      }
    );
  }
  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, i, s, r) {
  }
  /**
   * @return {LayerType} Layer.
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */
  handleFontsChanged() {
  }
  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */
  handleImageChange_(e) {
    const t = (
      /** @type {import("../Image.js").default} */
      e.target
    );
    (t.getState() === M.LOADED || t.getState() === M.ERROR) && this.renderIfReadyAndVisible();
  }
  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../Image.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */
  loadImage(e) {
    let t = e.getState();
    return t != M.LOADED && t != M.ERROR && e.addEventListener(G.CHANGE, this.boundHandleImageChange_), t == M.IDLE && (e.load(), t = e.getState()), t == M.LOADED;
  }
  /**
   * @protected
   */
  renderIfReadyAndVisible() {
    const e = this.getLayer();
    e && e.getVisible() && e.getSourceState() === "ready" && e.changed();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  renderDeferred(e) {
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.layer_, super.disposeInternal();
  }
}
const cE = hE;
class uE {
  constructor() {
    /**
     * @private
     * @param {...*} args Args.
     * @return {ZIndexContext} This.
     */
    Th(this, "pushMethodArgs_", (...e) => (this.instructions_[this.zIndex + this.offset_].push(e), this));
    this.instructions_ = [], this.zIndex = 0, this.offset_ = 0, this.context_ = /** @type {ZIndexContextProxy} */
    new Proxy(CanvasRenderingContext2D.prototype, {
      get: (e, t) => {
        if (typeof /** @type {*} */
        Oa()[t] == "function")
          return this.instructions_[this.zIndex + this.offset_] || (this.instructions_[this.zIndex + this.offset_] = []), this.instructions_[this.zIndex + this.offset_].push(t), this.pushMethodArgs_;
      },
      set: (e, t, i) => (this.instructions_[this.zIndex + this.offset_] || (this.instructions_[this.zIndex + this.offset_] = []), this.instructions_[this.zIndex + this.offset_].push(t, i), !0)
    });
  }
  /**
   * Get a proxy for CanvasRenderingContext2D which does not support getting state
   * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a
   * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,
   * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.
   * @return {ZIndexContextProxy} Context.
   */
  getContext() {
    return this.context_;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   */
  draw(e) {
    this.instructions_.forEach((t) => {
      for (let i = 0, s = t.length; i < s; i += 2) {
        const r = t[i], o = t[i + 1];
        if (typeof /** @type {*} */
        e[r] == "function")
          e[r](...o);
        else {
          if (typeof o == "function") {
            e[r] = o(e);
            continue;
          }
          e[r] = o;
        }
      }
    });
  }
  clear() {
    this.instructions_.length = 0, this.zIndex = 0, this.offset_ = 0;
  }
  /**
   * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to
   * avoid conflicting context.clip() or context.save()/restore() calls.
   */
  offset() {
    this.offset_ = this.instructions_.length, this.zIndex = 0;
  }
}
const lh = uE, Pc = [];
let Sn = null;
function dE() {
  Sn = Pe(1, 1, void 0, {
    willReadFrequently: !0
  });
}
class fE extends cE {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(e) {
    super(e), this.container = null, this.renderedResolution, this.tempTransform = at(), this.pixelTransform = at(), this.inversePixelTransform = at(), this.context = null, this.deferredContext_ = null, this.containerReused = !1, this.pixelContext_ = null, this.frameState = null;
  }
  /**
   * @param {import('../../DataTile.js').ImageLike} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */
  getImageData(e, t, i) {
    Sn || dE(), Sn.clearRect(0, 0, 1, 1);
    let s;
    try {
      Sn.drawImage(e, t, i, 1, 1, 0, 0, 1, 1), s = Sn.getImageData(0, 0, 1, 1).data;
    } catch {
      return Sn = null, null;
    }
    return s;
  }
  /**
   * @param {import('../../Map.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */
  getBackground(e) {
    let i = this.getLayer().getBackground();
    return typeof i == "function" && (i = i(e.viewState.resolution)), i || void 0;
  }
  /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS Transform.
   * @param {string} [backgroundColor] Background color.
   */
  useContainer(e, t, i) {
    const s = this.getLayer().getClassName();
    let r, o;
    if (e && e.className === s && (!i || e && e.style.backgroundColor && ri(
      jn(e.style.backgroundColor),
      jn(i)
    ))) {
      const a = e.firstElementChild;
      a instanceof HTMLCanvasElement && (o = a.getContext("2d"));
    }
    if (o && o.canvas.style.transform === t ? (this.container = e, this.context = o, this.containerReused = !0) : this.containerReused ? (this.container = null, this.context = null, this.containerReused = !1) : this.container && (this.container.style.backgroundColor = null), !this.container) {
      r = document.createElement("div"), r.className = s;
      let a = r.style;
      a.position = "absolute", a.width = "100%", a.height = "100%", o = Pe();
      const l = o.canvas;
      r.appendChild(l), a = l.style, a.position = "absolute", a.left = "0", a.transformOrigin = "top left", this.container = r, this.context = o;
    }
    !this.containerReused && i && !this.container.style.backgroundColor && (this.container.style.backgroundColor = i);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */
  clipUnrotated(e, t, i) {
    const s = kt(i), r = Js(i), o = qn(i), a = $n(i);
    Se(t.coordinateToPixelTransform, s), Se(t.coordinateToPixelTransform, r), Se(t.coordinateToPixelTransform, o), Se(t.coordinateToPixelTransform, a);
    const l = this.inversePixelTransform;
    Se(l, s), Se(l, r), Se(l, o), Se(l, a), e.save(), e.beginPath(), e.moveTo(Math.round(s[0]), Math.round(s[1])), e.lineTo(Math.round(r[0]), Math.round(r[1])), e.lineTo(Math.round(o[0]), Math.round(o[1])), e.lineTo(Math.round(a[0]), Math.round(a[1])), e.clip();
  }
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(e, t, i) {
    const s = this.getLayer();
    if (s.hasListener(e)) {
      const r = new ad(
        e,
        this.inversePixelTransform,
        i,
        t
      );
      s.dispatchEvent(r);
    }
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(e, t) {
    this.frameState = t, !t.declutter && this.dispatchRenderEvent_(st.PRERENDER, e, t);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(e, t) {
    t.declutter || this.dispatchRenderEvent_(st.POSTRENDER, e, t);
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeferredInternal(e) {
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.
   */
  getRenderContext(e) {
    return e.declutter && !this.deferredContext_ && (this.deferredContext_ = new lh()), e.declutter ? this.deferredContext_.getContext() : this.context;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderDeferred(e) {
    e.declutter && (this.dispatchRenderEvent_(
      st.PRERENDER,
      this.context,
      e
    ), e.declutter && this.deferredContext_ && (this.deferredContext_.draw(this.context), this.deferredContext_.clear()), this.renderDeferredInternal(e), this.dispatchRenderEvent_(
      st.POSTRENDER,
      this.context,
      e
    ));
  }
  /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  getRenderTransform(e, t, i, s, r, o, a) {
    const l = r / 2, h = o / 2, c = s / t, u = -c, d = -e[0] + a, f = -e[1];
    return wt(
      this.tempTransform,
      l,
      h,
      c,
      u,
      -i,
      d,
      f
    );
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.frameState, super.disposeInternal();
  }
}
const hh = fE;
function gE(n, e, t, i, s, r, o, a, l, h, c, u) {
  let d = n[e], f = n[e + 1], g = 0, _ = 0, m = 0, p = 0;
  function y() {
    g = d, _ = f, e += i, d = n[e], f = n[e + 1], p += m, m = Math.sqrt((d - g) * (d - g) + (f - _) * (f - _));
  }
  do
    y();
  while (e < t - i && p + m < r);
  let x = m === 0 ? 0 : (r - p) / m;
  const E = He(g, d, x), C = He(_, f, x), w = e - i, S = p, v = r + a * l(h, s, c);
  for (; e < t - i && p + m < v; )
    y();
  x = m === 0 ? 0 : (v - p) / m;
  const R = He(g, d, x), b = He(_, f, x);
  let A;
  if (u) {
    const L = [E, C, R, b];
    xl(L, 0, 4, 2, u, L, L), A = L[0] > L[2];
  } else
    A = E > R;
  const N = Math.PI, $ = [], V = w + i === e;
  e = w, m = 0, p = S, d = n[e], f = n[e + 1];
  let D;
  if (V) {
    y(), D = Math.atan2(f - _, d - g), A && (D += D > 0 ? -N : N);
    const L = (R + E) / 2, Y = (b + C) / 2;
    return $[0] = [L, Y, (v - r) / 2, D, s], $;
  }
  s = s.replace(/\n/g, " ");
  for (let L = 0, Y = s.length; L < Y; ) {
    y();
    let W = Math.atan2(f - _, d - g);
    if (A && (W += W > 0 ? -N : N), D !== void 0) {
      let I = W - D;
      if (I += I > N ? -2 * N : I < -N ? 2 * N : 0, Math.abs(I) > o)
        return null;
    }
    D = W;
    const oe = L;
    let q = 0;
    for (; L < Y; ++L) {
      const I = A ? Y - L - 1 : L, fe = a * l(h, s[I], c);
      if (e + i < t && p + m < r + q + fe / 2)
        break;
      q += fe;
    }
    if (L === oe)
      continue;
    const ae = A ? s.substring(Y - oe, Y - L) : s.substring(oe, L);
    x = m === 0 ? 0 : (r + q / 2 - p) / m;
    const ee = He(g, d, x), xe = He(_, f, x);
    $.push([ee, xe, q / 2, W, ae]), r += q;
  }
  return $;
}
const mn = Je(), di = [], Yt = [], Xt = [], fi = [];
function Lc(n) {
  return n[3].declutterBox;
}
const bc = new RegExp(
  /* eslint-disable prettier/prettier */
  "[֑-ࣿיִ-﷿ﹰ-ﻼࠀ-࿿-]"
  /* eslint-enable prettier/prettier */
);
function da(n, e) {
  return e === "start" ? e = bc.test(n) ? "right" : "left" : e === "end" && (e = bc.test(n) ? "left" : "right"), oo[e];
}
function _E(n, e, t) {
  return t > 0 && n.push(`
`, ""), n.push(e, ""), n;
}
class mE {
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions.
   * @param {boolean} [deferredRendering] Enable deferred rendering.
   */
  constructor(e, t, i, s, r) {
    this.overlaps = i, this.pixelRatio = t, this.resolution = e, this.alignAndScaleFill_, this.instructions = s.instructions, this.coordinates = s.coordinates, this.coordinateCache_ = {}, this.renderedTransform_ = at(), this.hitDetectionInstructions = s.hitDetectionInstructions, this.pixelCoordinates_ = null, this.viewRotation_ = 0, this.fillStates = s.fillStates || {}, this.strokeStates = s.strokeStates || {}, this.textStates = s.textStates || {}, this.widths_ = {}, this.labels_ = {}, this.zIndexContext_ = r ? new lh() : null;
  }
  /**
   * @return {ZIndexContext} ZIndex context.
   */
  getZIndexContext() {
    return this.zIndexContext_;
  }
  /**
   * @param {string|Array<string>} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */
  createLabel(e, t, i, s) {
    const r = e + t + i + s;
    if (this.labels_[r])
      return this.labels_[r];
    const o = s ? this.strokeStates[s] : null, a = i ? this.fillStates[i] : null, l = this.textStates[t], h = this.pixelRatio, c = [
      l.scale[0] * h,
      l.scale[1] * h
    ], u = Array.isArray(e), d = l.justify ? oo[l.justify] : da(
      Array.isArray(e) ? e[0] : e,
      l.textAlign || zs
    ), f = s && o.lineWidth ? o.lineWidth : 0, g = u ? e : e.split(`
`).reduce(_E, []), { width: _, height: m, widths: p, heights: y, lineWidths: x } = om(
      l,
      g
    ), E = _ + f, C = [], w = (E + 2) * c[0], S = (m + f) * c[1], v = {
      width: w < 0 ? Math.floor(w) : Math.ceil(w),
      height: S < 0 ? Math.floor(S) : Math.ceil(S),
      contextInstructions: C
    };
    (c[0] != 1 || c[1] != 1) && C.push("scale", c), s && (C.push("strokeStyle", o.strokeStyle), C.push("lineWidth", f), C.push("lineCap", o.lineCap), C.push("lineJoin", o.lineJoin), C.push("miterLimit", o.miterLimit), C.push("setLineDash", [o.lineDash]), C.push("lineDashOffset", o.lineDashOffset)), i && C.push("fillStyle", a.fillStyle), C.push("textBaseline", "middle"), C.push("textAlign", "center");
    const R = 0.5 - d;
    let b = d * E + R * f;
    const A = [], N = [];
    let $ = 0, V = 0, D = 0, L = 0, Y;
    for (let W = 0, oe = g.length; W < oe; W += 2) {
      const q = g[W];
      if (q === `
`) {
        V += $, $ = 0, b = d * E + R * f, ++L;
        continue;
      }
      const ae = g[W + 1] || l.font;
      ae !== Y && (s && A.push("font", ae), i && N.push("font", ae), Y = ae), $ = Math.max($, y[D]);
      const ee = [
        q,
        b + R * p[D] + d * (p[D] - x[L]),
        0.5 * (f + $) + V
      ];
      b += p[D], s && A.push("strokeText", ee), i && N.push("fillText", ee), ++D;
    }
    return Array.prototype.push.apply(C, A), Array.prototype.push.apply(C, N), this.labels_[r] = v, v;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */
  replayTextBackground_(e, t, i, s, r, o, a) {
    e.beginPath(), e.moveTo.apply(e, t), e.lineTo.apply(e, i), e.lineTo.apply(e, s), e.lineTo.apply(e, r), e.lineTo.apply(e, t), o && (this.alignAndScaleFill_ = /** @type {number} */
    o[2], this.fill_(e)), a && (this.setStrokeStyle_(
      e,
      /** @type {Array<*>} */
      a
    ), e.stroke());
  }
  /**
   * @private
   * @param {number} sheetWidth Width of the sprite sheet.
   * @param {number} sheetHeight Height of the sprite sheet.
   * @param {number} centerX X.
   * @param {number} centerY Y.
   * @param {number} width Width.
   * @param {number} height Height.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {import("../../size.js").Size} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {Array<number>} padding Padding.
   * @param {boolean} fillStroke Background fill or stroke.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
   */
  calculateImageOrLabelDimensions_(e, t, i, s, r, o, a, l, h, c, u, d, f, g, _, m) {
    a *= d[0], l *= d[1];
    let p = i - a, y = s - l;
    const x = r + h > e ? e - h : r, E = o + c > t ? t - c : o, C = g[3] + x * d[0] + g[1], w = g[0] + E * d[1] + g[2], S = p - g[3], v = y - g[0];
    (_ || u !== 0) && (di[0] = S, fi[0] = S, di[1] = v, Yt[1] = v, Yt[0] = S + C, Xt[0] = Yt[0], Xt[1] = v + w, fi[1] = Xt[1]);
    let R;
    return u !== 0 ? (R = wt(
      at(),
      i,
      s,
      1,
      1,
      u,
      -i,
      -s
    ), Se(R, di), Se(R, Yt), Se(R, Xt), Se(R, fi), ii(
      Math.min(di[0], Yt[0], Xt[0], fi[0]),
      Math.min(di[1], Yt[1], Xt[1], fi[1]),
      Math.max(di[0], Yt[0], Xt[0], fi[0]),
      Math.max(di[1], Yt[1], Xt[1], fi[1]),
      mn
    )) : ii(
      Math.min(S, S + C),
      Math.min(v, v + w),
      Math.max(S, S + C),
      Math.max(v, v + w),
      mn
    ), f && (p = Math.round(p), y = Math.round(y)), {
      drawImageX: p,
      drawImageY: y,
      drawImageW: x,
      drawImageH: E,
      originX: h,
      originY: c,
      declutterBox: {
        minX: mn[0],
        minY: mn[1],
        maxX: mn[2],
        maxY: mn[3],
        value: m
      },
      canvasTransform: R,
      scale: d
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
   * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
   * @param {ImageOrLabelDimensions} dimensions Dimensions.
   * @param {number} opacity Opacity.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   * @return {boolean} The image or label was rendered.
   */
  replayImageOrLabel_(e, t, i, s, r, o, a) {
    const l = !!(o || a), h = s.declutterBox, c = a ? a[2] * s.scale[0] / 2 : 0;
    return h.minX - c <= t[0] && h.maxX + c >= 0 && h.minY - c <= t[1] && h.maxY + c >= 0 && (l && this.replayTextBackground_(
      e,
      di,
      Yt,
      Xt,
      fi,
      /** @type {Array<*>} */
      o,
      /** @type {Array<*>} */
      a
    ), am(
      e,
      s.canvasTransform,
      r,
      i,
      s.originX,
      s.originY,
      s.drawImageW,
      s.drawImageH,
      s.drawImageX,
      s.drawImageY,
      s.scale
    )), !0;
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   */
  fill_(e) {
    const t = this.alignAndScaleFill_;
    if (t) {
      const i = Se(this.renderedTransform_, [0, 0]), s = 512 * this.pixelRatio;
      e.save(), e.translate(i[0] % s, i[1] % s), t !== 1 && e.scale(t, t), e.rotate(this.viewRotation_);
    }
    e.fill(), t && e.restore();
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */
  setStrokeStyle_(e, t) {
    e.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */
    t[1], e.lineWidth = /** @type {number} */
    t[2], e.lineCap = /** @type {CanvasLineCap} */
    t[3], e.lineJoin = /** @type {CanvasLineJoin} */
    t[4], e.miterLimit = /** @type {number} */
    t[5], e.lineDashOffset = /** @type {number} */
    t[7], e.setLineDash(
      /** @type {Array<number>} */
      t[6]
    );
  }
  /**
   * @private
   * @param {string|Array<string>} text The text to draw.
   * @param {string} textKey The key of the text state.
   * @param {string} strokeKey The key for the stroke state.
   * @param {string} fillKey The key for the fill state.
   * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
   */
  drawLabelWithPointPlacement_(e, t, i, s) {
    const r = this.textStates[t], o = this.createLabel(e, t, s, i), a = this.strokeStates[i], l = this.pixelRatio, h = da(
      Array.isArray(e) ? e[0] : e,
      r.textAlign || zs
    ), c = oo[r.textBaseline || Br], u = a && a.lineWidth ? a.lineWidth : 0, d = o.width / l - 2 * r.scale[0], f = h * d + 2 * (0.5 - h) * u, g = c * o.height / l + 2 * (0.5 - c) * u;
    return {
      label: o,
      anchorX: f,
      anchorY: g
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   * @return {T|undefined} Callback result.
   * @template T
   */
  execute_(e, t, i, s, r, o, a, l) {
    const h = this.zIndexContext_;
    let c;
    this.pixelCoordinates_ && ri(i, this.renderedTransform_) ? c = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), c = bi(
      this.coordinates,
      0,
      this.coordinates.length,
      2,
      i,
      this.pixelCoordinates_
    ), s_(this.renderedTransform_, i));
    let u = 0;
    const d = s.length;
    let f = 0, g, _, m, p, y, x, E, C, w, S, v, R, b, A = 0, N = 0, $ = null, V = null;
    const D = this.coordinateCache_, L = this.viewRotation_, Y = Math.round(Math.atan2(-i[1], i[0]) * 1e12) / 1e12, W = (
      /** @type {import("../../render.js").State} */
      {
        context: e,
        pixelRatio: this.pixelRatio,
        resolution: this.resolution,
        rotation: L
      }
    ), oe = this.instructions != s || this.overlaps ? 0 : 200;
    let q, ae, ee, xe;
    for (; u < d; ) {
      const I = s[u];
      switch (
        /** @type {import("./Instruction.js").default} */
        I[0]
      ) {
        case X.BEGIN_GEOMETRY:
          q = /** @type {import("../../Feature.js").FeatureLike} */
          I[1], xe = I[3], q.getGeometry() ? a !== void 0 && !ye(a, xe.getExtent()) ? u = /** @type {number} */
          I[2] + 1 : ++u : u = /** @type {number} */
          I[2], h && (h.zIndex = I[4]);
          break;
        case X.BEGIN_PATH:
          A > oe && (this.fill_(e), A = 0), N > oe && (e.stroke(), N = 0), !A && !N && (e.beginPath(), y = NaN, x = NaN), ++u;
          break;
        case X.CIRCLE:
          f = /** @type {number} */
          I[1];
          const Be = c[f], ve = c[f + 1], Ue = c[f + 2], ft = c[f + 3], Ve = Ue - Be, rs = ft - ve, Gi = Math.sqrt(Ve * Ve + rs * rs);
          e.moveTo(Be + Gi, ve), e.arc(Be, ve, Gi, 0, 2 * Math.PI, !0), ++u;
          break;
        case X.CLOSE_PATH:
          e.closePath(), ++u;
          break;
        case X.CUSTOM:
          f = /** @type {number} */
          I[1], g = I[2];
          const ko = (
            /** @type {import("../../geom/SimpleGeometry.js").default} */
            I[3]
          ), lr = I[4], hr = I[5];
          W.geometry = ko, W.feature = q, u in D || (D[u] = []);
          const Qe = D[u];
          hr ? hr(c, f, g, 2, Qe) : (Qe[0] = c[f], Qe[1] = c[f + 1], Qe.length = 2), h && (h.zIndex = I[6]), lr(Qe, W), ++u;
          break;
        case X.DRAW_IMAGE:
          f = /** @type {number} */
          I[1], g = /** @type {number} */
          I[2], w = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
          I[3], _ = /** @type {number} */
          I[4], m = /** @type {number} */
          I[5];
          let hn = (
            /** @type {number} */
            I[6]
          );
          const cr = (
            /** @type {number} */
            I[7]
          ), Go = (
            /** @type {number} */
            I[8]
          ), ur = (
            /** @type {number} */
            I[9]
          ), dr = (
            /** @type {boolean} */
            I[10]
          );
          let We = (
            /** @type {number} */
            I[11]
          );
          const gt = (
            /** @type {import("../../size.js").Size} */
            I[12]
          );
          let Rt = (
            /** @type {number} */
            I[13]
          );
          p = I[14] || "declutter";
          const _t = (
            /** @type {{args: import("../canvas.js").DeclutterImageWithText, declutterMode: import('../../style/Style.js').DeclutterMode}} */
            I[15]
          );
          if (!w && I.length >= 20) {
            S = /** @type {string} */
            I[19], v = /** @type {string} */
            I[20], R = /** @type {string} */
            I[21], b = /** @type {string} */
            I[22];
            const et = this.drawLabelWithPointPlacement_(
              S,
              v,
              R,
              b
            );
            w = et.label, I[3] = w;
            const zi = (
              /** @type {number} */
              I[23]
            );
            _ = (et.anchorX - zi) * this.pixelRatio, I[4] = _;
            const tt = (
              /** @type {number} */
              I[24]
            );
            m = (et.anchorY - tt) * this.pixelRatio, I[5] = m, hn = w.height, I[6] = hn, Rt = w.width, I[13] = Rt;
          }
          let cn;
          I.length > 25 && (cn = /** @type {number} */
          I[25]);
          let un, ci, zt;
          I.length > 17 ? (un = /** @type {Array<number>} */
          I[16], ci = /** @type {boolean} */
          I[17], zt = /** @type {boolean} */
          I[18]) : (un = Bi, ci = !1, zt = !1), dr && Y ? We += L : !dr && !Y && (We -= L);
          let zo = 0;
          for (; f < g; f += 2) {
            if (cn && cn[zo++] < Rt / this.pixelRatio)
              continue;
            const et = this.calculateImageOrLabelDimensions_(
              w.width,
              w.height,
              c[f],
              c[f + 1],
              Rt,
              hn,
              _,
              m,
              Go,
              ur,
              We,
              gt,
              r,
              un,
              ci || zt,
              q
            ), zi = [
              e,
              t,
              w,
              et,
              cr,
              ci ? (
                /** @type {Array<*>} */
                $
              ) : null,
              zt ? (
                /** @type {Array<*>} */
                V
              ) : null
            ];
            if (l) {
              let tt, It, it;
              if (_t) {
                const me = g - f;
                if (!_t[me]) {
                  _t[me] = { args: zi, declutterMode: p };
                  continue;
                }
                const Ge = _t[me];
                tt = Ge.args, It = Ge.declutterMode, delete _t[me], it = Lc(tt);
              }
              let $t, Ut;
              if (tt && (It !== "declutter" || !l.collides(it)) && ($t = !0), (p !== "declutter" || !l.collides(et.declutterBox)) && (Ut = !0), It === "declutter" && p === "declutter") {
                const me = $t && Ut;
                $t = me, Ut = me;
              }
              $t && (It !== "none" && l.insert(it), this.replayImageOrLabel_.apply(this, tt)), Ut && (p !== "none" && l.insert(et.declutterBox), this.replayImageOrLabel_.apply(this, zi));
            } else
              this.replayImageOrLabel_.apply(this, zi);
          }
          ++u;
          break;
        case X.DRAW_CHARS:
          const ke = (
            /** @type {number} */
            I[1]
          ), xh = (
            /** @type {number} */
            I[2]
          ), $o = (
            /** @type {number} */
            I[3]
          ), Df = (
            /** @type {number} */
            I[4]
          );
          b = /** @type {string} */
          I[5];
          const Nf = (
            /** @type {number} */
            I[6]
          ), Eh = (
            /** @type {number} */
            I[7]
          ), Ch = (
            /** @type {number} */
            I[8]
          );
          R = /** @type {string} */
          I[9];
          const Uo = (
            /** @type {number} */
            I[10]
          );
          S = /** @type {string} */
          I[11], v = /** @type {string} */
          I[12];
          const wh = [
            /** @type {number} */
            I[13],
            /** @type {number} */
            I[13]
          ];
          p = I[14] || "declutter";
          const Vo = this.textStates[v], os = Vo.font, as = [
            Vo.scale[0] * Eh,
            Vo.scale[1] * Eh
          ];
          let ls;
          os in this.widths_ ? ls = this.widths_[os] : (ls = {}, this.widths_[os] = ls);
          const Sh = Ed(c, ke, xh, 2), vh = Math.abs(as[0]) * sc(os, S, ls);
          if (Df || vh <= Sh) {
            const et = this.textStates[v].textAlign, zi = (Sh - vh) * da(S, et), tt = gE(
              c,
              ke,
              xh,
              2,
              S,
              zi,
              Nf,
              Math.abs(as[0]),
              sc,
              os,
              ls,
              Y ? 0 : this.viewRotation_
            );
            e:
              if (tt) {
                const It = [];
                let it, $t, Ut, me, Ge;
                if (R)
                  for (it = 0, $t = tt.length; it < $t; ++it) {
                    Ge = tt[it], Ut = /** @type {string} */
                    Ge[4], me = this.createLabel(Ut, v, "", R), _ = /** @type {number} */
                    Ge[2] + (as[0] < 0 ? -Uo : Uo), m = $o * me.height + (0.5 - $o) * 2 * Uo * as[1] / as[0] - Ch;
                    const Vt = this.calculateImageOrLabelDimensions_(
                      me.width,
                      me.height,
                      Ge[0],
                      Ge[1],
                      me.width,
                      me.height,
                      _,
                      m,
                      0,
                      0,
                      Ge[3],
                      wh,
                      !1,
                      Bi,
                      !1,
                      q
                    );
                    if (l && p === "declutter" && l.collides(Vt.declutterBox))
                      break e;
                    It.push([
                      e,
                      t,
                      me,
                      Vt,
                      1,
                      null,
                      null
                    ]);
                  }
                if (b)
                  for (it = 0, $t = tt.length; it < $t; ++it) {
                    Ge = tt[it], Ut = /** @type {string} */
                    Ge[4], me = this.createLabel(Ut, v, b, ""), _ = /** @type {number} */
                    Ge[2], m = $o * me.height - Ch;
                    const Vt = this.calculateImageOrLabelDimensions_(
                      me.width,
                      me.height,
                      Ge[0],
                      Ge[1],
                      me.width,
                      me.height,
                      _,
                      m,
                      0,
                      0,
                      Ge[3],
                      wh,
                      !1,
                      Bi,
                      !1,
                      q
                    );
                    if (l && p === "declutter" && l.collides(Vt.declutterBox))
                      break e;
                    It.push([
                      e,
                      t,
                      me,
                      Vt,
                      1,
                      null,
                      null
                    ]);
                  }
                l && p !== "none" && l.load(It.map(Lc));
                for (let Vt = 0, kf = It.length; Vt < kf; ++Vt)
                  this.replayImageOrLabel_.apply(this, It[Vt]);
              }
          }
          ++u;
          break;
        case X.END_GEOMETRY:
          if (o !== void 0) {
            q = /** @type {import("../../Feature.js").FeatureLike} */
            I[1];
            const et = o(q, xe);
            if (et)
              return et;
          }
          ++u;
          break;
        case X.FILL:
          oe ? A++ : this.fill_(e), ++u;
          break;
        case X.MOVE_TO_LINE_TO:
          for (f = /** @type {number} */
          I[1], g = /** @type {number} */
          I[2], ae = c[f], ee = c[f + 1], E = ae + 0.5 | 0, C = ee + 0.5 | 0, (E !== y || C !== x) && (e.moveTo(ae, ee), y = E, x = C), f += 2; f < g; f += 2)
            ae = c[f], ee = c[f + 1], E = ae + 0.5 | 0, C = ee + 0.5 | 0, (f == g - 2 || E !== y || C !== x) && (e.lineTo(ae, ee), y = E, x = C);
          ++u;
          break;
        case X.SET_FILL_STYLE:
          $ = I, this.alignAndScaleFill_ = I[2], A && (this.fill_(e), A = 0, N && (e.stroke(), N = 0)), e.fillStyle = I[1], ++u;
          break;
        case X.SET_STROKE_STYLE:
          V = I, N && (e.stroke(), N = 0), this.setStrokeStyle_(
            e,
            /** @type {Array<*>} */
            I
          ), ++u;
          break;
        case X.STROKE:
          oe ? N++ : e.stroke(), ++u;
          break;
        default:
          ++u;
          break;
      }
    }
    A && this.fill_(e), N && e.stroke();
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  execute(e, t, i, s, r, o) {
    this.viewRotation_ = s, this.execute_(
      e,
      t,
      i,
      this.instructions,
      r,
      void 0,
      void 0,
      o
    );
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @return {T|undefined} Callback result.
   * @template T
   */
  executeHitDetection(e, t, i, s, r) {
    return this.viewRotation_ = i, this.execute_(
      e,
      [e.canvas.width, e.canvas.height],
      t,
      this.hitDetectionInstructions,
      !0,
      s,
      r
    );
  }
}
const pE = mE, Is = [
  "Polygon",
  "Circle",
  "LineString",
  "Image",
  "Text",
  "Default"
], ao = ["Image", "Text"], yE = Is.filter(
  (n) => !ao.includes(n)
);
class xE {
  /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceed that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number} [renderBuffer] Optional rendering buffer.
   * @param {boolean} [deferredRendering] Enable deferred rendering with renderDeferred().
   */
  constructor(e, t, i, s, r, o, a) {
    this.maxExtent_ = e, this.overlaps_ = s, this.pixelRatio_ = i, this.resolution_ = t, this.renderBuffer_ = o, this.executorsByZIndex_ = {}, this.hitDetectionContext_ = null, this.hitDetectionTransform_ = at(), this.renderedContext_ = null, this.deferredZIndexContexts_ = [], this.createExecutors_(r, a);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  clip(e, t) {
    const i = this.getClipCoords(t);
    e.beginPath(), e.moveTo(i[0], i[1]), e.lineTo(i[2], i[3]), e.lineTo(i[4], i[5]), e.lineTo(i[6], i[7]), e.clip();
  }
  /**
   * Create executors and populate them using the provided instructions.
   * @private
   * @param {!Object<string, !Object<string, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
   * @param {boolean} deferredRendering Enable deferred rendering.
   */
  createExecutors_(e, t) {
    for (const i in e) {
      let s = this.executorsByZIndex_[i];
      s === void 0 && (s = {}, this.executorsByZIndex_[i] = s);
      const r = e[i];
      for (const o in r) {
        const a = r[o];
        s[o] = new pE(
          this.resolution_,
          this.pixelRatio_,
          this.overlaps_,
          a,
          t
        );
      }
    }
  }
  /**
   * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
   * @return {boolean} Has executors of the provided types.
   */
  hasExecutors(e) {
    for (const t in this.executorsByZIndex_) {
      const i = this.executorsByZIndex_[t];
      for (let s = 0, r = e.length; s < r; ++s)
        if (e[s] in i)
          return !0;
    }
    return !1;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
   * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, i, s, r, o) {
    s = Math.round(s);
    const a = s * 2 + 1, l = wt(
      this.hitDetectionTransform_,
      s + 0.5,
      s + 0.5,
      1 / t,
      -1 / t,
      -i,
      -e[0],
      -e[1]
    ), h = !this.hitDetectionContext_;
    h && (this.hitDetectionContext_ = Pe(
      a,
      a,
      void 0,
      { willReadFrequently: !0 }
    ));
    const c = this.hitDetectionContext_;
    c.canvas.width !== a || c.canvas.height !== a ? (c.canvas.width = a, c.canvas.height = a) : h || c.clearRect(0, 0, a, a);
    let u;
    this.renderBuffer_ !== void 0 && (u = Je(), ws(u, e), ot(
      u,
      t * (this.renderBuffer_ + s),
      u
    ));
    const d = EE(s);
    let f;
    function g(C, w) {
      const S = c.getImageData(
        0,
        0,
        a,
        a
      ).data;
      for (let v = 0, R = d.length; v < R; v++)
        if (S[d[v]] > 0) {
          if (!o || f !== "Image" && f !== "Text" || o.includes(C)) {
            const b = (d[v] - 3) / 4, A = s - b % a, N = s - (b / a | 0), $ = r(C, w, A * A + N * N);
            if ($)
              return $;
          }
          c.clearRect(0, 0, a, a);
          break;
        }
    }
    const _ = Object.keys(this.executorsByZIndex_).map(Number);
    _.sort(ti);
    let m, p, y, x, E;
    for (m = _.length - 1; m >= 0; --m) {
      const C = _[m].toString();
      for (y = this.executorsByZIndex_[C], p = Is.length - 1; p >= 0; --p)
        if (f = Is[p], x = y[f], x !== void 0 && (E = x.executeHitDetection(
          c,
          l,
          i,
          g,
          u
        ), E))
          return E;
    }
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>|null} Clip coordinates.
   */
  getClipCoords(e) {
    const t = this.maxExtent_;
    if (!t)
      return null;
    const i = t[0], s = t[1], r = t[2], o = t[3], a = [i, s, i, o, r, o, r, s];
    return bi(a, 0, 8, 2, e, a), a;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return Fi(this.executorsByZIndex_);
  }
  /**
   * @param {CanvasRenderingContext2D} targetContext Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ALL}
   * @param {import("rbush").default|null} [declutterTree] Declutter tree.
   *     When set to null, no decluttering is done, even when the executor group has a `ZIndexContext`.
   */
  execute(e, t, i, s, r, o, a) {
    const l = Object.keys(this.executorsByZIndex_).map(Number);
    l.sort(ti), o = o || Is;
    let h, c, u, d, f, g;
    for (a && l.reverse(), h = 0, c = l.length; h < c; ++h) {
      const _ = l[h].toString();
      for (f = this.executorsByZIndex_[_], u = 0, d = o.length; u < d; ++u) {
        const m = o[u];
        if (g = f[m], g !== void 0) {
          const p = a === null ? void 0 : g.getZIndexContext(), y = p ? p.getContext() : e, x = this.maxExtent_ && m !== "Image" && m !== "Text";
          if (x && (y.save(), this.clip(y, i)), g.execute(
            y,
            t,
            i,
            s,
            r,
            a
          ), x && y.restore(), p) {
            p.offset();
            const E = l[h];
            this.deferredZIndexContexts_[E] || (this.deferredZIndexContexts_[E] = []), this.deferredZIndexContexts_[E].push(p);
          }
        }
      }
    }
    this.renderedContext_ = e;
  }
  getDeferredZIndexContexts() {
    return this.deferredZIndexContexts_;
  }
  getRenderedContext() {
    return this.renderedContext_;
  }
  renderDeferred() {
    this.deferredZIndexContexts_.forEach((e) => {
      e.forEach((t) => {
        t.draw(this.renderedContext_), t.clear();
      });
    });
  }
}
const fa = {};
function EE(n) {
  if (fa[n] !== void 0)
    return fa[n];
  const e = n * 2 + 1, t = n * n, i = new Array(t + 1);
  for (let r = 0; r <= n; ++r)
    for (let o = 0; o <= n; ++o) {
      const a = r * r + o * o;
      if (a > t)
        break;
      let l = i[a];
      l || (l = [], i[a] = l), l.push(((n + r) * e + (n + o)) * 4 + 3), r > 0 && l.push(((n - r) * e + (n + o)) * 4 + 3), o > 0 && (l.push(((n + r) * e + (n - o)) * 4 + 3), r > 0 && l.push(((n - r) * e + (n - o)) * 4 + 3));
    }
  const s = [];
  for (let r = 0, o = i.length; r < o; ++r)
    i[r] && s.push(...i[r]);
  return fa[n] = s, s;
}
const Hd = xE;
class CE extends Kd {
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
   */
  constructor(e, t, i, s, r, o, a) {
    super(), this.context_ = e, this.pixelRatio_ = t, this.extent_ = i, this.transform_ = s, this.transformRotation_ = s ? Zs(Math.atan2(s[1], s[0]), 10) : 0, this.viewRotation_ = r, this.squaredTolerance_ = o, this.userTransform_ = a, this.contextFillState_ = null, this.contextStrokeState_ = null, this.contextTextState_ = null, this.fillState_ = null, this.strokeState_ = null, this.image_ = null, this.imageAnchorX_ = 0, this.imageAnchorY_ = 0, this.imageHeight_ = 0, this.imageOpacity_ = 0, this.imageOriginX_ = 0, this.imageOriginY_ = 0, this.imageRotateWithView_ = !1, this.imageRotation_ = 0, this.imageScale_ = [0, 0], this.imageWidth_ = 0, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = !1, this.textRotation_ = 0, this.textScale_ = [0, 0], this.textFillState_ = null, this.textStrokeState_ = null, this.textState_ = null, this.pixelCoordinates_ = [], this.tmpLocalTransform_ = at();
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawImages_(e, t, i, s) {
    if (!this.image_)
      return;
    const r = bi(
      e,
      t,
      i,
      s,
      this.transform_,
      this.pixelCoordinates_
    ), o = this.context_, a = this.tmpLocalTransform_, l = o.globalAlpha;
    this.imageOpacity_ != 1 && (o.globalAlpha = l * this.imageOpacity_);
    let h = this.imageRotation_;
    this.transformRotation_ === 0 && (h -= this.viewRotation_), this.imageRotateWithView_ && (h += this.viewRotation_);
    for (let c = 0, u = r.length; c < u; c += 2) {
      const d = r[c] - this.imageAnchorX_, f = r[c + 1] - this.imageAnchorY_;
      if (h !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
        const g = d + this.imageAnchorX_, _ = f + this.imageAnchorY_;
        wt(
          a,
          g,
          _,
          1,
          1,
          h,
          -g,
          -_
        ), o.save(), o.transform.apply(o, a), o.translate(g, _), o.scale(this.imageScale_[0], this.imageScale_[1]), o.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          -this.imageAnchorX_,
          -this.imageAnchorY_,
          this.imageWidth_,
          this.imageHeight_
        ), o.restore();
      } else
        o.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          d,
          f,
          this.imageWidth_,
          this.imageHeight_
        );
    }
    this.imageOpacity_ != 1 && (o.globalAlpha = l);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawText_(e, t, i, s) {
    if (!this.textState_ || this.text_ === "")
      return;
    this.textFillState_ && this.setContextFillState_(this.textFillState_), this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_), this.setContextTextState_(this.textState_);
    const r = bi(
      e,
      t,
      i,
      s,
      this.transform_,
      this.pixelCoordinates_
    ), o = this.context_;
    let a = this.textRotation_;
    for (this.transformRotation_ === 0 && (a -= this.viewRotation_), this.textRotateWithView_ && (a += this.viewRotation_); t < i; t += s) {
      const l = r[t] + this.textOffsetX_, h = r[t + 1] + this.textOffsetY_;
      a !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1 ? (o.save(), o.translate(l - this.textOffsetX_, h - this.textOffsetY_), o.rotate(a), o.translate(this.textOffsetX_, this.textOffsetY_), o.scale(this.textScale_[0], this.textScale_[1]), this.textStrokeState_ && o.strokeText(this.text_, 0, 0), this.textFillState_ && o.fillText(this.text_, 0, 0), o.restore()) : (this.textStrokeState_ && o.strokeText(this.text_, l, h), this.textFillState_ && o.fillText(this.text_, l, h));
    }
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */
  moveToLineTo_(e, t, i, s, r) {
    const o = this.context_, a = bi(
      e,
      t,
      i,
      s,
      this.transform_,
      this.pixelCoordinates_
    );
    o.moveTo(a[0], a[1]);
    let l = a.length;
    r && (l -= 2);
    for (let h = 2; h < l; h += 2)
      o.lineTo(a[h], a[h + 1]);
    return r && o.closePath(), i;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawRings_(e, t, i, s) {
    for (let r = 0, o = i.length; r < o; ++r)
      t = this.moveToLineTo_(
        e,
        t,
        i[r],
        s,
        !0
      );
    return t;
  }
  /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @api
   */
  drawCircle(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/Circle.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!ye(this.extent_, e.getExtent())) {
      if (this.fillState_ || this.strokeState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const t = u_(
          e,
          this.transform_,
          this.pixelCoordinates_
        ), i = t[2] - t[0], s = t[3] - t[1], r = Math.sqrt(i * i + s * s), o = this.context_;
        o.beginPath(), o.arc(
          t[0],
          t[1],
          r,
          0,
          2 * Math.PI
        ), this.fillState_ && o.fill(), this.strokeState_ && o.stroke();
      }
      this.text_ !== "" && this.drawText_(e.getCenter(), 0, 2, 2);
    }
  }
  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @api
   */
  setStyle(e) {
    this.setFillStrokeStyle(e.getFill(), e.getStroke()), this.setImageStyle(e.getImage()), this.setTextStyle(e.getText());
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  setTransform(e) {
    this.transform_ = e;
  }
  /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @api
   */
  drawGeometry(e) {
    switch (e.getType()) {
      case "Point":
        this.drawPoint(
          /** @type {import("../../geom/Point.js").default} */
          e
        );
        break;
      case "LineString":
        this.drawLineString(
          /** @type {import("../../geom/LineString.js").default} */
          e
        );
        break;
      case "Polygon":
        this.drawPolygon(
          /** @type {import("../../geom/Polygon.js").default} */
          e
        );
        break;
      case "MultiPoint":
        this.drawMultiPoint(
          /** @type {import("../../geom/MultiPoint.js").default} */
          e
        );
        break;
      case "MultiLineString":
        this.drawMultiLineString(
          /** @type {import("../../geom/MultiLineString.js").default} */
          e
        );
        break;
      case "MultiPolygon":
        this.drawMultiPolygon(
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e
        );
        break;
      case "GeometryCollection":
        this.drawGeometryCollection(
          /** @type {import("../../geom/GeometryCollection.js").default} */
          e
        );
        break;
      case "Circle":
        this.drawCircle(
          /** @type {import("../../geom/Circle.js").default} */
          e
        );
        break;
    }
  }
  /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @api
   */
  drawFeature(e, t) {
    const i = t.getGeometryFunction()(e);
    i && (this.setStyle(t), this.drawGeometry(i));
  }
  /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   */
  drawGeometryCollection(e) {
    const t = e.getGeometriesArray();
    for (let i = 0, s = t.length; i < s; ++i)
      this.drawGeometry(t[i]);
  }
  /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   */
  drawPoint(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/Point.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const t = e.getFlatCoordinates(), i = e.getStride();
    this.image_ && this.drawImages_(t, 0, t.length, i), this.text_ !== "" && this.drawText_(t, 0, t.length, i);
  }
  /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   */
  drawMultiPoint(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiPoint.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const t = e.getFlatCoordinates(), i = e.getStride();
    this.image_ && this.drawImages_(t, 0, t.length, i), this.text_ !== "" && this.drawText_(t, 0, t.length, i);
  }
  /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   */
  drawLineString(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/LineString.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!ye(this.extent_, e.getExtent())) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const t = this.context_, i = e.getFlatCoordinates();
        t.beginPath(), this.moveToLineTo_(
          i,
          0,
          i.length,
          e.getStride(),
          !1
        ), t.stroke();
      }
      if (this.text_ !== "") {
        const t = e.getFlatMidpoint();
        this.drawText_(t, 0, 2, 2);
      }
    }
  }
  /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   */
  drawMultiLineString(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiLineString.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const t = e.getExtent();
    if (ye(this.extent_, t)) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const i = this.context_, s = e.getFlatCoordinates();
        let r = 0;
        const o = (
          /** @type {Array<number>} */
          e.getEnds()
        ), a = e.getStride();
        i.beginPath();
        for (let l = 0, h = o.length; l < h; ++l)
          r = this.moveToLineTo_(
            s,
            r,
            o[l],
            a,
            !1
          );
        i.stroke();
      }
      if (this.text_ !== "") {
        const i = e.getFlatMidpoints();
        this.drawText_(i, 0, i.length, 2);
      }
    }
  }
  /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   */
  drawPolygon(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/Polygon.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!ye(this.extent_, e.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const t = this.context_;
        t.beginPath(), this.drawRings_(
          e.getOrientedFlatCoordinates(),
          0,
          /** @type {Array<number>} */
          e.getEnds(),
          e.getStride()
        ), this.fillState_ && t.fill(), this.strokeState_ && t.stroke();
      }
      if (this.text_ !== "") {
        const t = e.getFlatInteriorPoint();
        this.drawText_(t, 0, 2, 2);
      }
    }
  }
  /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   */
  drawMultiPolygon(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiPolygon.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!ye(this.extent_, e.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const t = this.context_, i = e.getOrientedFlatCoordinates();
        let s = 0;
        const r = e.getEndss(), o = e.getStride();
        t.beginPath();
        for (let a = 0, l = r.length; a < l; ++a) {
          const h = r[a];
          s = this.drawRings_(i, s, h, o);
        }
        this.fillState_ && t.fill(), this.strokeState_ && t.stroke();
      }
      if (this.text_ !== "") {
        const t = e.getFlatInteriorPoints();
        this.drawText_(t, 0, t.length, 2);
      }
    }
  }
  /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */
  setContextFillState_(e) {
    const t = this.context_, i = this.contextFillState_;
    i ? i.fillStyle != e.fillStyle && (i.fillStyle = e.fillStyle, t.fillStyle = e.fillStyle) : (t.fillStyle = e.fillStyle, this.contextFillState_ = {
      fillStyle: e.fillStyle
    });
  }
  /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */
  setContextStrokeState_(e) {
    const t = this.context_, i = this.contextStrokeState_;
    i ? (i.lineCap != e.lineCap && (i.lineCap = e.lineCap, t.lineCap = e.lineCap), ri(i.lineDash, e.lineDash) || t.setLineDash(
      i.lineDash = e.lineDash
    ), i.lineDashOffset != e.lineDashOffset && (i.lineDashOffset = e.lineDashOffset, t.lineDashOffset = e.lineDashOffset), i.lineJoin != e.lineJoin && (i.lineJoin = e.lineJoin, t.lineJoin = e.lineJoin), i.lineWidth != e.lineWidth && (i.lineWidth = e.lineWidth, t.lineWidth = e.lineWidth), i.miterLimit != e.miterLimit && (i.miterLimit = e.miterLimit, t.miterLimit = e.miterLimit), i.strokeStyle != e.strokeStyle && (i.strokeStyle = e.strokeStyle, t.strokeStyle = e.strokeStyle)) : (t.lineCap = e.lineCap, t.setLineDash(e.lineDash), t.lineDashOffset = e.lineDashOffset, t.lineJoin = e.lineJoin, t.lineWidth = e.lineWidth, t.miterLimit = e.miterLimit, t.strokeStyle = e.strokeStyle, this.contextStrokeState_ = {
      lineCap: e.lineCap,
      lineDash: e.lineDash,
      lineDashOffset: e.lineDashOffset,
      lineJoin: e.lineJoin,
      lineWidth: e.lineWidth,
      miterLimit: e.miterLimit,
      strokeStyle: e.strokeStyle
    });
  }
  /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */
  setContextTextState_(e) {
    const t = this.context_, i = this.contextTextState_, s = e.textAlign ? e.textAlign : zs;
    i ? (i.font != e.font && (i.font = e.font, t.font = e.font), i.textAlign != s && (i.textAlign = s, t.textAlign = s), i.textBaseline != e.textBaseline && (i.textBaseline = e.textBaseline, t.textBaseline = e.textBaseline)) : (t.font = e.font, t.textAlign = s, t.textBaseline = e.textBaseline, this.contextTextState_ = {
      font: e.font,
      textAlign: s,
      textBaseline: e.textBaseline
    });
  }
  /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(e, t) {
    if (!e)
      this.fillState_ = null;
    else {
      const i = e.getColor();
      this.fillState_ = {
        fillStyle: At(
          i || Ye
        )
      };
    }
    if (!t)
      this.strokeState_ = null;
    else {
      const i = t.getColor(), s = t.getLineCap(), r = t.getLineDash(), o = t.getLineDashOffset(), a = t.getLineJoin(), l = t.getWidth(), h = t.getMiterLimit(), c = r || Jt;
      this.strokeState_ = {
        lineCap: s !== void 0 ? s : Xn,
        lineDash: this.pixelRatio_ === 1 ? c : c.map((u) => u * this.pixelRatio_),
        lineDashOffset: (o || Qt) * this.pixelRatio_,
        lineJoin: a !== void 0 ? a : Bn,
        lineWidth: (l !== void 0 ? l : $s) * this.pixelRatio_,
        miterLimit: h !== void 0 ? h : ks,
        strokeStyle: At(
          i || Gs
        )
      };
    }
  }
  /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   */
  setImageStyle(e) {
    let t;
    if (!e || !(t = e.getSize())) {
      this.image_ = null;
      return;
    }
    const i = e.getPixelRatio(this.pixelRatio_), s = e.getAnchor(), r = e.getOrigin();
    this.image_ = e.getImage(this.pixelRatio_), this.imageAnchorX_ = s[0] * i, this.imageAnchorY_ = s[1] * i, this.imageHeight_ = t[1] * i, this.imageOpacity_ = e.getOpacity(), this.imageOriginX_ = r[0], this.imageOriginY_ = r[1], this.imageRotateWithView_ = e.getRotateWithView(), this.imageRotation_ = e.getRotation();
    const o = e.getScaleArray();
    this.imageScale_ = [
      o[0] * this.pixelRatio_ / i,
      o[1] * this.pixelRatio_ / i
    ], this.imageWidth_ = t[0] * i;
  }
  /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   */
  setTextStyle(e) {
    if (!e)
      this.text_ = "";
    else {
      const t = e.getFill();
      if (!t)
        this.textFillState_ = null;
      else {
        const f = t.getColor();
        this.textFillState_ = {
          fillStyle: At(
            f || Ye
          )
        };
      }
      const i = e.getStroke();
      if (!i)
        this.textStrokeState_ = null;
      else {
        const f = i.getColor(), g = i.getLineCap(), _ = i.getLineDash(), m = i.getLineDashOffset(), p = i.getLineJoin(), y = i.getWidth(), x = i.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: g !== void 0 ? g : Xn,
          lineDash: _ || Jt,
          lineDashOffset: m || Qt,
          lineJoin: p !== void 0 ? p : Bn,
          lineWidth: y !== void 0 ? y : $s,
          miterLimit: x !== void 0 ? x : ks,
          strokeStyle: At(
            f || Gs
          )
        };
      }
      const s = e.getFont(), r = e.getOffsetX(), o = e.getOffsetY(), a = e.getRotateWithView(), l = e.getRotation(), h = e.getScaleArray(), c = e.getText(), u = e.getTextAlign(), d = e.getTextBaseline();
      this.textState_ = {
        font: s !== void 0 ? s : Zu,
        textAlign: u !== void 0 ? u : zs,
        textBaseline: d !== void 0 ? d : Br
      }, this.text_ = c !== void 0 ? Array.isArray(c) ? c.reduce((f, g, _) => f += _ % 2 ? " " : g, "") : c : "", this.textOffsetX_ = r !== void 0 ? this.pixelRatio_ * r : 0, this.textOffsetY_ = o !== void 0 ? this.pixelRatio_ * o : 0, this.textRotateWithView_ = a !== void 0 ? a : !1, this.textRotation_ = l !== void 0 ? l : 0, this.textScale_ = [
        this.pixelRatio_ * h[0],
        this.pixelRatio_ * h[1]
      ];
    }
  }
}
const wE = CE, qe = 0.5;
function qd(n, e, t, i, s, r, o, a, l) {
  const h = l ? yo(s) : s, c = n[0] * qe, u = n[1] * qe, d = Pe(c, u);
  d.imageSmoothingEnabled = !1;
  const f = d.canvas, g = new wE(
    d,
    qe,
    s,
    null,
    o,
    a,
    l ? Qs(Zg(), l) : null
  ), _ = t.length, m = Math.floor((256 * 256 * 256 - 1) / _), p = {};
  for (let x = 1; x <= _; ++x) {
    const E = t[x - 1], C = E.getStyleFunction() || i;
    if (!C)
      continue;
    let w = C(E, r);
    if (!w)
      continue;
    Array.isArray(w) || (w = [w]);
    const v = (x * m).toString(16).padStart(7, "#00000");
    for (let R = 0, b = w.length; R < b; ++R) {
      const A = w[R], N = A.getGeometryFunction()(E);
      if (!N || !ye(h, N.getExtent()))
        continue;
      const $ = A.clone(), V = $.getFill();
      V && V.setColor(v);
      const D = $.getStroke();
      D && (D.setColor(v), D.setLineDash(null)), $.setText(void 0);
      const L = A.getImage();
      if (L) {
        const q = L.getImageSize();
        if (!q)
          continue;
        const ae = Pe(
          q[0],
          q[1],
          void 0,
          { alpha: !1 }
        ), ee = ae.canvas;
        ae.fillStyle = v, ae.fillRect(0, 0, ee.width, ee.height), $.setImage(
          new vo({
            img: ee,
            anchor: L.getAnchor(),
            anchorXUnits: "pixels",
            anchorYUnits: "pixels",
            offset: L.getOrigin(),
            opacity: 1,
            size: L.getSize(),
            scale: L.getScale(),
            rotation: L.getRotation(),
            rotateWithView: L.getRotateWithView()
          })
        );
      }
      const Y = $.getZIndex() || 0;
      let W = p[Y];
      W || (W = {}, p[Y] = W, W.Polygon = [], W.Circle = [], W.LineString = [], W.Point = []);
      const oe = N.getType();
      if (oe === "GeometryCollection") {
        const q = (
          /** @type {import("../../geom/GeometryCollection.js").default} */
          N.getGeometriesArrayRecursive()
        );
        for (let ae = 0, ee = q.length; ae < ee; ++ae) {
          const xe = q[ae];
          W[xe.getType().replace("Multi", "")].push(
            xe,
            $
          );
        }
      } else
        W[oe.replace("Multi", "")].push(N, $);
    }
  }
  const y = Object.keys(p).map(Number).sort(ti);
  for (let x = 0, E = y.length; x < E; ++x) {
    const C = p[y[x]];
    for (const w in C) {
      const S = C[w];
      for (let v = 0, R = S.length; v < R; v += 2) {
        g.setStyle(S[v + 1]);
        for (let b = 0, A = e.length; b < A; ++b)
          g.setTransform(e[b]), g.drawGeometry(S[v]);
      }
    }
  }
  return d.getImageData(0, 0, f.width, f.height);
}
function Jd(n, e, t) {
  const i = [];
  if (t) {
    const s = Math.floor(Math.round(n[0]) * qe), r = Math.floor(Math.round(n[1]) * qe), o = (_e(s, 0, t.width - 1) + _e(r, 0, t.height - 1) * t.width) * 4, a = t.data[o], l = t.data[o + 1], c = t.data[o + 2] + 256 * (l + 256 * a), u = Math.floor((256 * 256 * 256 - 1) / e.length);
    c && c % u === 0 && i.push(e[c / u - 1]);
  }
  return i;
}
const SE = 0.5, Qd = {
  Point: AE,
  LineString: PE,
  Polygon: ME,
  MultiPoint: FE,
  MultiLineString: LE,
  MultiPolygon: bE,
  GeometryCollection: IE,
  Circle: TE
};
function vE(n, e) {
  return parseInt(j(n), 10) - parseInt(j(e), 10);
}
function Za(n, e) {
  const t = ef(n, e);
  return t * t;
}
function ef(n, e) {
  return SE * n / e;
}
function TE(n, e, t, i) {
  const s = t.getFill(), r = t.getStroke();
  if (s || r) {
    const a = n.getBuilder(t.getZIndex(), "Circle");
    a.setFillStrokeStyle(s, r), a.drawCircle(e, i);
  }
  const o = t.getText();
  if (o && o.getText()) {
    const a = n.getBuilder(t.getZIndex(), "Text");
    a.setTextStyle(o), a.drawText(e, i);
  }
}
function lo(n, e, t, i, s, r, o, a) {
  const l = [], h = t.getImage();
  if (h) {
    let d = !0;
    const f = h.getImageState();
    f == M.LOADED || f == M.ERROR ? d = !1 : f == M.IDLE && h.load(), d && l.push(h.ready());
  }
  const c = t.getFill();
  c && c.loading() && l.push(c.ready());
  const u = l.length > 0;
  return u && Promise.all(l).then(() => s(null)), RE(
    n,
    e,
    t,
    i,
    r,
    o,
    a
  ), u;
}
function RE(n, e, t, i, s, r, o) {
  const a = t.getGeometryFunction()(e);
  if (!a)
    return;
  const l = a.simplifyTransformed(
    i,
    s
  );
  if (t.getRenderer())
    tf(n, l, t, e, o);
  else {
    const c = Qd[l.getType()];
    c(
      n,
      l,
      t,
      e,
      o,
      r
    );
  }
}
function tf(n, e, t, i, s) {
  if (e.getType() == "GeometryCollection") {
    const o = (
      /** @type {import("../geom/GeometryCollection.js").default} */
      e.getGeometries()
    );
    for (let a = 0, l = o.length; a < l; ++a)
      tf(n, o[a], t, i, s);
    return;
  }
  n.getBuilder(t.getZIndex(), "Default").drawCustom(
    /** @type {import("../geom/SimpleGeometry.js").default} */
    e,
    i,
    t.getRenderer(),
    t.getHitDetectionRenderer(),
    s
  );
}
function IE(n, e, t, i, s, r) {
  const o = e.getGeometriesArray();
  let a, l;
  for (a = 0, l = o.length; a < l; ++a) {
    const h = Qd[o[a].getType()];
    h(
      n,
      o[a],
      t,
      i,
      s,
      r
    );
  }
}
function PE(n, e, t, i, s) {
  const r = t.getStroke();
  if (r) {
    const a = n.getBuilder(
      t.getZIndex(),
      "LineString"
    );
    a.setFillStrokeStyle(null, r), a.drawLineString(e, i, s);
  }
  const o = t.getText();
  if (o && o.getText()) {
    const a = n.getBuilder(t.getZIndex(), "Text");
    a.setTextStyle(o), a.drawText(e, i, s);
  }
}
function LE(n, e, t, i, s) {
  const r = t.getStroke();
  if (r) {
    const a = n.getBuilder(
      t.getZIndex(),
      "LineString"
    );
    a.setFillStrokeStyle(null, r), a.drawMultiLineString(e, i, s);
  }
  const o = t.getText();
  if (o && o.getText()) {
    const a = n.getBuilder(t.getZIndex(), "Text");
    a.setTextStyle(o), a.drawText(e, i, s);
  }
}
function bE(n, e, t, i, s) {
  const r = t.getFill(), o = t.getStroke();
  if (o || r) {
    const l = n.getBuilder(t.getZIndex(), "Polygon");
    l.setFillStrokeStyle(r, o), l.drawMultiPolygon(e, i, s);
  }
  const a = t.getText();
  if (a && a.getText()) {
    const l = n.getBuilder(t.getZIndex(), "Text");
    l.setTextStyle(a), l.drawText(e, i, s);
  }
}
function AE(n, e, t, i, s, r) {
  const o = t.getImage(), a = t.getText(), l = a && a.getText(), h = r && o && l ? {} : void 0;
  if (o) {
    if (o.getImageState() != M.LOADED)
      return;
    const c = n.getBuilder(t.getZIndex(), "Image");
    c.setImageStyle(o, h), c.drawPoint(e, i, s);
  }
  if (l) {
    const c = n.getBuilder(t.getZIndex(), "Text");
    c.setTextStyle(a, h), c.drawText(e, i, s);
  }
}
function FE(n, e, t, i, s, r) {
  const o = t.getImage(), a = o && o.getOpacity() !== 0, l = t.getText(), h = l && l.getText(), c = r && a && h ? {} : void 0;
  if (a) {
    if (o.getImageState() != M.LOADED)
      return;
    const u = n.getBuilder(t.getZIndex(), "Image");
    u.setImageStyle(o, c), u.drawMultiPoint(e, i, s);
  }
  if (h) {
    const u = n.getBuilder(t.getZIndex(), "Text");
    u.setTextStyle(l, c), u.drawText(e, i, s);
  }
}
function ME(n, e, t, i, s) {
  const r = t.getFill(), o = t.getStroke();
  if (r || o) {
    const l = n.getBuilder(t.getZIndex(), "Polygon");
    l.setFillStrokeStyle(r, o), l.drawPolygon(e, i, s);
  }
  const a = t.getText();
  if (a && a.getText()) {
    const l = n.getBuilder(t.getZIndex(), "Text");
    l.setTextStyle(a), l.drawText(e, i, s);
  }
}
class OE extends hh {
  /**
   * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
   */
  constructor(e) {
    super(e), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.animatingOrInteracting_, this.hitDetectionImageData_ = null, this.renderedFeatures_ = null, this.renderedRevision_ = -1, this.renderedResolution_ = NaN, this.renderedExtent_ = Je(), this.wrappedRenderedExtent_ = Je(), this.renderedRotation_, this.renderedCenter_ = null, this.renderedProjection_ = null, this.renderedPixelRatio_ = 1, this.renderedRenderOrder_ = null, this.replayGroup_ = null, this.replayGroupChanged = !0, this.clipping = !0, this.compositionContext_ = null, this.opacity_ = 1;
  }
  /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {boolean} [declutterable] `true` to only render declutterable items,
   *     `false` to only render non-declutterable items, `undefined` to render all.
   */
  renderWorlds(e, t, i) {
    const s = t.extent, r = t.viewState, o = r.center, a = r.resolution, l = r.projection, h = r.rotation, c = l.getExtent(), u = this.getLayer().getSource(), d = this.getLayer().getDeclutter(), f = t.pixelRatio, g = t.viewHints, _ = !(g[de.ANIMATING] || g[de.INTERACTING]), m = this.compositionContext_, p = Math.round(t.size[0] * f), y = Math.round(t.size[1] * f), x = u.getWrapX() && l.canWrapX(), E = x ? ie(c) : null, C = x ? Math.ceil((s[2] - c[2]) / E) + 1 : 1;
    let w = x ? Math.floor((s[0] - c[0]) / E) : 0;
    do {
      const S = this.getRenderTransform(
        o,
        a,
        h,
        f,
        p,
        y,
        w * E
      );
      e.execute(
        m,
        [m.canvas.width, m.canvas.height],
        S,
        h,
        _,
        i === void 0 ? Is : i ? ao : yE,
        i ? d && t.declutter[d] : void 0
      );
    } while (++w < C);
  }
  setupCompositionContext_() {
    if (this.opacity_ !== 1) {
      const e = Pe(
        this.context.canvas.width,
        this.context.canvas.height,
        Pc
      );
      this.compositionContext_ = e;
    } else
      this.compositionContext_ = this.context;
  }
  releaseCompositionContext_() {
    if (this.opacity_ !== 1) {
      const e = this.context.globalAlpha;
      this.context.globalAlpha = this.opacity_, this.context.drawImage(this.compositionContext_.canvas, 0, 0), this.context.globalAlpha = e, ir(this.compositionContext_), Pc.push(this.compositionContext_.canvas), this.compositionContext_ = null;
    }
  }
  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(e) {
    this.getLayer().getDeclutter() && (this.setupCompositionContext_(), this.renderWorlds(this.replayGroup_, e, !0), this.releaseCompositionContext_());
  }
  /**
   * Render deferred instructions.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeferredInternal(e) {
    this.replayGroup_.renderDeferred();
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement|null} The rendered element.
   */
  renderFrame(e, t) {
    const i = e.pixelRatio, s = e.layerStatesArray[e.layerIndex];
    r_(this.pixelTransform, 1 / i, 1 / i), Eo(this.inversePixelTransform, this.pixelTransform);
    const r = yl(this.pixelTransform);
    this.useContainer(t, r, this.getBackground(e));
    const o = this.context, a = o.canvas, l = this.replayGroup_;
    let h = l && !l.isEmpty();
    if (!h && !(this.getLayer().hasListener(st.PRERENDER) || this.getLayer().hasListener(st.POSTRENDER)))
      return null;
    const c = Math.round(e.size[0] * i), u = Math.round(e.size[1] * i);
    a.width != c || a.height != u ? (a.width = c, a.height = u, a.style.transform !== r && (a.style.transform = r)) : this.containerReused || o.clearRect(0, 0, c, u), this.preRender(o, e);
    const d = e.viewState;
    d.projection, this.opacity_ = s.opacity, this.setupCompositionContext_();
    let f = !1;
    if (h && s.extent && this.clipping) {
      const g = Et(s.extent);
      h = ye(g, e.extent), f = h && !rt(g, e.extent), f && this.clipUnrotated(this.compositionContext_, e, g);
    }
    return h && this.renderWorlds(
      l,
      e,
      this.getLayer().getDeclutter() ? !1 : void 0
    ), f && this.compositionContext_.restore(), this.releaseCompositionContext_(), this.postRender(o, e), this.renderedRotation_ !== d.rotation && (this.renderedRotation_ = d.rotation, this.hitDetectionImageData_ = null), this.container;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise
   * that resolves with an array of features.
   */
  getFeatures(e) {
    return new Promise((t) => {
      if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
        const i = [this.context.canvas.width, this.context.canvas.height];
        Se(this.pixelTransform, i);
        const s = this.renderedCenter_, r = this.renderedResolution_, o = this.renderedRotation_, a = this.renderedProjection_, l = this.wrappedRenderedExtent_, h = this.getLayer(), c = [], u = i[0] * qe, d = i[1] * qe;
        c.push(
          this.getRenderTransform(
            s,
            r,
            o,
            qe,
            u,
            d,
            0
          ).slice()
        );
        const f = h.getSource(), g = a.getExtent();
        if (f.getWrapX() && a.canWrapX() && !rt(g, l)) {
          let _ = l[0];
          const m = ie(g);
          let p = 0, y;
          for (; _ < g[0]; )
            --p, y = m * p, c.push(
              this.getRenderTransform(
                s,
                r,
                o,
                qe,
                u,
                d,
                y
              ).slice()
            ), _ += m;
          for (p = 0, _ = l[2]; _ > g[2]; )
            ++p, y = m * p, c.push(
              this.getRenderTransform(
                s,
                r,
                o,
                qe,
                u,
                d,
                y
              ).slice()
            ), _ -= m;
        }
        this.hitDetectionImageData_ = qd(
          i,
          c,
          this.renderedFeatures_,
          h.getStyleFunction(),
          l,
          r,
          o,
          Za(r, this.renderedPixelRatio_),
          null
        );
      }
      t(
        Jd(e, this.renderedFeatures_, this.hitDetectionImageData_)
      );
    });
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, i, s, r) {
    if (!this.replayGroup_)
      return;
    const o = t.viewState.resolution, a = t.viewState.rotation, l = this.getLayer(), h = {}, c = function(g, _, m) {
      const p = j(g), y = h[p];
      if (y) {
        if (y !== !0 && m < y.distanceSq) {
          if (m === 0)
            return h[p] = !0, r.splice(r.lastIndexOf(y), 1), s(g, l, _);
          y.geometry = _, y.distanceSq = m;
        }
      } else {
        if (m === 0)
          return h[p] = !0, s(g, l, _);
        r.push(
          h[p] = {
            feature: g,
            layer: l,
            geometry: _,
            distanceSq: m,
            callback: s
          }
        );
      }
    };
    let u;
    const d = [this.replayGroup_], f = this.getLayer().getDeclutter();
    return d.some((g) => u = g.forEachFeatureAtCoordinate(
      e,
      o,
      a,
      i,
      c,
      f && t.declutter[f] ? t.declutter[f].all().map((_) => _.value) : null
    )), u;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */
  handleFontsChanged() {
    const e = this.getLayer();
    e.getVisible() && this.replayGroup_ && e.changed();
  }
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(e) {
    this.renderIfReadyAndVisible();
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    const t = this.getLayer(), i = t.getSource();
    if (!i)
      return !1;
    const s = e.viewHints[de.ANIMATING], r = e.viewHints[de.INTERACTING], o = t.getUpdateWhileAnimating(), a = t.getUpdateWhileInteracting();
    if (this.ready && !o && s || !a && r)
      return this.animatingOrInteracting_ = !0, !0;
    this.animatingOrInteracting_ = !1;
    const l = e.extent, h = e.viewState, c = h.projection, u = h.resolution, d = e.pixelRatio, f = t.getRevision(), g = t.getRenderBuffer();
    let _ = t.getRenderOrder();
    _ === void 0 && (_ = vE);
    const m = h.center.slice(), p = ot(
      l,
      g * u
    ), y = p.slice(), x = [p.slice()], E = c.getExtent();
    if (i.getWrapX() && c.canWrapX() && !rt(E, e.extent)) {
      const V = ie(E), D = Math.max(ie(p) / 2, V);
      p[0] = E[0] - D, p[2] = E[2] + D, mo(m, c);
      const L = fu(x[0], c);
      L[0] < E[0] && L[2] < E[2] ? x.push([
        L[0] + V,
        L[1],
        L[2] + V,
        L[3]
      ]) : L[0] > E[0] && L[2] > E[2] && x.push([
        L[0] - V,
        L[1],
        L[2] - V,
        L[3]
      ]);
    }
    if (this.ready && this.renderedResolution_ == u && this.renderedRevision_ == f && this.renderedRenderOrder_ == _ && rt(this.wrappedRenderedExtent_, p))
      return ri(this.renderedExtent_, y) || (this.hitDetectionImageData_ = null, this.renderedExtent_ = y), this.renderedCenter_ = m, this.replayGroupChanged = !1, !0;
    this.replayGroup_ = null;
    const C = new Zd(
      ef(u, d),
      p,
      u,
      d
    );
    let w;
    for (let V = 0, D = x.length; V < D; ++V)
      i.loadFeatures(x[V], u, c);
    const S = Za(u, d);
    let v = !0;
    const R = (
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {number} index Index.
       */
      (V, D) => {
        let L;
        const Y = V.getStyleFunction() || t.getStyleFunction();
        if (Y && (L = Y(V, u)), L) {
          const W = this.renderFeature(
            V,
            S,
            L,
            C,
            w,
            this.getLayer().getDeclutter(),
            D
          );
          v = v && !W;
        }
      }
    ), b = yo(p), A = i.getFeaturesInExtent(b);
    _ && A.sort(_);
    for (let V = 0, D = A.length; V < D; ++V)
      R(A[V], V);
    this.renderedFeatures_ = A, this.ready = v;
    const N = C.finish(), $ = new Hd(
      p,
      u,
      d,
      i.getOverlaps(),
      N,
      t.getRenderBuffer(),
      !!e.declutter
    );
    return this.renderedResolution_ = u, this.renderedRevision_ = f, this.renderedRenderOrder_ = _, this.renderedExtent_ = y, this.wrappedRenderedExtent_ = p, this.renderedCenter_ = m, this.renderedProjection_ = c, this.renderedPixelRatio_ = d, this.replayGroup_ = $, this.hitDetectionImageData_ = null, this.replayGroupChanged = !0, !0;
  }
  /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} squaredTolerance Squared render tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
   * @param {boolean} [declutter] Enable decluttering.
   * @param {number} [index] Render order index.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(e, t, i, s, r, o, a) {
    if (!i)
      return !1;
    let l = !1;
    if (Array.isArray(i))
      for (let h = 0, c = i.length; h < c; ++h)
        l = lo(
          s,
          e,
          i[h],
          t,
          this.boundHandleStyleImageChange_,
          r,
          o,
          a
        ) || l;
    else
      l = lo(
        s,
        e,
        i,
        t,
        this.boundHandleStyleImageChange_,
        r,
        o,
        a
      );
    return l;
  }
}
const DE = OE;
class NE extends Bl {
  /**
   * @param {import("./BaseVector.js").Options<VectorSourceType>} [options] Options.
   */
  constructor(e) {
    super(e);
  }
  createRenderer() {
    return new DE(this);
  }
}
const ch = NE;
class kE {
  /**
   * @param {number} [maxEntries] Max entries.
   */
  constructor(e) {
    this.rbush_ = new Du(e), this.items_ = {};
  }
  /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  insert(e, t) {
    const i = {
      minX: e[0],
      minY: e[1],
      maxX: e[2],
      maxY: e[3],
      value: t
    };
    this.rbush_.insert(i), this.items_[j(t)] = i;
  }
  /**
   * Bulk-insert values into the RBush.
   * @param {Array<import("../extent.js").Extent>} extents Extents.
   * @param {Array<T>} values Values.
   */
  load(e, t) {
    const i = new Array(t.length);
    for (let s = 0, r = t.length; s < r; s++) {
      const o = e[s], a = t[s], l = {
        minX: o[0],
        minY: o[1],
        maxX: o[2],
        maxY: o[3],
        value: a
      };
      i[s] = l, this.items_[j(a)] = l;
    }
    this.rbush_.load(i);
  }
  /**
   * Remove a value from the RBush.
   * @param {T} value Value.
   * @return {boolean} Removed.
   */
  remove(e) {
    const t = j(e), i = this.items_[t];
    return delete this.items_[t], this.rbush_.remove(i) !== null;
  }
  /**
   * Update the extent of a value in the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  update(e, t) {
    const i = this.items_[j(t)], s = [i.minX, i.minY, i.maxX, i.maxY];
    Mi(s, e) || (this.remove(t), this.insert(e, t));
  }
  /**
   * Return all values in the RBush.
   * @return {Array<T>} All.
   */
  getAll() {
    return this.rbush_.all().map(function(t) {
      return t.value;
    });
  }
  /**
   * Return all values in the given extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<T>} All in extent.
   */
  getInExtent(e) {
    const t = {
      minX: e[0],
      minY: e[1],
      maxX: e[2],
      maxY: e[3]
    };
    return this.rbush_.search(t).map(function(s) {
      return s.value;
    });
  }
  /**
   * Calls a callback function with each value in the tree.
   * If the callback returns a truthy value, this value is returned without
   * checking the rest of the tree.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEach(e) {
    return this.forEach_(this.getAll(), e);
  }
  /**
   * Calls a callback function with each value in the provided extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEachInExtent(e, t) {
    return this.forEach_(this.getInExtent(e), t);
  }
  /**
   * @param {Array<T>} values Values.
   * @param {function(T): *} callback Callback.
   * @private
   * @return {*} Callback return value.
   */
  forEach_(e, t) {
    let i;
    for (let s = 0, r = e.length; s < r; s++)
      if (i = t(e[s]), i)
        return i;
    return i;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return Fi(this.items_);
  }
  /**
   * Remove all values from the RBush.
   */
  clear() {
    this.rbush_.clear(), this.items_ = {};
  }
  /**
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} Extent.
   */
  getExtent(e) {
    const t = this.rbush_.toJSON();
    return ii(t.minX, t.minY, t.maxX, t.maxY, e);
  }
  /**
   * @param {RBush} rbush R-Tree.
   */
  concat(e) {
    this.rbush_.load(e.rbush_.all());
    for (const t in e.items_)
      this.items_[t] = e.items_[t];
  }
}
const Ha = kE;
class GE extends vt {
  /**
   * @param {Options} options Source options.
   */
  constructor(e) {
    super(), this.projection = ce(e.projection), this.attributions_ = Ac(e.attributions), this.attributionsCollapsible_ = e.attributionsCollapsible !== void 0 ? e.attributionsCollapsible : !0, this.loading = !1, this.state_ = e.state !== void 0 ? e.state : "ready", this.wrapX_ = e.wrapX !== void 0 ? e.wrapX : !1, this.interpolate_ = !!e.interpolate, this.viewResolver = null, this.viewRejector = null;
    const t = this;
    this.viewPromise_ = new Promise(function(i, s) {
      t.viewResolver = i, t.viewRejector = s;
    });
  }
  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */
  getAttributions() {
    return this.attributions_;
  }
  /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */
  getAttributionsCollapsible() {
    return this.attributionsCollapsible_;
  }
  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default|null} Projection.
   * @api
   */
  getProjection() {
    return this.projection;
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(e) {
    return null;
  }
  /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */
  getView() {
    return this.viewPromise_;
  }
  /**
   * Get the state of the source, see {@link import("./Source.js").State} for possible states.
   * @return {import("./Source.js").State} State.
   * @api
   */
  getState() {
    return this.state_;
  }
  /**
   * @return {boolean|undefined} Wrap X.
   */
  getWrapX() {
    return this.wrapX_;
  }
  /**
   * @return {boolean} Use linear interpolation when resampling.
   */
  getInterpolate() {
    return this.interpolate_;
  }
  /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */
  refresh() {
    this.changed();
  }
  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */
  setAttributions(e) {
    this.attributions_ = Ac(e), this.changed();
  }
  /**
   * Set the state of the source.
   * @param {import("./Source.js").State} state State.
   */
  setState(e) {
    this.state_ = e, this.changed();
  }
}
function Ac(n) {
  return n ? Array.isArray(n) ? function(e) {
    return n;
  } : typeof n == "function" ? n : function(e) {
    return [n];
  } : null;
}
const uh = GE, Ze = {
  /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: "addfeature",
  /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: "changefeature",
  /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: "clear",
  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: "removefeature",
  /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */
  FEATURESLOADSTART: "featuresloadstart",
  /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */
  FEATURESLOADEND: "featuresloadend",
  /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */
  FEATURESLOADERROR: "featuresloaderror"
};
function zE(n, e) {
  return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]];
}
let $E = !1;
function nf(n, e, t, i, s, r, o) {
  const a = new XMLHttpRequest();
  a.open(
    "GET",
    typeof n == "function" ? n(t, i, s) : n,
    !0
  ), e.getType() == "arraybuffer" && (a.responseType = "arraybuffer"), a.withCredentials = $E, a.onload = function(l) {
    if (!a.status || a.status >= 200 && a.status < 300) {
      const h = e.getType();
      let c;
      h == "json" ? c = JSON.parse(a.responseText) : h == "text" ? c = a.responseText : h == "xml" ? (c = a.responseXML, c || (c = new DOMParser().parseFromString(
        a.responseText,
        "application/xml"
      ))) : h == "arraybuffer" && (c = /** @type {ArrayBuffer} */
      a.response), c ? r(
        /** @type {Array<import("./Feature.js").default>} */
        e.readFeatures(c, {
          extent: t,
          featureProjection: s
        }),
        e.readProjection(c)
      ) : o();
    } else
      o();
  }, a.onerror = o, a.send();
}
function Fc(n, e) {
  return function(t, i, s, r, o) {
    const a = (
      /** @type {import("./source/Vector").default} */
      this
    );
    nf(
      n,
      e,
      t,
      i,
      s,
      /**
       * @param {Array<import("./Feature.js").default>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */
      function(l, h) {
        a.addFeatures(l), r !== void 0 && r(l);
      },
      /* FIXME handle error */
      o || Gn
    );
  };
}
class gi extends dt {
  /**
   * @param {string} type Type.
   * @param {FeatureClass} [feature] Feature.
   * @param {Array<FeatureClass>} [features] Features.
   */
  constructor(e, t, i) {
    super(e), this.feature = t, this.features = i;
  }
}
class UE extends uh {
  /**
   * @param {Options<FeatureType>} [options] Vector source options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      interpolate: !0,
      projection: void 0,
      state: "ready",
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0
    }), this.on, this.once, this.un, this.loader_ = Gn, this.format_ = e.format, this.overlaps_ = e.overlaps === void 0 ? !0 : e.overlaps, this.url_ = e.url, e.loader !== void 0 ? this.loader_ = e.loader : this.url_ !== void 0 && (Q(this.format_, "`format` must be set when `url` is set"), this.loader_ = Fc(
      this.url_,
      /** @type {import("../format/Feature.js").default} */
      this.format_
    )), this.strategy_ = e.strategy !== void 0 ? e.strategy : zE;
    const t = e.useSpatialIndex !== void 0 ? e.useSpatialIndex : !0;
    this.featuresRtree_ = t ? new Ha() : null, this.loadedExtentsRtree_ = new Ha(), this.loadingExtentsCount_ = 0, this.nullGeometryFeatures_ = {}, this.idIndex_ = {}, this.uidIndex_ = {}, this.featureChangeKeys_ = {}, this.featuresCollection_ = null;
    let i, s;
    Array.isArray(e.features) ? s = e.features : e.features && (i = e.features, s = i.getArray()), !t && i === void 0 && (i = new ze(s)), s !== void 0 && this.addFeaturesInternal(s), i !== void 0 && this.bindFeaturesCollection_(i);
  }
  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if an {@link module:ol/Collection~Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {FeatureType} feature Feature to add.
   * @api
   */
  addFeature(e) {
    this.addFeatureInternal(e), this.changed();
  }
  /**
   * Add a feature without firing a `change` event.
   * @param {FeatureType} feature Feature.
   * @protected
   */
  addFeatureInternal(e) {
    const t = j(e);
    if (!this.addToIndex_(t, e)) {
      this.featuresCollection_ && this.featuresCollection_.remove(e);
      return;
    }
    this.setupChangeEvents_(t, e);
    const i = e.getGeometry();
    if (i) {
      const s = i.getExtent();
      this.featuresRtree_ && this.featuresRtree_.insert(s, e);
    } else
      this.nullGeometryFeatures_[t] = e;
    this.dispatchEvent(
      new gi(Ze.ADDFEATURE, e)
    );
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureType} feature The feature.
   * @private
   */
  setupChangeEvents_(e, t) {
    t instanceof mt || (this.featureChangeKeys_[e] = [
      Z(t, G.CHANGE, this.handleFeatureChange_, this),
      Z(
        t,
        Ji.PROPERTYCHANGE,
        this.handleFeatureChange_,
        this
      )
    ]);
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureType} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */
  addToIndex_(e, t) {
    let i = !0;
    if (t.getId() !== void 0) {
      const s = String(t.getId());
      if (!(s in this.idIndex_))
        this.idIndex_[s] = t;
      else if (t instanceof mt) {
        const r = this.idIndex_[s];
        r instanceof mt ? Array.isArray(r) ? r.push(t) : this.idIndex_[s] = [r, t] : i = !1;
      } else
        i = !1;
    }
    return i && (Q(
      !(e in this.uidIndex_),
      "The passed `feature` was already added to the source"
    ), this.uidIndex_[e] = t), i;
  }
  /**
   * Add a batch of features to the source.
   * @param {Array<FeatureType>} features Features to add.
   * @api
   */
  addFeatures(e) {
    this.addFeaturesInternal(e), this.changed();
  }
  /**
   * Add features without firing a `change` event.
   * @param {Array<FeatureType>} features Features.
   * @protected
   */
  addFeaturesInternal(e) {
    const t = [], i = [], s = [];
    for (let r = 0, o = e.length; r < o; r++) {
      const a = e[r], l = j(a);
      this.addToIndex_(l, a) && i.push(a);
    }
    for (let r = 0, o = i.length; r < o; r++) {
      const a = i[r], l = j(a);
      this.setupChangeEvents_(l, a);
      const h = a.getGeometry();
      if (h) {
        const c = h.getExtent();
        t.push(c), s.push(a);
      } else
        this.nullGeometryFeatures_[l] = a;
    }
    if (this.featuresRtree_ && this.featuresRtree_.load(t, s), this.hasListener(Ze.ADDFEATURE))
      for (let r = 0, o = i.length; r < o; r++)
        this.dispatchEvent(
          new gi(Ze.ADDFEATURE, i[r])
        );
  }
  /**
   * @param {!Collection<FeatureType>} collection Collection.
   * @private
   */
  bindFeaturesCollection_(e) {
    let t = !1;
    this.addEventListener(
      Ze.ADDFEATURE,
      /**
       * @param {VectorSourceEvent<FeatureType>} evt The vector source event
       */
      function(i) {
        t || (t = !0, e.push(i.feature), t = !1);
      }
    ), this.addEventListener(
      Ze.REMOVEFEATURE,
      /**
       * @param {VectorSourceEvent<FeatureType>} evt The vector source event
       */
      function(i) {
        t || (t = !0, e.remove(i.feature), t = !1);
      }
    ), e.addEventListener(
      Fe.ADD,
      /**
       * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
       */
      (i) => {
        t || (t = !0, this.addFeature(i.element), t = !1);
      }
    ), e.addEventListener(
      Fe.REMOVE,
      /**
       * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
       */
      (i) => {
        t || (t = !0, this.removeFeature(i.element), t = !1);
      }
    ), this.featuresCollection_ = e;
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
   * @api
   */
  clear(e) {
    if (e) {
      for (const i in this.featureChangeKeys_)
        this.featureChangeKeys_[i].forEach(he);
      this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.uidIndex_ = {});
    } else if (this.featuresRtree_) {
      const i = (s) => {
        this.removeFeatureInternal(s);
      };
      this.featuresRtree_.forEach(i);
      for (const s in this.nullGeometryFeatures_)
        this.removeFeatureInternal(this.nullGeometryFeatures_[s]);
    }
    this.featuresCollection_ && this.featuresCollection_.clear(), this.featuresRtree_ && this.featuresRtree_.clear(), this.nullGeometryFeatures_ = {};
    const t = new gi(Ze.CLEAR);
    this.dispatchEvent(t), this.changed();
  }
  /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(FeatureType): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeature(e) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEach(e);
    this.featuresCollection_ && this.featuresCollection_.forEach(e);
  }
  /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be
   * called for all features.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */
  forEachFeatureAtCoordinateDirect(e, t) {
    const i = [e[0], e[1], e[0], e[1]];
    return this.forEachFeatureInExtent(i, function(s) {
      const r = s.getGeometry();
      if (r instanceof mt || r.intersectsCoordinate(e))
        return t(s);
    });
  }
  /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureInExtent(e, t) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEachInExtent(e, t);
    this.featuresCollection_ && this.featuresCollection_.forEach(t);
  }
  /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureIntersectingExtent(e, t) {
    return this.forEachFeatureInExtent(
      e,
      /**
       * @param {FeatureType} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */
      function(i) {
        const s = i.getGeometry();
        if (s instanceof mt || s.intersectsExtent(e)) {
          const r = t(i);
          if (r)
            return r;
        }
      }
    );
  }
  /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with an {@link module:ol/Collection~Collection} as `features`.
   * @return {Collection<FeatureType>|null} The collection of features.
   * @api
   */
  getFeaturesCollection() {
    return this.featuresCollection_;
  }
  /**
   * Get a snapshot of the features currently on the source in random order. The returned array
   * is a copy, the features are references to the features in the source.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeatures() {
    let e;
    return this.featuresCollection_ ? e = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (e = this.featuresRtree_.getAll(), Fi(this.nullGeometryFeatures_) || se(e, Object.values(this.nullGeometryFeatures_))), e;
  }
  /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  getFeaturesAtCoordinate(e) {
    const t = [];
    return this.forEachFeatureAtCoordinateDirect(e, function(i) {
      t.push(i);
    }), t;
  }
  /**
   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * When `useSpatialIndex` is set to false, this method will return all
   * features.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../proj/Projection.js").default} [projection] Include features
   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeaturesInExtent(e, t) {
    if (this.featuresRtree_) {
      if (!(t && t.canWrapX() && this.getWrapX()))
        return this.featuresRtree_.getInExtent(e);
      const s = Gg(e, t);
      return [].concat(
        ...s.map((r) => this.featuresRtree_.getInExtent(r))
      );
    }
    return this.featuresCollection_ ? this.featuresCollection_.getArray().slice(0) : [];
  }
  /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false` and the features in this source are of type
   * {@link module:ol/Feature~Feature}.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureType):boolean} [filter] Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {FeatureType} Closest feature.
   * @api
   */
  getClosestFeatureToCoordinate(e, t) {
    const i = e[0], s = e[1];
    let r = null;
    const o = [NaN, NaN];
    let a = 1 / 0;
    const l = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
    return t = t || kn, this.featuresRtree_.forEachInExtent(
      l,
      /**
       * @param {FeatureType} feature Feature.
       */
      function(h) {
        if (t(h)) {
          const c = h.getGeometry(), u = a;
          if (a = c instanceof mt ? 0 : c.closestPointXY(i, s, o, a), a < u) {
            r = h;
            const d = Math.sqrt(a);
            l[0] = i - d, l[1] = s - d, l[2] = i + d, l[3] = s + d;
          }
        }
      }
    ), r;
  }
  /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent(e) {
    return this.featuresRtree_.getExtent(e);
  }
  /**
   * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s
   * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling
   * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per
   * `GeometryCollection` member.
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {FeatureClassOrArrayOfRenderFeatures<FeatureType>|null} The feature (or `null` if not found).
   * @api
   */
  getFeatureById(e) {
    const t = this.idIndex_[e.toString()];
    return t !== void 0 ? (
      /** @type {FeatureClassOrArrayOfRenderFeatures<FeatureType>} */
      t
    ) : null;
  }
  /**
   * Get a feature by its internal unique identifier (using `getUid`).
   *
   * @param {string} uid Feature identifier.
   * @return {FeatureType|null} The feature (or `null` if not found).
   */
  getFeatureByUid(e) {
    const t = this.uidIndex_[e];
    return t !== void 0 ? t : null;
  }
  /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default<import('../format/Feature.js').FeatureToFeatureClass<FeatureType>>|undefined} The feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  getOverlaps() {
    return this.overlaps_;
  }
  /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * @param {Event} event Event.
   * @private
   */
  handleFeatureChange_(e) {
    const t = (
      /** @type {FeatureType} */
      e.target
    ), i = j(t), s = t.getGeometry();
    if (!s)
      i in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(t), this.nullGeometryFeatures_[i] = t);
    else {
      const o = s.getExtent();
      i in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[i], this.featuresRtree_ && this.featuresRtree_.insert(o, t)) : this.featuresRtree_ && this.featuresRtree_.update(o, t);
    }
    const r = t.getId();
    if (r !== void 0) {
      const o = r.toString();
      this.idIndex_[o] !== t && (this.removeFromIdIndex_(t), this.idIndex_[o] = t);
    } else
      this.removeFromIdIndex_(t), this.uidIndex_[i] = t;
    this.changed(), this.dispatchEvent(
      new gi(Ze.CHANGEFEATURE, t)
    );
  }
  /**
   * Returns true if the feature is contained within the source.
   * @param {FeatureType} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */
  hasFeature(e) {
    const t = e.getId();
    return t !== void 0 ? t in this.idIndex_ : j(e) in this.uidIndex_;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && Fi(this.nullGeometryFeatures_) : this.featuresCollection_ ? this.featuresCollection_.getLength() === 0 : !0;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  loadFeatures(e, t, i) {
    const s = this.loadedExtentsRtree_, r = this.strategy_(e, t, i);
    for (let o = 0, a = r.length; o < a; ++o) {
      const l = r[o];
      s.forEachInExtent(
        l,
        /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */
        function(c) {
          return rt(c.extent, l);
        }
      ) || (++this.loadingExtentsCount_, this.dispatchEvent(
        new gi(Ze.FEATURESLOADSTART)
      ), this.loader_.call(
        this,
        l,
        t,
        i,
        (c) => {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new gi(
              Ze.FEATURESLOADEND,
              void 0,
              c
            )
          );
        },
        () => {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new gi(Ze.FEATURESLOADERROR)
          );
        }
      ), s.insert(l, { extent: l.slice() }));
    }
    this.loading = this.loader_.length < 4 ? !1 : this.loadingExtentsCount_ > 0;
  }
  refresh() {
    this.clear(!0), this.loadedExtentsRtree_.clear(), super.refresh();
  }
  /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  removeLoadedExtent(e) {
    const t = this.loadedExtentsRtree_;
    let i;
    t.forEachInExtent(e, function(s) {
      if (Mi(s.extent, e))
        return i = s, !0;
    }), i && t.remove(i);
  }
  /**
   * Remove a single feature from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {FeatureType} feature Feature to remove.
   * @api
   */
  removeFeature(e) {
    if (!e)
      return;
    const t = j(e);
    t in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[t] : this.featuresRtree_ && this.featuresRtree_.remove(e), this.removeFeatureInternal(e) && this.changed();
  }
  /**
   * Remove feature without firing a `change` event.
   * @param {FeatureType} feature Feature.
   * @return {FeatureType|undefined} The removed feature
   *     (or undefined if the feature was not found).
   * @protected
   */
  removeFeatureInternal(e) {
    const t = j(e), i = this.featureChangeKeys_[t];
    if (!i)
      return;
    i.forEach(he), delete this.featureChangeKeys_[t];
    const s = e.getId();
    return s !== void 0 && delete this.idIndex_[s.toString()], delete this.uidIndex_[t], this.dispatchEvent(
      new gi(Ze.REMOVEFEATURE, e)
    ), e;
  }
  /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {FeatureType} feature The feature.
   * @return {boolean} Removed the feature from the index.
   * @private
   */
  removeFromIdIndex_(e) {
    let t = !1;
    for (const i in this.idIndex_) {
      const s = this.idIndex_[i];
      if (e instanceof mt && Array.isArray(s) && s.includes(e))
        s.splice(s.indexOf(e), 1);
      else if (this.idIndex_[i] === e) {
        delete this.idIndex_[i], t = !0;
        break;
      }
    }
    return t;
  }
  /**
   * Set the new loader of the source. The next render cycle will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
   * @api
   */
  setLoader(e) {
    this.loader_ = e;
  }
  /**
   * Points the source to a new url. The next render cycle will use the new url.
   * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
   * @api
   */
  setUrl(e) {
    Q(this.format_, "`format` must be set when `url` is set"), this.url_ = e, this.setLoader(Fc(e, this.format_));
  }
}
const dh = UE, sf = 0.5;
let VE = class extends Ks {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */
  constructor(e, t, i) {
    super(), i = i || {}, this.tileCoord = e, this.state = t, this.interimTile = null, this.key = "", this.transition_ = i.transition === void 0 ? 250 : i.transition, this.transitionStarts_ = {}, this.interpolate = !!i.interpolate;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(G.CHANGE);
  }
  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */
  release() {
    this.state === P.ERROR && this.setState(P.EMPTY);
  }
  /**
   * @return {string} Key.
   */
  getKey() {
    return this.key + "/" + this.tileCoord;
  }
  /**
   * Get the interim tile most suitable for rendering using the chain of interim
   * tiles. This corresponds to the  most recent tile that has been loaded, if no
   * such tile exists, the original tile is returned.
   * @return {!Tile} Best tile for rendering.
   */
  getInterimTile() {
    let e = this.interimTile;
    if (!e)
      return this;
    do {
      if (e.getState() == P.LOADED)
        return this.transition_ = 0, e;
      e = e.interimTile;
    } while (e);
    return this;
  }
  /**
   * Goes through the chain of interim tiles and discards sections of the chain
   * that are no longer relevant.
   */
  refreshInterimChain() {
    let e = this.interimTile;
    if (!e)
      return;
    let t = this;
    do {
      if (e.getState() == P.LOADED) {
        e.interimTile = null;
        break;
      }
      e.getState() == P.LOADING ? t = e : e.getState() == P.IDLE ? t.interimTile = e.interimTile : t = e, e = t.interimTile;
    } while (e);
  }
  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  getTileCoord() {
    return this.tileCoord;
  }
  /**
   * @return {import("./TileState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */
  setState(e) {
    if (this.state !== P.ERROR && this.state > e)
      throw new Error("Tile load sequence violation");
    this.state = e, this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  load() {
    B();
  }
  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  getAlpha(e, t) {
    if (!this.transition_)
      return 1;
    let i = this.transitionStarts_[e];
    if (!i)
      i = t, this.transitionStarts_[e] = i;
    else if (i === -1)
      return 1;
    const s = t - i + 1e3 / 60;
    return s >= this.transition_ ? 1 : Eu(s / this.transition_);
  }
  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  inTransition(e) {
    return this.transition_ ? this.transitionStarts_[e] !== -1 : !1;
  }
  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  endTransition(e) {
    this.transition_ && (this.transitionStarts_[e] = -1);
  }
};
const Do = VE, jE = 10, Mc = 0.25;
class YE {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   */
  constructor(e, t, i, s, r, o) {
    this.sourceProj_ = e, this.targetProj_ = t;
    let a = {};
    const l = Os(this.targetProj_, this.sourceProj_);
    this.transformInv_ = function(y) {
      const x = y[0] + "/" + y[1];
      return a[x] || (a[x] = l(y)), a[x];
    }, this.maxSourceExtent_ = s, this.errorThresholdSquared_ = r * r, this.triangles_ = [], this.wrapsXInSource_ = !1, this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!s && !!this.sourceProj_.getExtent() && ie(s) >= ie(this.sourceProj_.getExtent()), this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? ie(this.sourceProj_.getExtent()) : null, this.targetWorldWidth_ = this.targetProj_.getExtent() ? ie(this.targetProj_.getExtent()) : null;
    const h = kt(i), c = Js(i), u = qn(i), d = $n(i), f = this.transformInv_(h), g = this.transformInv_(c), _ = this.transformInv_(u), m = this.transformInv_(d), p = jE + (o ? Math.max(
      0,
      Math.ceil(
        Math.log2(
          Pa(i) / (o * o * 256 * 256)
        )
      )
    ) : 0);
    if (this.addQuad_(
      h,
      c,
      u,
      d,
      f,
      g,
      _,
      m,
      p
    ), this.wrapsXInSource_) {
      let y = 1 / 0;
      this.triangles_.forEach(function(x, E, C) {
        y = Math.min(
          y,
          x.source[0][0],
          x.source[1][0],
          x.source[2][0]
        );
      }), this.triangles_.forEach((x) => {
        if (Math.max(
          x.source[0][0],
          x.source[1][0],
          x.source[2][0]
        ) - y > this.sourceWorldWidth_ / 2) {
          const E = [
            [x.source[0][0], x.source[0][1]],
            [x.source[1][0], x.source[1][1]],
            [x.source[2][0], x.source[2][1]]
          ];
          E[0][0] - y > this.sourceWorldWidth_ / 2 && (E[0][0] -= this.sourceWorldWidth_), E[1][0] - y > this.sourceWorldWidth_ / 2 && (E[1][0] -= this.sourceWorldWidth_), E[2][0] - y > this.sourceWorldWidth_ / 2 && (E[2][0] -= this.sourceWorldWidth_);
          const C = Math.min(
            E[0][0],
            E[1][0],
            E[2][0]
          );
          Math.max(
            E[0][0],
            E[1][0],
            E[2][0]
          ) - C < this.sourceWorldWidth_ / 2 && (x.source = E);
        }
      });
    }
    a = {};
  }
  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */
  addTriangle_(e, t, i, s, r, o) {
    this.triangles_.push({
      source: [s, r, o],
      target: [e, t, i]
    });
  }
  /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */
  addQuad_(e, t, i, s, r, o, a, l, h) {
    const c = je([r, o, a, l]), u = this.sourceWorldWidth_ ? ie(c) / this.sourceWorldWidth_ : null, d = (
      /** @type {number} */
      this.sourceWorldWidth_
    ), f = this.sourceProj_.canWrapX() && u > 0.5 && u < 1;
    let g = !1;
    if (h > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        const m = je([e, t, i, s]);
        g = ie(m) / this.targetWorldWidth_ > Mc || g;
      }
      !f && this.sourceProj_.isGlobal() && u && (g = u > Mc || g);
    }
    if (!g && this.maxSourceExtent_ && isFinite(c[0]) && isFinite(c[1]) && isFinite(c[2]) && isFinite(c[3]) && !ye(c, this.maxSourceExtent_))
      return;
    let _ = 0;
    if (!g && (!isFinite(r[0]) || !isFinite(r[1]) || !isFinite(o[0]) || !isFinite(o[1]) || !isFinite(a[0]) || !isFinite(a[1]) || !isFinite(l[0]) || !isFinite(l[1]))) {
      if (h > 0)
        g = !0;
      else if (_ = (!isFinite(r[0]) || !isFinite(r[1]) ? 8 : 0) + (!isFinite(o[0]) || !isFinite(o[1]) ? 4 : 0) + (!isFinite(a[0]) || !isFinite(a[1]) ? 2 : 0) + (!isFinite(l[0]) || !isFinite(l[1]) ? 1 : 0), _ != 1 && _ != 2 && _ != 4 && _ != 8)
        return;
    }
    if (h > 0) {
      if (!g) {
        const m = [(e[0] + i[0]) / 2, (e[1] + i[1]) / 2], p = this.transformInv_(m);
        let y;
        f ? y = (Hi(r[0], d) + Hi(a[0], d)) / 2 - Hi(p[0], d) : y = (r[0] + a[0]) / 2 - p[0];
        const x = (r[1] + a[1]) / 2 - p[1];
        g = y * y + x * x > this.errorThresholdSquared_;
      }
      if (g) {
        if (Math.abs(e[0] - i[0]) <= Math.abs(e[1] - i[1])) {
          const m = [(t[0] + i[0]) / 2, (t[1] + i[1]) / 2], p = this.transformInv_(m), y = [(s[0] + e[0]) / 2, (s[1] + e[1]) / 2], x = this.transformInv_(y);
          this.addQuad_(
            e,
            t,
            m,
            y,
            r,
            o,
            p,
            x,
            h - 1
          ), this.addQuad_(
            y,
            m,
            i,
            s,
            x,
            p,
            a,
            l,
            h - 1
          );
        } else {
          const m = [(e[0] + t[0]) / 2, (e[1] + t[1]) / 2], p = this.transformInv_(m), y = [(i[0] + s[0]) / 2, (i[1] + s[1]) / 2], x = this.transformInv_(y);
          this.addQuad_(
            e,
            m,
            y,
            s,
            r,
            p,
            x,
            l,
            h - 1
          ), this.addQuad_(
            m,
            t,
            i,
            y,
            p,
            o,
            a,
            x,
            h - 1
          );
        }
        return;
      }
    }
    if (f) {
      if (!this.canWrapXInSource_)
        return;
      this.wrapsXInSource_ = !0;
    }
    _ & 11 || this.addTriangle_(e, i, s, r, a, l), _ & 14 || this.addTriangle_(e, i, t, r, a, o), _ && (_ & 13 || this.addTriangle_(t, s, e, o, l, r), _ & 7 || this.addTriangle_(t, s, i, o, l, a));
  }
  /**
   * Calculates extent of the `source` coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */
  calculateSourceExtent() {
    const e = Je();
    return this.triangles_.forEach(function(t, i, s) {
      const r = t.source;
      ws(e, r[0]), ws(e, r[1]), ws(e, r[2]);
    }), e;
  }
  /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */
  getTriangles() {
    return this.triangles_;
  }
}
const rf = YE;
let ga;
const Mn = [];
function Oc(n, e, t, i, s) {
  n.beginPath(), n.moveTo(0, 0), n.lineTo(e, t), n.lineTo(i, s), n.closePath(), n.save(), n.clip(), n.fillRect(0, 0, Math.max(e, i) + 1, Math.max(t, s)), n.restore();
}
function _a(n, e) {
  return Math.abs(n[e * 4] - 210) > 2 || Math.abs(n[e * 4 + 3] - 0.75 * 255) > 2;
}
function XE() {
  if (ga === void 0) {
    const n = Pe(6, 6, Mn);
    n.globalCompositeOperation = "lighter", n.fillStyle = "rgba(210, 0, 0, 0.75)", Oc(n, 4, 5, 4, 0), Oc(n, 4, 5, 0, 5);
    const e = n.getImageData(0, 0, 3, 3).data;
    ga = _a(e, 0) || _a(e, 4) || _a(e, 8), ir(n), Mn.push(n.canvas);
  }
  return ga;
}
function Ys(n, e, t, i) {
  const s = po(t, e, n);
  let r = zr(
    e,
    i,
    t
  );
  const o = e.getMetersPerUnit();
  o !== void 0 && (r *= o);
  const a = n.getMetersPerUnit();
  a !== void 0 && (r /= a);
  const l = n.getExtent();
  if (!l || Qi(l, s)) {
    const h = zr(n, r, s) / r;
    isFinite(h) && h > 0 && (r /= h);
  }
  return r;
}
function BE(n, e, t, i) {
  const s = Ot(t);
  let r = Ys(
    n,
    e,
    s,
    i
  );
  return (!isFinite(r) || r <= 0) && al(t, function(o) {
    return r = Ys(
      n,
      e,
      o,
      i
    ), isFinite(r) && r > 0;
  }), r;
}
function of(n, e, t, i, s, r, o, a, l, h, c, u, d, f) {
  const g = Pe(
    Math.round(t * n),
    Math.round(t * e),
    Mn
  );
  if (u || (g.imageSmoothingEnabled = !1), l.length === 0)
    return g.canvas;
  g.scale(t, t);
  function _(C) {
    return Math.round(C * t) / t;
  }
  g.globalCompositeOperation = "lighter";
  const m = Je();
  l.forEach(function(C, w, S) {
    uu(m, C.extent);
  });
  let p;
  const y = t / i, x = (u ? 1 : 1 + Math.pow(2, -24)) / y;
  if (!d || l.length !== 1 || h !== 0) {
    if (p = Pe(
      Math.round(ie(m) * y),
      Math.round(Te(m) * y),
      Mn
    ), u || (p.imageSmoothingEnabled = !1), s && f) {
      const C = (s[0] - m[0]) * y, w = -(s[3] - m[3]) * y, S = ie(s) * y, v = Te(s) * y;
      p.rect(C, w, S, v), p.clip();
    }
    l.forEach(function(C, w, S) {
      const v = (C.extent[0] - m[0]) * y, R = -(C.extent[3] - m[3]) * y, b = ie(C.extent) * y, A = Te(C.extent) * y;
      C.image.width > 0 && C.image.height > 0 && p.drawImage(
        C.image,
        h,
        h,
        C.image.width - 2 * h,
        C.image.height - 2 * h,
        u ? v : Math.round(v),
        u ? R : Math.round(R),
        u ? b : Math.round(v + b) - Math.round(v),
        u ? A : Math.round(R + A) - Math.round(R)
      );
    });
  }
  const E = kt(o);
  return a.getTriangles().forEach(function(C, w, S) {
    const v = C.source, R = C.target;
    let b = v[0][0], A = v[0][1], N = v[1][0], $ = v[1][1], V = v[2][0], D = v[2][1];
    const L = _((R[0][0] - E[0]) / r), Y = _(
      -(R[0][1] - E[1]) / r
    ), W = _((R[1][0] - E[0]) / r), oe = _(
      -(R[1][1] - E[1]) / r
    ), q = _((R[2][0] - E[0]) / r), ae = _(
      -(R[2][1] - E[1]) / r
    ), ee = b, xe = A;
    b = 0, A = 0, N -= ee, $ -= xe, V -= ee, D -= xe;
    const I = [
      [N, $, 0, 0, W - L],
      [V, D, 0, 0, q - L],
      [0, 0, N, $, oe - Y],
      [0, 0, V, D, ae - Y]
    ], fe = Cg(I);
    if (!fe)
      return;
    if (g.save(), g.beginPath(), XE() || !u) {
      g.moveTo(W, oe);
      const ve = 4, Ue = L - W, ft = Y - oe;
      for (let Ve = 0; Ve < ve; Ve++)
        g.lineTo(
          W + _((Ve + 1) * Ue / ve),
          oe + _(Ve * ft / (ve - 1))
        ), Ve != ve - 1 && g.lineTo(
          W + _((Ve + 1) * Ue / ve),
          oe + _((Ve + 1) * ft / (ve - 1))
        );
      g.lineTo(q, ae);
    } else
      g.moveTo(W, oe), g.lineTo(L, Y), g.lineTo(q, ae);
    g.clip(), g.transform(
      fe[0],
      fe[2],
      fe[1],
      fe[3],
      L,
      Y
    ), g.translate(
      m[0] - ee,
      m[3] - xe
    );
    let Be;
    if (p)
      Be = p.canvas, g.scale(x, -x);
    else {
      const ve = l[0], Ue = ve.extent;
      Be = ve.image, g.scale(
        ie(Ue) / Be.width,
        -Te(Ue) / Be.height
      );
    }
    g.drawImage(Be, 0, 0), g.restore();
  }), p && (ir(p), Mn.push(p.canvas)), c && (g.save(), g.globalCompositeOperation = "source-over", g.strokeStyle = "black", g.lineWidth = 1, a.getTriangles().forEach(function(C, w, S) {
    const v = C.target, R = (v[0][0] - E[0]) / r, b = -(v[0][1] - E[1]) / r, A = (v[1][0] - E[0]) / r, N = -(v[1][1] - E[1]) / r, $ = (v[2][0] - E[0]) / r, V = -(v[2][1] - E[1]) / r;
    g.beginPath(), g.moveTo(A, N), g.lineTo(R, b), g.lineTo($, V), g.closePath(), g.stroke();
  }), g.restore()), g.canvas;
}
class WE extends Do {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {import("../Tile.js").Options} [options] Tile options.
   */
  constructor(e, t, i, s, r, o, a, l, h, c, u, d) {
    super(r, P.IDLE, d), this.renderEdges_ = u !== void 0 ? u : !1, this.pixelRatio_ = a, this.gutter_ = l, this.canvas_ = null, this.sourceTileGrid_ = t, this.targetTileGrid_ = s, this.wrappedTileCoord_ = o || r, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0;
    const f = s.getTileCoordExtent(
      this.wrappedTileCoord_
    ), g = this.targetTileGrid_.getExtent();
    let _ = this.sourceTileGrid_.getExtent();
    const m = g ? qt(f, g) : f;
    if (Pa(m) === 0) {
      this.state = P.EMPTY;
      return;
    }
    const p = e.getExtent();
    p && (_ ? _ = qt(_, p) : _ = p);
    const y = s.getResolution(
      this.wrappedTileCoord_[0]
    ), x = BE(
      e,
      i,
      m,
      y
    );
    if (!isFinite(x) || x <= 0) {
      this.state = P.EMPTY;
      return;
    }
    const E = c !== void 0 ? c : sf;
    if (this.triangulation_ = new rf(
      e,
      i,
      m,
      _,
      x * E,
      y
    ), this.triangulation_.getTriangles().length === 0) {
      this.state = P.EMPTY;
      return;
    }
    this.sourceZ_ = t.getZForResolution(x);
    let C = this.triangulation_.calculateSourceExtent();
    if (_ && (e.canWrapX() ? (C[1] = _e(
      C[1],
      _[1],
      _[3]
    ), C[3] = _e(
      C[3],
      _[1],
      _[3]
    )) : C = qt(C, _)), !Pa(C))
      this.state = P.EMPTY;
    else {
      const w = t.getTileRangeForExtentAndZ(
        C,
        this.sourceZ_
      );
      for (let S = w.minX; S <= w.maxX; S++)
        for (let v = w.minY; v <= w.maxY; v++) {
          const R = h(this.sourceZ_, S, v, a);
          R && this.sourceTiles_.push(R);
        }
      this.sourceTiles_.length === 0 && (this.state = P.EMPTY);
    }
  }
  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @private
   */
  reproject_() {
    const e = [];
    if (this.sourceTiles_.forEach((t) => {
      t && t.getState() == P.LOADED && e.push({
        extent: this.sourceTileGrid_.getTileCoordExtent(t.tileCoord),
        image: t.getImage()
      });
    }), this.sourceTiles_.length = 0, e.length === 0)
      this.state = P.ERROR;
    else {
      const t = this.wrappedTileCoord_[0], i = this.targetTileGrid_.getTileSize(t), s = typeof i == "number" ? i : i[0], r = typeof i == "number" ? i : i[1], o = this.targetTileGrid_.getResolution(t), a = this.sourceTileGrid_.getResolution(
        this.sourceZ_
      ), l = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      );
      this.canvas_ = of(
        s,
        r,
        this.pixelRatio_,
        a,
        this.sourceTileGrid_.getExtent(),
        o,
        l,
        this.triangulation_,
        e,
        this.gutter_,
        this.renderEdges_,
        this.interpolate
      ), this.state = P.LOADED;
    }
    this.changed();
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == P.IDLE) {
      this.state = P.LOADING, this.changed();
      let e = 0;
      this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach((t) => {
        const i = t.getState();
        if (i == P.IDLE || i == P.LOADING) {
          e++;
          const s = Z(
            t,
            G.CHANGE,
            function(r) {
              const o = t.getState();
              (o == P.LOADED || o == P.ERROR || o == P.EMPTY) && (he(s), e--, e === 0 && (this.unlistenSources_(), this.reproject_()));
            },
            this
          );
          this.sourcesListenerKeys_.push(s);
        }
      }), e === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function(t, i, s) {
        t.getState() == P.IDLE && t.load();
      });
    }
  }
  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(he), this.sourcesListenerKeys_ = null;
  }
  /**
   * Remove from the cache due to expiry
   */
  release() {
    this.canvas_ && (ir(this.canvas_.getContext("2d")), Mn.push(this.canvas_), this.canvas_ = null), super.release();
  }
}
const qa = WE;
class KE extends Do {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(e, t, i, s, r, o) {
    super(e, t, o), this.crossOrigin_ = s, this.src_ = i, this.key = i, this.image_ = new Image(), s !== null && (this.image_.crossOrigin = s), this.unlisten_ = null, this.tileLoadFunction_ = r;
  }
  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
   * @param {HTMLCanvasElement|HTMLImageElement} element Element.
   */
  setImage(e) {
    this.image_ = e, this.state = P.LOADED, this.unlistenImage_(), this.changed();
  }
  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = P.ERROR, this.unlistenImage_(), this.image_ = ZE(), this.changed();
  }
  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    const e = (
      /** @type {HTMLImageElement} */
      this.image_
    );
    e.naturalWidth && e.naturalHeight ? this.state = P.LOADED : this.state = P.EMPTY, this.unlistenImage_(), this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   *
   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
   * that checks for error status codes and reloads only when the status code is
   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
   * made already:
   *
   * ```js
   * const retryCodes = [408, 429, 500, 502, 503, 504];
   * const retries = {};
   * source.setTileLoadFunction((tile, src) => {
   *   const image = tile.getImage();
   *   fetch(src)
   *     .then((response) => {
   *       if (retryCodes.includes(response.status)) {
   *         retries[src] = (retries[src] || 0) + 1;
   *         if (retries[src] <= 3) {
   *           setTimeout(() => tile.load(), retries[src] * 1000);
   *         }
   *         return Promise.reject();
   *       }
   *       return response.blob();
   *     })
   *     .then((blob) => {
   *       const imageUrl = URL.createObjectURL(blob);
   *       image.src = imageUrl;
   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
   *     })
   *     .catch(() => tile.setState(3)); // error
   * });
   * ```
   *
   * @api
   */
  load() {
    this.state == P.ERROR && (this.state = P.IDLE, this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_)), this.state == P.IDLE && (this.state = P.LOADING, this.changed(), this.tileLoadFunction_(this, this.src_), this.unlisten_ = q_(
      this.image_,
      this.handleImageLoad_.bind(this),
      this.handleImageError_.bind(this)
    ));
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
  }
}
function ZE() {
  const n = Pe(1, 1);
  return n.fillStyle = "rgba(0,0,0,0)", n.fillRect(0, 0, 1, 1), n.canvas;
}
const af = KE;
class HE {
  /**
   * @param {number} [highWaterMark] High water mark.
   */
  constructor(e) {
    this.highWaterMark = e !== void 0 ? e : 2048, this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }
  /**
   * Expire the cache.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */
  expireCache(e) {
    for (; this.canExpireCache(); )
      this.pop();
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  containsKey(e) {
    return this.entries_.hasOwnProperty(e);
  }
  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */
  forEach(e) {
    let t = this.oldest_;
    for (; t; )
      e(t.value_, t.key_, this), t = t.newer;
  }
  /**
   * @param {string} key Key.
   * @param {*} [options] Options (reserved for subclasses).
   * @return {T} Value.
   */
  get(e, t) {
    const i = this.entries_[e];
    return Q(
      i !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    ), i === this.newest_ || (i === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    this.oldest_.newer, this.oldest_.older = null) : (i.newer.older = i.older, i.older.newer = i.newer), i.newer = null, i.older = this.newest_, this.newest_.newer = i, this.newest_ = i), i.value_;
  }
  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  remove(e) {
    const t = this.entries_[e];
    return Q(
      t !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    ), t === this.newest_ ? (this.newest_ = /** @type {Entry} */
    t.older, this.newest_ && (this.newest_.newer = null)) : t === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    t.newer, this.oldest_ && (this.oldest_.older = null)) : (t.newer.older = t.older, t.older.newer = t.newer), delete this.entries_[e], --this.count_, t.value_;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.count_;
  }
  /**
   * @return {Array<string>} Keys.
   */
  getKeys() {
    const e = new Array(this.count_);
    let t = 0, i;
    for (i = this.newest_; i; i = i.older)
      e[t++] = i.key_;
    return e;
  }
  /**
   * @return {Array<T>} Values.
   */
  getValues() {
    const e = new Array(this.count_);
    let t = 0, i;
    for (i = this.newest_; i; i = i.older)
      e[t++] = i.value_;
    return e;
  }
  /**
   * @return {T} Last value.
   */
  peekLast() {
    return this.oldest_.value_;
  }
  /**
   * @return {string} Last key.
   */
  peekLastKey() {
    return this.oldest_.key_;
  }
  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  peekFirstKey() {
    return this.newest_.key_;
  }
  /**
   * Return an entry without updating least recently used time.
   * @param {string} key Key.
   * @return {T|undefined} Value.
   */
  peek(e) {
    var t;
    return (t = this.entries_[e]) == null ? void 0 : t.value_;
  }
  /**
   * @return {T} value Value.
   */
  pop() {
    const e = this.oldest_;
    return delete this.entries_[e.key_], e.newer && (e.newer.older = null), this.oldest_ = /** @type {Entry} */
    e.newer, this.oldest_ || (this.newest_ = null), --this.count_, e.value_;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  replace(e, t) {
    this.get(e), this.entries_[e].value_ = t;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  set(e, t) {
    Q(
      !(e in this.entries_),
      "Tried to set a value for a key that is used already"
    );
    const i = {
      key_: e,
      newer: null,
      older: this.newest_,
      value_: t
    };
    this.newest_ ? this.newest_.newer = i : this.oldest_ = i, this.newest_ = i, this.entries_[e] = i, ++this.count_;
  }
  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  setSize(e) {
    this.highWaterMark = e;
  }
}
const qE = HE;
class lf {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  constructor(e, t, i, s) {
    this.minX = e, this.maxX = t, this.minY = i, this.maxY = s;
  }
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */
  contains(e) {
    return this.containsXY(e[1], e[2]);
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */
  containsTileRange(e) {
    return this.minX <= e.minX && e.maxX <= this.maxX && this.minY <= e.minY && e.maxY <= this.maxY;
  }
  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */
  containsXY(e, t) {
    return this.minX <= e && e <= this.maxX && this.minY <= t && t <= this.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */
  equals(e) {
    return this.minX == e.minX && this.minY == e.minY && this.maxX == e.maxX && this.maxY == e.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   */
  extend(e) {
    e.minX < this.minX && (this.minX = e.minX), e.maxX > this.maxX && (this.maxX = e.maxX), e.minY < this.minY && (this.minY = e.minY), e.maxY > this.maxY && (this.maxY = e.maxY);
  }
  /**
   * @return {number} Height.
   */
  getHeight() {
    return this.maxY - this.minY + 1;
  }
  /**
   * @return {import("./size.js").Size} Size.
   */
  getSize() {
    return [this.getWidth(), this.getHeight()];
  }
  /**
   * @return {number} Width.
   */
  getWidth() {
    return this.maxX - this.minX + 1;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */
  intersects(e) {
    return this.minX <= e.maxX && this.maxX >= e.minX && this.minY <= e.maxY && this.maxY >= e.minY;
  }
}
function pn(n, e, t, i, s) {
  return s !== void 0 ? (s.minX = n, s.maxX = e, s.minY = t, s.maxY = i, s) : new lf(n, e, t, i);
}
const hf = lf;
function Dc(n, e, t, i) {
  return i !== void 0 ? (i[0] = n, i[1] = e, i[2] = t, i) : [n, e, t];
}
function ss(n, e, t) {
  return n + "/" + e + "/" + t;
}
function cf(n) {
  return ss(n[0], n[1], n[2]);
}
function JE(n) {
  const [e, t, i] = n.substring(n.lastIndexOf("/") + 1, n.length).split(",").map(Number);
  return ss(e, t, i);
}
function uf(n) {
  return n.split("/").map(Number);
}
function df(n) {
  return (n[1] << n[0]) + n[2];
}
function QE(n, e) {
  const t = n[0], i = n[1], s = n[2];
  if (e.getMinZoom() > t || t > e.getMaxZoom())
    return !1;
  const r = e.getFullTileRange(t);
  return r ? r.containsXY(i, s) : !0;
}
class eC extends tr {
  /**
   * @param {Options<ImageSourceType>} [options] Layer options.
   */
  constructor(e) {
    e = e || {}, super(e);
  }
}
const tC = eC;
class iC extends hh {
  /**
   * @param {import("../../layer/Image.js").default} imageLayer Image layer.
   */
  constructor(e) {
    super(e), this.image_ = null;
  }
  /**
   * @return {import('../../DataTile.js').ImageLike} Image.
   */
  getImage() {
    return this.image_ ? this.image_.getImage() : null;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    const t = e.layerStatesArray[e.layerIndex], i = e.pixelRatio, s = e.viewState, r = s.resolution, o = this.getLayer().getSource(), a = e.viewHints;
    let l = e.extent;
    if (t.extent !== void 0 && (l = qt(
      l,
      Et(t.extent, s.projection)
    )), !a[de.ANIMATING] && !a[de.INTERACTING] && !Jn(l))
      if (o) {
        const h = s.projection, c = o.getImage(
          l,
          r,
          i,
          h
        );
        c && (this.loadImage(c) ? this.image_ = c : c.getState() === M.EMPTY && (this.image_ = null));
      } else
        this.image_ = null;
    return !!this.image_;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */
  getData(e) {
    const t = this.frameState;
    if (!t)
      return null;
    const i = this.getLayer(), s = Se(
      t.pixelToCoordinateTransform,
      e.slice()
    ), r = i.getExtent();
    if (r && !Qi(r, s))
      return null;
    const o = this.image_.getExtent(), a = this.image_.getImage(), l = ie(o), h = Math.floor(
      a.width * ((s[0] - o[0]) / l)
    );
    if (h < 0 || h >= a.width)
      return null;
    const c = Te(o), u = Math.floor(
      a.height * ((o[3] - s[1]) / c)
    );
    return u < 0 || u >= a.height ? null : this.getImageData(a, h, u);
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(e, t) {
    const i = this.image_, s = i.getExtent(), r = i.getResolution(), [o, a] = Array.isArray(r) ? r : [r, r], l = i.getPixelRatio(), h = e.layerStatesArray[e.layerIndex], c = e.pixelRatio, u = e.viewState, d = u.center, f = u.resolution, g = c * o / (f * l), _ = c * a / (f * l), m = e.extent, p = u.resolution, y = u.rotation, x = Math.round(ie(m) / p * c), E = Math.round(Te(m) / p * c);
    wt(
      this.pixelTransform,
      e.size[0] / 2,
      e.size[1] / 2,
      1 / c,
      1 / c,
      y,
      -x / 2,
      -E / 2
    ), Eo(this.inversePixelTransform, this.pixelTransform);
    const C = yl(this.pixelTransform);
    this.useContainer(t, C, this.getBackground(e));
    const w = this.getRenderContext(e), S = this.context.canvas;
    S.width != x || S.height != E ? (S.width = x, S.height = E) : this.containerReused || w.clearRect(0, 0, x, E);
    let v = !1, R = !0;
    if (h.extent) {
      const V = Et(
        h.extent,
        u.projection
      );
      R = ye(V, e.extent), v = R && !rt(V, e.extent), v && this.clipUnrotated(w, e, V);
    }
    const b = i.getImage(), A = wt(
      this.tempTransform,
      x / 2,
      E / 2,
      g,
      _,
      0,
      l * (s[0] - d[0]) / o,
      l * (d[1] - s[3]) / a
    );
    this.renderedResolution = a * c / l;
    const N = b.width * A[0], $ = b.height * A[3];
    if (this.getLayer().getSource().getInterpolate() || (w.imageSmoothingEnabled = !1), this.preRender(w, e), R && N >= 0.5 && $ >= 0.5) {
      const V = A[4], D = A[5], L = h.opacity;
      L !== 1 && (w.save(), w.globalAlpha = L), w.drawImage(b, 0, 0, +b.width, +b.height, V, D, N, $), L !== 1 && w.restore();
    }
    return this.postRender(this.context, e), v && w.restore(), w.imageSmoothingEnabled = !0, C !== S.style.transform && (S.style.transform = C), this.container;
  }
}
const nC = iC;
class sC extends tC {
  /**
   * @param {import("./BaseImage.js").Options<ImageSourceType>} [options] Layer options.
   */
  constructor(e) {
    super(e);
  }
  createRenderer() {
    return new nC(this);
  }
  /**
   * Get data for a pixel location.  A four element RGBA array will be returned.  For requests outside the
   * layer extent, `null` will be returned.  Data for an image can only be retrieved if the
   * source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */
  getData(e) {
    return super.getData(e);
  }
}
const rC = sC, Ri = {
  PRELOAD: "preload",
  USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};
class oC extends tr {
  /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign({}, e);
    delete t.preload, delete t.useInterimTilesOnError, super(t), this.on, this.once, this.un, this.setPreload(e.preload !== void 0 ? e.preload : 0), this.setUseInterimTilesOnError(
      e.useInterimTilesOnError !== void 0 ? e.useInterimTilesOnError : !0
    );
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get(Ri.PRELOAD)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(e) {
    this.set(Ri.PRELOAD, e);
  }
  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get(Ri.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(e) {
    this.set(Ri.USE_INTERIM_TILES_ON_ERROR, e);
  }
  /**
   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
   * a four element RGBA array will be returned.  For data tiles, the array length will match the
   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */
  getData(e) {
    return super.getData(e);
  }
}
const aC = oC;
class lC extends hh {
  /**
   * @param {LayerType} tileLayer Tile layer.
   */
  constructor(e) {
    super(e), this.extentChanged = !0, this.renderedExtent_ = null, this.renderedPixelRatio, this.renderedProjection = null, this.renderedRevision, this.renderedTiles = [], this.newTiles_ = !1, this.tmpExtent = Je(), this.tmpTileRange_ = new hf(0, 0, 0, 0);
  }
  /**
   * @protected
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  isDrawableTile(e) {
    const t = this.getLayer(), i = e.getState(), s = t.getUseInterimTilesOnError();
    return i == P.LOADED || i == P.EMPTY || i == P.ERROR && !s;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */
  getTile(e, t, i, s) {
    const r = s.pixelRatio, o = s.viewState.projection, a = this.getLayer();
    let h = a.getSource().getTile(e, t, i, r, o);
    return h.getState() == P.ERROR && a.getUseInterimTilesOnError() && a.getPreload() > 0 && (this.newTiles_ = !0), this.isDrawableTile(h) || (h = h.getInterimTile()), h;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */
  getData(e) {
    const t = this.frameState;
    if (!t)
      return null;
    const i = this.getLayer(), s = Se(
      t.pixelToCoordinateTransform,
      e.slice()
    ), r = i.getExtent();
    if (r && !Qi(r, s))
      return null;
    const o = t.pixelRatio, a = t.viewState.projection, l = t.viewState, h = i.getRenderSource(), c = h.getTileGridForProjection(l.projection), u = h.getTilePixelRatio(t.pixelRatio);
    for (let d = c.getZForResolution(l.resolution); d >= c.getMinZoom(); --d) {
      const f = c.getTileCoordForCoordAndZ(s, d), g = h.getTile(
        d,
        f[1],
        f[2],
        o,
        a
      );
      if (!(g instanceof af || g instanceof qa) || g instanceof qa && g.getState() === P.EMPTY)
        return null;
      if (g.getState() !== P.LOADED)
        continue;
      const _ = c.getOrigin(d), m = $e(c.getTileSize(d)), p = c.getResolution(d), y = Math.floor(
        u * ((s[0] - _[0]) / p - f[1] * m[0])
      ), x = Math.floor(
        u * ((_[1] - s[1]) / p - f[2] * m[1])
      ), E = Math.round(
        u * h.getGutterForProjection(l.projection)
      );
      return this.getImageData(g.getImage(), y + E, x + E);
    }
    return null;
  }
  /**
   * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(e, t, i) {
    return this.isDrawableTile(i) ? super.loadedTileCallback(e, t, i) : !1;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    return !!this.getLayer().getSource();
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(e, t) {
    const i = e.layerStatesArray[e.layerIndex], s = e.viewState, r = s.projection, o = s.resolution, a = s.center, l = s.rotation, h = e.pixelRatio, c = this.getLayer(), u = c.getSource(), d = u.getRevision(), f = u.getTileGridForProjection(r), g = f.getZForResolution(o, u.zDirection), _ = f.getResolution(g);
    let m = e.extent;
    const p = e.viewState.resolution, y = u.getTilePixelRatio(h), x = Math.round(ie(m) / p * h), E = Math.round(Te(m) / p * h), C = i.extent && Et(i.extent);
    C && (m = qt(
      m,
      Et(i.extent)
    ));
    const w = _ * x / 2 / y, S = _ * E / 2 / y, v = [
      a[0] - w,
      a[1] - S,
      a[0] + w,
      a[1] + S
    ], R = f.getTileRangeForExtentAndZ(m, g), b = {};
    b[g] = {};
    const A = this.createLoadedTileFinder(
      u,
      r,
      b
    ), N = this.tmpExtent, $ = this.tmpTileRange_;
    this.newTiles_ = !1;
    const V = l ? La(
      s.center,
      p,
      l,
      e.size
    ) : void 0;
    for (let xe = R.minX; xe <= R.maxX; ++xe)
      for (let I = R.minY; I <= R.maxY; ++I) {
        if (l && !f.tileCoordIntersectsViewport([g, xe, I], V))
          continue;
        const fe = this.getTile(g, xe, I, e);
        if (this.isDrawableTile(fe)) {
          const Ue = j(this);
          if (fe.getState() == P.LOADED) {
            b[g][fe.tileCoord.toString()] = fe;
            let ft = fe.inTransition(Ue);
            ft && i.opacity !== 1 && (fe.endTransition(Ue), ft = !1), !this.newTiles_ && (ft || !this.renderedTiles.includes(fe)) && (this.newTiles_ = !0);
          }
          if (fe.getAlpha(Ue, e.time) === 1)
            continue;
        }
        const Be = f.getTileCoordChildTileRange(
          fe.tileCoord,
          $,
          N
        );
        let ve = !1;
        Be && (ve = A(g + 1, Be)), ve || f.forEachTileCoordParentTileRange(
          fe.tileCoord,
          A,
          $,
          N
        );
      }
    const D = _ / o * h / y;
    wt(
      this.pixelTransform,
      e.size[0] / 2,
      e.size[1] / 2,
      1 / h,
      1 / h,
      l,
      -x / 2,
      -E / 2
    );
    const L = yl(this.pixelTransform);
    this.useContainer(t, L, this.getBackground(e));
    const Y = this.getRenderContext(e), W = this.context.canvas;
    Eo(this.inversePixelTransform, this.pixelTransform), wt(
      this.tempTransform,
      x / 2,
      E / 2,
      D,
      D,
      0,
      -x / 2,
      -E / 2
    ), W.width != x || W.height != E ? (W.width = x, W.height = E) : this.containerReused || Y.clearRect(0, 0, x, E), C && this.clipUnrotated(Y, e, C), u.getInterpolate() || (Y.imageSmoothingEnabled = !1), this.preRender(Y, e), this.renderedTiles.length = 0;
    let oe = Object.keys(b).map(Number);
    oe.sort(ti);
    let q, ae, ee;
    i.opacity === 1 && (!this.containerReused || u.getOpaque(e.viewState.projection)) ? oe = oe.reverse() : (q = [], ae = []);
    for (let xe = oe.length - 1; xe >= 0; --xe) {
      const I = oe[xe], fe = u.getTilePixelSize(
        I,
        h,
        r
      ), ve = f.getResolution(I) / _, Ue = fe[0] * ve * D, ft = fe[1] * ve * D, Ve = f.getTileCoordForCoordAndZ(
        kt(v),
        I
      ), rs = f.getTileCoordExtent(Ve), Gi = Se(this.tempTransform, [
        y * (rs[0] - v[0]) / _,
        y * (v[3] - rs[3]) / _
      ]), ko = y * u.getGutterForProjection(r), lr = b[I];
      for (const hr in lr) {
        const Qe = (
          /** @type {import("../../ImageTile.js").default} */
          lr[hr]
        ), hn = Qe.tileCoord, cr = Ve[1] - hn[1], Go = Math.round(Gi[0] - (cr - 1) * Ue), ur = Ve[2] - hn[2], dr = Math.round(Gi[1] - (ur - 1) * ft), We = Math.round(Gi[0] - cr * Ue), gt = Math.round(Gi[1] - ur * ft), Rt = Go - We, _t = dr - gt, cn = g === I, un = cn && Qe.getAlpha(j(this), e.time) !== 1;
        let ci = !1;
        if (!un)
          if (q) {
            ee = [We, gt, We + Rt, gt, We + Rt, gt + _t, We, gt + _t];
            for (let zt = 0, zo = q.length; zt < zo; ++zt)
              if (g !== I && I < ae[zt]) {
                const ke = q[zt];
                ye(
                  [We, gt, We + Rt, gt + _t],
                  [ke[0], ke[3], ke[4], ke[7]]
                ) && (ci || (Y.save(), ci = !0), Y.beginPath(), Y.moveTo(ee[0], ee[1]), Y.lineTo(ee[2], ee[3]), Y.lineTo(ee[4], ee[5]), Y.lineTo(ee[6], ee[7]), Y.moveTo(ke[6], ke[7]), Y.lineTo(ke[4], ke[5]), Y.lineTo(ke[2], ke[3]), Y.lineTo(ke[0], ke[1]), Y.clip());
              }
            q.push(ee), ae.push(I);
          } else
            Y.clearRect(We, gt, Rt, _t);
        this.drawTileImage(
          Qe,
          e,
          We,
          gt,
          Rt,
          _t,
          ko,
          cn
        ), q && !un ? (ci && Y.restore(), this.renderedTiles.unshift(Qe)) : this.renderedTiles.push(Qe), this.updateUsedTiles(e.usedTiles, u, Qe);
      }
    }
    return this.renderedRevision = d, this.renderedResolution = _, this.extentChanged = !this.renderedExtent_ || !Mi(this.renderedExtent_, v), this.renderedExtent_ = v, this.renderedPixelRatio = h, this.renderedProjection = r, this.manageTilePyramid(
      e,
      u,
      f,
      h,
      r,
      m,
      g,
      c.getPreload()
    ), this.scheduleExpireCache(e, u), this.postRender(this.context, e), i.extent && Y.restore(), Y.imageSmoothingEnabled = !0, L !== W.style.transform && (W.style.transform = L), this.container;
  }
  /**
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   */
  drawTileImage(e, t, i, s, r, o, a, l) {
    const h = this.getTileImage(e);
    if (!h)
      return;
    const c = this.getRenderContext(t), u = j(this), d = t.layerStatesArray[t.layerIndex], f = d.opacity * (l ? e.getAlpha(u, t.time) : 1), g = f !== c.globalAlpha;
    g && (c.save(), c.globalAlpha = f), c.drawImage(
      h,
      a,
      a,
      h.width - 2 * a,
      h.height - 2 * a,
      i,
      s,
      r,
      o
    ), g && c.restore(), f !== d.opacity ? t.animate = !0 : l && e.endTransition(u);
  }
  /**
   * @return {HTMLCanvasElement} Image
   */
  getImage() {
    const e = this.context;
    return e ? e.canvas : null;
  }
  /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */
  getTileImage(e) {
    return e.getImage();
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @protected
   */
  scheduleExpireCache(e, t) {
    if (t.canExpireCache()) {
      const i = (function(s, r, o) {
        const a = j(s);
        a in o.usedTiles && s.expireCache(
          o.viewState.projection,
          o.usedTiles[a]
        );
      }).bind(null, t);
      e.postRenderFunctions.push(
        /** @type {import("../../Map.js").PostRenderFunction} */
        i
      );
    }
  }
  /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */
  updateUsedTiles(e, t, i) {
    const s = j(t);
    s in e || (e[s] = {}), e[s][i.getKey()] = !0;
  }
  /**
   * Manage tile pyramid.
   * This function performs a number of functions related to the tiles at the
   * current zoom and lower zoom levels:
   * - registers idle tiles in frameState.wantedTiles so that they are not
   *   discarded by the tile queue
   * - enqueues missing tiles
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {number} currentZ Current Z.
   * @param {number} preload Load low resolution tiles up to `preload` levels.
   * @param {function(import("../../Tile.js").default):void} [tileCallback] Tile callback.
   * @protected
   */
  manageTilePyramid(e, t, i, s, r, o, a, l, h) {
    const c = j(t);
    c in e.wantedTiles || (e.wantedTiles[c] = {});
    const u = e.wantedTiles[c], d = e.tileQueue, f = i.getMinZoom(), g = e.viewState.rotation, _ = g ? La(
      e.viewState.center,
      e.viewState.resolution,
      g,
      e.size
    ) : void 0;
    let m = 0, p, y, x, E, C, w;
    for (w = f; w <= a; ++w)
      for (y = i.getTileRangeForExtentAndZ(o, w, y), x = i.getResolution(w), E = y.minX; E <= y.maxX; ++E)
        for (C = y.minY; C <= y.maxY; ++C)
          g && !i.tileCoordIntersectsViewport([w, E, C], _) || (a - w <= l ? (++m, p = t.getTile(w, E, C, s, r), p.getState() == P.IDLE && (u[p.getKey()] = !0, d.isKeyQueued(p.getKey()) || d.enqueue([
            p,
            c,
            i.getTileCoordCenter(p.tileCoord),
            x
          ])), h !== void 0 && h(p)) : t.useTile(w, E, C, r));
    t.updateCacheSize(m, r);
  }
}
const ff = lC;
class hC extends aC {
  /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(e) {
    super(e);
  }
  createRenderer() {
    return new ff(this);
  }
}
const cC = hC;
function Ja(n) {
  return Array.isArray(n) ? Math.min(...n) : n;
}
const uC = {
  image: ["Polygon", "Circle", "LineString", "Image", "Text"],
  hybrid: ["Polygon", "LineString"],
  vector: []
}, Nc = {
  hybrid: ["Image", "Text", "Default"],
  vector: ["Polygon", "Circle", "LineString", "Image", "Text", "Default"]
};
class dC extends ff {
  /**
   * @param {import("../../layer/VectorTile.js").default} layer VectorTile layer.
   */
  constructor(e) {
    super(e), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.renderedLayerRevision_, this.renderedPixelToCoordinateTransform_ = null, this.renderedRotation_, this.renderedOpacity_ = 1, this.tmpTransform_ = at(), this.tileClipContexts_ = null;
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection").default} projection Projection.
   * @return {boolean|undefined} Tile needs to be rendered.
   */
  prepareTile(e, t, i) {
    let s;
    const r = e.getState();
    return (r === P.LOADED || r === P.ERROR) && (this.updateExecutorGroup_(e, t, i), this.tileImageNeedsRender_(e) && (s = !0)), s;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */
  getTile(e, t, i, s) {
    const r = s.pixelRatio, o = s.viewState, a = o.resolution, l = o.projection, h = this.getLayer(), c = h.getSource().getTile(e, t, i, r, l), u = s.viewHints, d = !(u[de.ANIMATING] || u[de.INTERACTING]);
    return (d || !c.wantedResolution) && (c.wantedResolution = a), this.prepareTile(c, r, l) && (d || Date.now() - s.time < 8) && h.getRenderMode() !== "vector" && this.renderTileImage_(c, s), super.getTile(e, t, i, s);
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  isDrawableTile(e) {
    const t = this.getLayer();
    return super.isDrawableTile(e) && (t.getRenderMode() === "vector" ? j(t) in e.executorGroups : e.hasContext(t));
  }
  /**
   * @inheritDoc
   */
  getTileImage(e) {
    return e.getImage(this.getLayer());
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    const t = this.getLayer().getRevision();
    return this.renderedLayerRevision_ !== t && (this.renderedLayerRevision_ = t, this.renderedTiles.length = 0), super.prepareFrame(e);
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @private
   */
  updateExecutorGroup_(e, t, i) {
    var m;
    const s = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), r = s.getRevision(), o = s.getRenderOrder() || null, a = e.wantedResolution, l = e.getReplayState(s);
    if (!l.dirty && l.renderedResolution === a && l.renderedRevision == r && l.renderedRenderOrder == o)
      return;
    const h = s.getSource(), c = !!s.getDeclutter(), u = h.getTileGrid(), f = h.getTileGridForProjection(i).getTileCoordExtent(e.wrappedTileCoord), g = h.getSourceTiles(t, i, e), _ = j(s);
    delete e.hitDetectionImageData[_], e.executorGroups[_] = [], l.dirty = !1;
    for (let p = 0, y = g.length; p < y; ++p) {
      const x = g[p];
      if (x.getState() != P.LOADED)
        continue;
      const E = x.tileCoord, C = u.getTileCoordExtent(E), w = qt(f, C), S = ot(
        w,
        s.getRenderBuffer() * a,
        this.tmpExtent
      ), v = Mi(C, w) ? null : S, R = new Zd(
        0,
        w,
        a,
        t
      ), b = Za(
        a,
        t
      ), A = function(L, Y) {
        let W;
        const oe = L.getStyleFunction() || s.getStyleFunction();
        if (oe && (W = oe(L, a)), W) {
          const q = this.renderFeature(
            L,
            b,
            W,
            R,
            c,
            Y
          );
          l.dirty = l.dirty || q;
        }
      }, N = x.getFeatures();
      o && o !== l.renderedRenderOrder && N.sort(o);
      for (let L = 0, Y = N.length; L < Y; ++L) {
        const W = N[L];
        (!v || ye(v, W.getGeometry().getExtent())) && A.call(this, W, L);
      }
      const $ = R.finish(), V = s.getRenderMode() !== "vector" && c && g.length === 1 ? null : w, D = new Hd(
        V,
        a,
        t,
        h.getOverlaps(),
        $,
        s.getRenderBuffer(),
        !!((m = this.frameState) != null && m.declutter)
      );
      e.executorGroups[_].push(D);
    }
    l.renderedRevision = r, l.renderedRenderOrder = o, l.renderedResolution = a;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, i, s, r) {
    const o = t.viewState.resolution, a = t.viewState.rotation;
    i = i ?? 0;
    const l = this.getLayer(), c = l.getSource().getTileGridForProjection(
      t.viewState.projection
    ), u = je([e]);
    ot(u, o * i, u);
    const d = {}, f = function(m, p, y) {
      let x = m.getId();
      x === void 0 && (x = j(m));
      const E = d[x];
      if (E) {
        if (E !== !0 && y < E.distanceSq) {
          if (y === 0)
            return d[x] = !0, r.splice(r.lastIndexOf(E), 1), s(m, l, p);
          E.geometry = p, E.distanceSq = y;
        }
      } else {
        if (y === 0)
          return d[x] = !0, s(m, l, p);
        r.push(
          d[x] = {
            feature: m,
            layer: l,
            geometry: p,
            distanceSq: y,
            callback: s
          }
        );
      }
    }, g = (
      /** @type {Array<import("../../VectorRenderTile.js").default>} */
      this.renderedTiles
    );
    let _;
    for (let m = 0, p = g.length; !_ && m < p; ++m) {
      const y = g[m], x = c.getTileCoordExtent(y.wrappedTileCoord);
      if (!ye(x, u))
        continue;
      const E = j(l), C = [y.executorGroups[E]], w = l.getDeclutter();
      C.some((S) => {
        const v = w ? t.declutter[w].all().map((R) => R.value) : null;
        for (let R = 0, b = S.length; R < b; ++R)
          if (_ = S[R].forEachFeatureAtCoordinate(
            e,
            o,
            a,
            i,
            f,
            v
          ), _)
            return !0;
      });
    }
    return _;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature.js").FeatureLike>>} Promise that resolves with an array of features.
   */
  getFeatures(e) {
    return new Promise((t, i) => {
      const s = this.getLayer(), r = j(s), o = s.getSource(), a = this.renderedProjection, l = a.getExtent(), h = this.renderedResolution, c = o.getTileGridForProjection(a), u = Se(
        this.renderedPixelToCoordinateTransform_,
        e.slice()
      ), d = c.getTileCoordForCoordAndResolution(
        u,
        h
      );
      let f;
      for (let x = 0, E = this.renderedTiles.length; x < E; ++x)
        if (d.toString() === this.renderedTiles[x].tileCoord.toString()) {
          if (f = /** @type {import("../../VectorRenderTile.js").default} */
          this.renderedTiles[x], f.getState() === P.LOADED) {
            const C = c.getTileCoordExtent(f.tileCoord);
            o.getWrapX() && a.canWrapX() && !rt(l, C) && mo(u, a);
            break;
          }
          f = void 0;
        }
      if (!f || f.loadingSourceTiles > 0) {
        t([]);
        return;
      }
      const g = c.getTileCoordExtent(f.wrappedTileCoord), _ = kt(g), m = [
        (u[0] - _[0]) / h,
        (_[1] - u[1]) / h
      ], p = f.getSourceTiles().reduce(function(x, E) {
        return x.concat(E.getFeatures());
      }, []);
      let y = f.hitDetectionImageData[r];
      if (!y) {
        const x = $e(
          c.getTileSize(
            c.getZForResolution(h, o.zDirection)
          )
        ), E = this.renderedRotation_, C = [
          this.getRenderTransform(
            c.getTileCoordCenter(f.wrappedTileCoord),
            h,
            0,
            qe,
            x[0] * qe,
            x[1] * qe,
            0
          )
        ];
        y = qd(
          x,
          C,
          p,
          s.getStyleFunction(),
          c.getTileCoordExtent(f.wrappedTileCoord),
          f.getReplayState(s).renderedResolution,
          E
        ), f.hitDetectionImageData[r] = y;
      }
      t(Jd(m, p, y));
    });
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */
  handleFontsChanged() {
    const e = this.getLayer();
    e.getVisible() && this.renderedLayerRevision_ !== void 0 && e.changed();
  }
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(e) {
    this.renderIfReadyAndVisible();
  }
  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(e, t) {
    const i = this.context, s = i.globalAlpha;
    i.globalAlpha = t.opacity;
    const r = e.viewHints, o = !(r[de.ANIMATING] || r[de.INTERACTING]), a = (
      /** @type {Array<import("../../VectorRenderTile.js").default>} */
      this.renderedTiles
    );
    for (let l = 0, h = a.length; l < h; ++l) {
      const c = a[l], u = c.executorGroups[j(this.getLayer())], d = this.getLayer().getDeclutter();
      if (u)
        for (let f = u.length - 1; f >= 0; --f)
          u[f].execute(
            this.context,
            [this.context.canvas.width, this.context.canvas.height],
            this.getTileRenderTransform(c, e),
            e.viewState.rotation,
            o,
            ao,
            d ? e.declutter[d] : void 0
          );
    }
    i.globalAlpha = s;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeferredInternal(e) {
    const i = /** @type {Array<import("../../VectorRenderTile.js").default>} */ this.renderedTiles.reduce((o, a, l) => (a.executorGroups[j(this.getLayer())].forEach(
      (h) => o.push({
        executorGroup: h,
        index: l
      })
    ), o), []), s = i.map(
      ({ executorGroup: o }) => o.getDeferredZIndexContexts()
    );
    s.map((o) => Object.keys(o)).flat().sort(ti).map(Number).forEach((o) => {
      s.forEach((a, l) => {
        a[o] && a[o].forEach((h) => {
          const { executorGroup: c, index: u } = i[l], d = c.getRenderedContext(), f = d.globalAlpha;
          d.globalAlpha = this.renderedOpacity_;
          const g = this.tileClipContexts_[u];
          g && g.draw(d), h.draw(d), g && d.restore(), d.globalAlpha = f, h.clear();
        });
      });
    });
  }
  getTileRenderTransform(e, t) {
    const i = t.pixelRatio, s = t.viewState, r = s.center, o = s.resolution, a = s.rotation, l = t.size, h = Math.round(l[0] * i), c = Math.round(l[1] * i), d = this.getLayer().getSource().getTileGridForProjection(
      t.viewState.projection
    ), f = e.tileCoord, g = d.getTileCoordExtent(e.wrappedTileCoord), _ = d.getTileCoordExtent(f, this.tmpExtent)[0] - g[0];
    return pl(
      Ko(this.inversePixelTransform.slice(), 1 / i, 1 / i),
      this.getRenderTransform(
        r,
        o,
        a,
        i,
        h,
        c,
        _
      )
    );
  }
  /**
   * Render the vectors for this layer.
   * @param {CanvasRenderingContext2D} context Target context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  postRender(e, t) {
    const i = t.viewHints, s = !(i[de.ANIMATING] || i[de.INTERACTING]);
    this.renderedPixelToCoordinateTransform_ = t.pixelToCoordinateTransform.slice(), this.renderedRotation_ = t.viewState.rotation, this.renderedOpacity_ = t.layerStatesArray[t.layerIndex].opacity;
    const r = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), o = r.getRenderMode(), a = e.globalAlpha;
    e.globalAlpha = this.renderedOpacity_;
    const l = r.getDeclutter(), h = l ? Nc[o].filter((E) => !ao.includes(E)) : Nc[o], c = t.viewState, u = c.rotation, d = r.getSource(), g = d.getTileGridForProjection(c.projection).getZForResolution(
      c.resolution,
      d.zDirection
    ), _ = this.renderedTiles, m = [], p = [], y = [];
    let x = !0;
    for (let E = _.length - 1; E >= 0; --E) {
      const C = (
        /** @type {import("../../VectorRenderTile.js").default} */
        _[E]
      );
      x = x && !C.getReplayState(r).dirty;
      const w = C.executorGroups[j(r)].filter(
        ($) => $.hasExecutors(h)
      );
      if (w.length === 0)
        continue;
      const S = this.getTileRenderTransform(C, t), v = C.tileCoord[0];
      let R = !1;
      const b = w[0].getClipCoords(S);
      let A = e, N;
      if (b) {
        l && (N = new lh(), A = N.getContext());
        for (let $ = 0, V = m.length; $ < V; ++$)
          if (g !== v && v < p[$]) {
            const D = m[$];
            ye(
              [
                b[0],
                b[3],
                b[4],
                b[7]
              ],
              [D[0], D[3], D[4], D[7]]
            ) && (R || (A.save(), R = !0), A.beginPath(), A.moveTo(b[0], b[1]), A.lineTo(b[2], b[3]), A.lineTo(b[4], b[5]), A.lineTo(b[6], b[7]), A.moveTo(D[6], D[7]), A.lineTo(D[4], D[5]), A.lineTo(D[2], D[3]), A.lineTo(D[0], D[1]), A.clip());
          }
        m.push(b), p.push(v);
      }
      for (let $ = 0, V = w.length; $ < V; ++$)
        w[$].execute(
          e,
          [e.canvas.width, e.canvas.height],
          S,
          u,
          s,
          h
        );
      R && (A === e ? A.restore() : y[E] = N);
    }
    e.globalAlpha = a, this.ready = x, this.tileClipContexts_ = y, super.postRender(e, t);
  }
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {boolean} [declutter] Enable decluttering.
   * @param {number} [index] Render order index.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(e, t, i, s, r, o) {
    if (!i)
      return !1;
    let a = !1;
    if (Array.isArray(i))
      for (let l = 0, h = i.length; l < h; ++l)
        a = lo(
          s,
          e,
          i[l],
          t,
          this.boundHandleStyleImageChange_,
          void 0,
          r,
          o
        ) || a;
    else
      a = lo(
        s,
        e,
        i,
        t,
        this.boundHandleStyleImageChange_,
        void 0,
        r,
        o
      );
    return a;
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @return {boolean} A new tile image was rendered.
   * @private
   */
  tileImageNeedsRender_(e) {
    const t = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    );
    if (t.getRenderMode() === "vector")
      return !1;
    const i = e.getReplayState(t), s = t.getRevision(), r = e.wantedResolution;
    return i.renderedTileResolution !== r || i.renderedTileRevision !== s;
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {import("../../Map").FrameState} frameState Frame state.
   * @private
   */
  renderTileImage_(e, t) {
    const i = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), s = e.getReplayState(i), r = i.getRevision(), o = e.executorGroups[j(i)];
    s.renderedTileRevision = r;
    const a = e.wrappedTileCoord, l = a[0], h = i.getSource();
    let c = t.pixelRatio;
    const d = t.viewState.projection, f = h.getTileGridForProjection(d), g = f.getResolution(e.tileCoord[0]), _ = t.pixelRatio / e.wantedResolution * g, m = f.getResolution(l), p = e.getContext(i);
    c = Math.round(
      Math.max(c, _ / c)
    );
    const y = h.getTilePixelSize(l, c, d);
    p.canvas.width = y[0], p.canvas.height = y[1];
    const x = c / _;
    if (x !== 1) {
      const S = Bh(this.tmpTransform_);
      Ko(S, x, x), p.setTransform.apply(p, S);
    }
    const E = f.getTileCoordExtent(a, this.tmpExtent), C = _ / m, w = Bh(this.tmpTransform_);
    Ko(w, C, -C), o_(w, -E[0], -E[3]);
    for (let S = 0, v = o.length; S < v; ++S)
      o[S].execute(
        p,
        [
          p.canvas.width * x,
          p.canvas.height * x
        ],
        w,
        0,
        !0,
        uC[i.getRenderMode()],
        null
      );
    s.renderedTileResolution = e.wantedResolution;
  }
}
const fC = dC;
class gC extends Bl {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {Object} */
      Object.assign({}, e)
    );
    delete t.preload, delete t.useInterimTilesOnError, super(
      /** @type {import("./BaseVector.js").Options<import("../source/VectorTile.js").default>} */
      t
    ), this.on, this.once, this.un;
    const i = e.renderMode || "hybrid";
    Q(
      i == "hybrid" || i == "vector",
      "`renderMode` must be `'hybrid'` or `'vector'`"
    ), this.renderMode_ = i, this.setPreload(e.preload ? e.preload : 0), this.setUseInterimTilesOnError(
      e.useInterimTilesOnError !== void 0 ? e.useInterimTilesOnError : !0
    ), this.getBackground, this.setBackground;
  }
  createRenderer() {
    return new fC(this);
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   */
  getFeatures(e) {
    return super.getFeatures(e);
  }
  /**
   * @return {VectorTileRenderType} The render mode.
   */
  getRenderMode() {
    return this.renderMode_;
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get(Ri.PRELOAD)
    );
  }
  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get(Ri.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(e) {
    this.set(Ri.PRELOAD, e);
  }
  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(e) {
    this.set(Ri.USE_INTERIM_TILES_ON_ERROR, e);
  }
}
const _C = gC;
class mC extends qE {
  clear() {
    for (; this.getCount() > 0; )
      this.pop().release();
    super.clear();
  }
  /**
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(e) {
    for (; this.canExpireCache() && !(this.peekLast().getKey() in e); )
      this.pop().release();
  }
  /**
   * Prune all tiles from the cache that don't have the same z as the newest tile.
   */
  pruneExceptNewestZ() {
    if (this.getCount() === 0)
      return;
    const e = this.peekFirstKey(), i = uf(e)[0];
    this.forEach((s) => {
      s.tileCoord[0] !== i && (this.remove(cf(s.tileCoord)), s.release());
    });
  }
}
const fh = mC, ma = {
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: "tileloadstart",
  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: "tileloadend",
  /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: "tileloaderror"
}, yn = [0, 0, 0], _i = 5;
class pC {
  /**
   * @param {Options} options Tile grid options.
   */
  constructor(e) {
    this.minZoom = e.minZoom !== void 0 ? e.minZoom : 0, this.resolutions_ = e.resolutions, Q(
      fg(
        this.resolutions_,
        /**
         * @param {number} a First resolution
         * @param {number} b Second resolution
         * @return {number} Comparison result
         */
        (s, r) => r - s,
        !0
      ),
      "`resolutions` must be sorted in descending order"
    );
    let t;
    if (!e.origins) {
      for (let s = 0, r = this.resolutions_.length - 1; s < r; ++s)
        if (!t)
          t = this.resolutions_[s] / this.resolutions_[s + 1];
        else if (this.resolutions_[s] / this.resolutions_[s + 1] !== t) {
          t = void 0;
          break;
        }
    }
    this.zoomFactor_ = t, this.maxZoom = this.resolutions_.length - 1, this.origin_ = e.origin !== void 0 ? e.origin : null, this.origins_ = null, e.origins !== void 0 && (this.origins_ = e.origins, Q(
      this.origins_.length == this.resolutions_.length,
      "Number of `origins` and `resolutions` must be equal"
    ));
    const i = e.extent;
    i !== void 0 && !this.origin_ && !this.origins_ && (this.origin_ = kt(i)), Q(
      !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
      "Either `origin` or `origins` must be configured, never both"
    ), this.tileSizes_ = null, e.tileSizes !== void 0 && (this.tileSizes_ = e.tileSizes, Q(
      this.tileSizes_.length == this.resolutions_.length,
      "Number of `tileSizes` and `resolutions` must be equal"
    )), this.tileSize_ = e.tileSize !== void 0 ? e.tileSize : this.tileSizes_ ? null : nl, Q(
      !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
      "Either `tileSize` or `tileSizes` must be configured, never both"
    ), this.extent_ = i !== void 0 ? i : null, this.fullTileRanges_ = null, this.tmpSize_ = [0, 0], this.tmpExtent_ = [0, 0, 0, 0], e.sizes !== void 0 ? this.fullTileRanges_ = e.sizes.map((s, r) => {
      const o = new hf(
        Math.min(0, s[0]),
        Math.max(s[0] - 1, -1),
        Math.min(0, s[1]),
        Math.max(s[1] - 1, -1)
      );
      if (i) {
        const a = this.getTileRangeForExtentAndZ(i, r);
        o.minX = Math.max(a.minX, o.minX), o.maxX = Math.min(a.maxX, o.maxX), o.minY = Math.max(a.minY, o.minY), o.maxY = Math.min(a.maxY, o.maxY);
      }
      return o;
    }) : i && this.calculateTileRanges_(i);
  }
  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */
  forEachTileCoord(e, t, i) {
    const s = this.getTileRangeForExtentAndZ(e, t);
    for (let r = s.minX, o = s.maxX; r <= o; ++r)
      for (let a = s.minY, l = s.maxY; a <= l; ++a)
        i([t, r, a]);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */
  forEachTileCoordParentTileRange(e, t, i, s) {
    let r, o, a, l = null, h = e[0] - 1;
    for (this.zoomFactor_ === 2 ? (o = e[1], a = e[2]) : l = this.getTileCoordExtent(e, s); h >= this.minZoom; ) {
      if (o !== void 0 && a !== void 0 ? (o = Math.floor(o / 2), a = Math.floor(a / 2), r = pn(o, o, a, a, i)) : r = this.getTileRangeForExtentAndZ(
        l,
        h,
        i
      ), t(h, r))
        return !0;
      --h;
    }
    return !1;
  }
  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */
  getMaxZoom() {
    return this.maxZoom;
  }
  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */
  getMinZoom() {
    return this.minZoom;
  }
  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */
  getOrigin(e) {
    return this.origin_ ? this.origin_ : this.origins_[e];
  }
  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */
  getResolution(e) {
    return this.resolutions_[e];
  }
  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileCoordChildTileRange(e, t, i) {
    if (e[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        const r = e[1] * 2, o = e[2] * 2;
        return pn(
          r,
          r + 1,
          o,
          o + 1,
          t
        );
      }
      const s = this.getTileCoordExtent(
        e,
        i || this.tmpExtent_
      );
      return this.getTileRangeForExtentAndZ(
        s,
        e[0] + 1,
        t
      );
    }
    return null;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileRangeForTileCoordAndZ(e, t, i) {
    if (t > this.maxZoom || t < this.minZoom)
      return null;
    const s = e[0], r = e[1], o = e[2];
    if (t === s)
      return pn(
        r,
        o,
        r,
        o,
        i
      );
    if (this.zoomFactor_) {
      const l = Math.pow(this.zoomFactor_, t - s), h = Math.floor(r * l), c = Math.floor(o * l);
      if (t < s)
        return pn(h, h, c, c, i);
      const u = Math.floor(l * (r + 1)) - 1, d = Math.floor(l * (o + 1)) - 1;
      return pn(h, u, c, d, i);
    }
    const a = this.getTileCoordExtent(e, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(a, t, i);
  }
  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */
  getTileRangeForExtentAndZ(e, t, i) {
    this.getTileCoordForXYAndZ_(e[0], e[3], t, !1, yn);
    const s = yn[1], r = yn[2];
    this.getTileCoordForXYAndZ_(e[2], e[1], t, !0, yn);
    const o = yn[1], a = yn[2];
    return pn(s, o, r, a, i);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */
  getTileCoordCenter(e) {
    const t = this.getOrigin(e[0]), i = this.getResolution(e[0]), s = $e(this.getTileSize(e[0]), this.tmpSize_);
    return [
      t[0] + (e[1] + 0.5) * s[0] * i,
      t[1] - (e[2] + 0.5) * s[1] * i
    ];
  }
  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getTileCoordExtent(e, t) {
    const i = this.getOrigin(e[0]), s = this.getResolution(e[0]), r = $e(this.getTileSize(e[0]), this.tmpSize_), o = i[0] + e[1] * r[0] * s, a = i[1] - (e[2] + 1) * r[1] * s, l = o + r[0] * s, h = a + r[1] * s;
    return ii(o, a, l, h, t);
  }
  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndResolution(e, t, i) {
    return this.getTileCoordForXYAndResolution_(
      e[0],
      e[1],
      t,
      !1,
      i
    );
  }
  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndResolution_(e, t, i, s, r) {
    const o = this.getZForResolution(i), a = i / this.getResolution(o), l = this.getOrigin(o), h = $e(this.getTileSize(o), this.tmpSize_);
    let c = a * (e - l[0]) / i / h[0], u = a * (l[1] - t) / i / h[1];
    return s ? (c = xi(c, _i) - 1, u = xi(u, _i) - 1) : (c = vn(c, _i), u = vn(u, _i)), Dc(o, c, u, r);
  }
  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndZ_(e, t, i, s, r) {
    const o = this.getOrigin(i), a = this.getResolution(i), l = $e(this.getTileSize(i), this.tmpSize_);
    let h = (e - o[0]) / a / l[0], c = (o[1] - t) / a / l[1];
    return s ? (h = xi(h, _i) - 1, c = xi(c, _i) - 1) : (h = vn(h, _i), c = vn(c, _i)), Dc(i, h, c, r);
  }
  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndZ(e, t, i) {
    return this.getTileCoordForXYAndZ_(
      e[0],
      e[1],
      t,
      !1,
      i
    );
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */
  getTileCoordResolution(e) {
    return this.resolutions_[e[0]];
  }
  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */
  getTileSize(e) {
    return this.tileSize_ ? this.tileSize_ : this.tileSizes_[e];
  }
  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default|null} Extent tile range for the specified zoom level.
   */
  getFullTileRange(e) {
    return this.fullTileRanges_ ? this.fullTileRanges_[e] : this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, e) : null;
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */
  getZForResolution(e, t) {
    const i = go(
      this.resolutions_,
      e,
      t || 0
    );
    return _e(i, this.minZoom, this.maxZoom);
  }
  /**
   * The tile with the provided tile coordinate intersects the given viewport.
   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
   */
  tileCoordIntersectsViewport(e, t) {
    return bu(
      t,
      0,
      t.length,
      2,
      this.getTileCoordExtent(e)
    );
  }
  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */
  calculateTileRanges_(e) {
    const t = this.resolutions_.length, i = new Array(t);
    for (let s = this.minZoom; s < t; ++s)
      i[s] = this.getTileRangeForExtentAndZ(e, s);
    this.fullTileRanges_ = i;
  }
}
const gh = pC;
function gf(n) {
  let e = n.getDefaultTileGrid();
  return e || (e = EC(n), n.setDefaultTileGrid(e)), e;
}
function yC(n, e, t) {
  const i = e[0], s = n.getTileCoordCenter(e), r = No(t);
  if (!Qi(r, s)) {
    const o = ie(r), a = Math.ceil(
      (r[0] - s[0]) / o
    );
    return s[0] += o * a, n.getTileCoordForCoordAndZ(s, i);
  }
  return e;
}
function xC(n, e, t, i) {
  i = i !== void 0 ? i : "top-left";
  const s = _f(n, e, t);
  return new gh({
    extent: n,
    origin: Og(n, i),
    resolutions: s,
    tileSize: t
  });
}
function _h(n) {
  const e = n || {}, t = e.extent || ce("EPSG:3857").getExtent(), i = {
    extent: t,
    minZoom: e.minZoom,
    tileSize: e.tileSize,
    resolutions: _f(
      t,
      e.maxZoom,
      e.tileSize,
      e.maxResolution
    )
  };
  return new gh(i);
}
function _f(n, e, t, i) {
  e = e !== void 0 ? e : hu, t = $e(t !== void 0 ? t : nl);
  const s = Te(n), r = ie(n);
  i = i > 0 ? i : Math.max(r / t[0], s / t[1]);
  const o = e + 1, a = new Array(o);
  for (let l = 0; l < o; ++l)
    a[l] = i / Math.pow(2, l);
  return a;
}
function EC(n, e, t, i) {
  const s = No(n);
  return xC(s, e, t, i);
}
function No(n) {
  n = ce(n);
  let e = n.getExtent();
  if (!e) {
    const t = 180 * zn.degrees / n.getMetersPerUnit();
    e = ii(-t, -t, t, t);
  }
  return e;
}
class CC extends uh {
  /**
   * @param {Options} options SourceTile source options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      projection: e.projection,
      state: e.state,
      wrapX: e.wrapX,
      interpolate: e.interpolate
    }), this.on, this.once, this.un, this.opaque_ = e.opaque !== void 0 ? e.opaque : !1, this.tilePixelRatio_ = e.tilePixelRatio !== void 0 ? e.tilePixelRatio : 1, this.tileGrid = e.tileGrid !== void 0 ? e.tileGrid : null;
    const t = [256, 256];
    this.tileGrid && $e(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), t), this.tileCache = new fh(e.cacheSize || 0), this.tmpSize = [0, 0], this.key_ = e.key || "", this.tileOptions = {
      transition: e.transition,
      interpolate: e.interpolate
    }, this.zDirection = e.zDirection ? e.zDirection : 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.tileCache.canExpireCache();
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(e, t) {
    const i = this.getTileCacheForProjection(e);
    i && i.expireCache(t);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {number} z Zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
   *     loaded tile.  If the callback returns `false`, the tile will not be
   *     considered loaded.
   * @return {boolean} The tile range is fully covered with loaded tiles.
   */
  forEachLoadedTile(e, t, i, s) {
    const r = this.getTileCacheForProjection(e);
    if (!r)
      return !1;
    let o = !0, a, l, h;
    for (let c = i.minX; c <= i.maxX; ++c)
      for (let u = i.minY; u <= i.maxY; ++u)
        l = ss(t, c, u), h = !1, r.containsKey(l) && (a = /** @type {!import("../Tile.js").default} */
        r.get(l), h = a.getState() === P.LOADED, h && (h = s(a) !== !1)), h || (o = !1);
    return o;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(e) {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    return this.key_;
  }
  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  setKey(e) {
    this.key_ !== e && (this.key_ = e, this.changed());
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(e) {
    return this.opaque_;
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(e) {
    const t = e ? this.getTileGridForProjection(e) : this.tileGrid;
    return t ? t.getResolutions() : null;
  }
  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   */
  getTile(e, t, i, s, r) {
    return B();
  }
  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
   * @api
   */
  getTileGrid() {
    return this.tileGrid;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(e) {
    return this.tileGrid ? this.tileGrid : gf(e);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   * @protected
   */
  getTileCacheForProjection(e) {
    const t = this.getProjection();
    return Q(
      t === null || Zt(t, e),
      "A VectorTile source can only be rendered if it has a projection compatible with the view projection."
    ), this.tileCache;
  }
  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(e) {
    return this.tilePixelRatio_;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(e, t, i) {
    const s = this.getTileGridForProjection(i), r = this.getTilePixelRatio(t), o = $e(s.getTileSize(e), this.tmpSize);
    return r == 1 ? o : D_(o, r, this.tmpSize);
  }
  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  getTileCoordForTileUrlFunction(e, t) {
    t = t !== void 0 ? t : this.getProjection();
    const i = this.getTileGridForProjection(t);
    return this.getWrapX() && t.isGlobal() && (e = yC(i, e, t)), QE(e, i) ? e : null;
  }
  /**
   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
   * @api
   */
  clear() {
    this.tileCache.clear();
  }
  refresh() {
    this.clear(), super.refresh();
  }
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  updateCacheSize(e, t) {
    const i = this.getTileCacheForProjection(t);
    e > i.highWaterMark && (i.highWaterMark = e);
  }
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  useTile(e, t, i, s) {
  }
}
class wC extends dt {
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */
  constructor(e, t) {
    super(e), this.tile = t;
  }
}
const mf = CC;
function SC(n, e) {
  const t = /\{z\}/g, i = /\{x\}/g, s = /\{y\}/g, r = /\{-y\}/g;
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(o, a, l) {
      if (o)
        return n.replace(t, o[0].toString()).replace(i, o[1].toString()).replace(s, o[2].toString()).replace(r, function() {
          const h = o[0], c = e.getFullTileRange(h);
          if (!c)
            throw new Error(
              "The {-y} placeholder requires a tile grid with extent"
            );
          return (c.getHeight() - o[2] - 1).toString();
        });
    }
  );
}
function vC(n, e) {
  const t = n.length, i = new Array(t);
  for (let s = 0; s < t; ++s)
    i[s] = SC(n[s], e);
  return Qa(i);
}
function Qa(n) {
  return n.length === 1 ? n[0] : (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(e, t, i) {
      if (!e)
        return;
      const s = df(e), r = Hi(s, n.length);
      return n[r](e, t, i);
    }
  );
}
function pf(n) {
  const e = [];
  let t = /\{([a-z])-([a-z])\}/.exec(n);
  if (t) {
    const i = t[1].charCodeAt(0), s = t[2].charCodeAt(0);
    let r;
    for (r = i; r <= s; ++r)
      e.push(n.replace(t[0], String.fromCharCode(r)));
    return e;
  }
  if (t = /\{(\d+)-(\d+)\}/.exec(n), t) {
    const i = parseInt(t[2], 10);
    for (let s = parseInt(t[1], 10); s <= i; s++)
      e.push(n.replace(t[0], s.toString()));
    return e;
  }
  return e.push(n), e;
}
class mh extends mf {
  /**
   * @param {Options} options Image tile options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      opaque: e.opaque,
      projection: e.projection,
      state: e.state,
      tileGrid: e.tileGrid,
      tilePixelRatio: e.tilePixelRatio,
      wrapX: e.wrapX,
      transition: e.transition,
      interpolate: e.interpolate,
      key: e.key,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection
    }), this.generateTileUrlFunction_ = this.tileUrlFunction === mh.prototype.tileUrlFunction, this.tileLoadFunction = e.tileLoadFunction, e.tileUrlFunction && (this.tileUrlFunction = e.tileUrlFunction), this.urls = null, e.urls ? this.setUrls(e.urls) : e.url && this.setUrl(e.url), this.tileLoadingKeys_ = {};
  }
  /**
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  getTileLoadFunction() {
    return this.tileLoadFunction;
  }
  /**
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */
  getTileUrlFunction() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
  }
  /**
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */
  getUrls() {
    return this.urls;
  }
  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(e) {
    const t = (
      /** @type {import("../Tile.js").default} */
      e.target
    ), i = j(t), s = t.getState();
    let r;
    s == P.LOADING ? (this.tileLoadingKeys_[i] = !0, r = ma.TILELOADSTART) : i in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[i], r = s == P.ERROR ? ma.TILELOADERROR : s == P.LOADED ? ma.TILELOADEND : void 0), r != null && this.dispatchEvent(new wC(r, t));
  }
  /**
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  setTileLoadFunction(e) {
    this.tileCache.clear(), this.tileLoadFunction = e, this.changed();
  }
  /**
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string} [key] Optional new tile key for the source.
   * @api
   */
  setTileUrlFunction(e, t) {
    this.tileUrlFunction = e, this.tileCache.pruneExceptNewestZ(), typeof t < "u" ? this.setKey(t) : this.changed();
  }
  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  setUrl(e) {
    const t = pf(e);
    this.urls = t, this.setUrls(t);
  }
  /**
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */
  setUrls(e) {
    this.urls = e;
    const t = e.join(`
`);
    this.generateTileUrlFunction_ ? this.setTileUrlFunction(vC(e, this.tileGrid), t) : this.setKey(t);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */
  tileUrlFunction(e, t, i) {
  }
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   */
  useTile(e, t, i) {
    const s = ss(e, t, i);
    this.tileCache.containsKey(s) && this.tileCache.get(s);
  }
}
const yf = mh;
class TC extends yf {
  /**
   * @param {!Options} options Image tile options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      opaque: e.opaque,
      projection: e.projection,
      state: e.state,
      tileGrid: e.tileGrid,
      tileLoadFunction: e.tileLoadFunction ? e.tileLoadFunction : RC,
      tilePixelRatio: e.tilePixelRatio,
      tileUrlFunction: e.tileUrlFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX,
      transition: e.transition,
      interpolate: e.interpolate !== void 0 ? e.interpolate : !0,
      key: e.key,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection
    }), this.crossOrigin = e.crossOrigin !== void 0 ? e.crossOrigin : null, this.tileClass = e.tileClass !== void 0 ? e.tileClass : af, this.tileCacheForProjection = {}, this.tileGridForProjection = {}, this.reprojectionErrorThreshold_ = e.reprojectionErrorThreshold, this.renderReprojectionEdges_ = !1;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    if (this.tileCache.canExpireCache())
      return !0;
    for (const e in this.tileCacheForProjection)
      if (this.tileCacheForProjection[e].canExpireCache())
        return !0;
    return !1;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(e, t) {
    const i = this.getTileCacheForProjection(e);
    this.tileCache.expireCache(
      this.tileCache == i ? t : {}
    );
    for (const s in this.tileCacheForProjection) {
      const r = this.tileCacheForProjection[s];
      r.expireCache(r == i ? t : {});
    }
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(e) {
    return this.getProjection() && e && !Zt(this.getProjection(), e) ? 0 : this.getGutter();
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    let e = super.getKey();
    return this.getInterpolate() || (e += ":disable-interpolation"), e;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(e) {
    return this.getProjection() && e && !Zt(this.getProjection(), e) ? !1 : super.getOpaque(e);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(e) {
    const t = this.getProjection();
    if (this.tileGrid && (!t || Zt(t, e)))
      return this.tileGrid;
    const i = j(e);
    return i in this.tileGridForProjection || (this.tileGridForProjection[i] = gf(e)), this.tileGridForProjection[i];
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   */
  getTileCacheForProjection(e) {
    const t = this.getProjection();
    if (!t || Zt(t, e))
      return this.tileCache;
    const i = j(e);
    return i in this.tileCacheForProjection || (this.tileCacheForProjection[i] = new fh(
      this.tileCache.highWaterMark
    )), this.tileCacheForProjection[i];
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!ImageTile} Tile.
   * @private
   */
  createTile_(e, t, i, s, r, o) {
    const a = [e, t, i], l = this.getTileCoordForTileUrlFunction(
      a,
      r
    ), h = l ? this.tileUrlFunction(l, s, r) : void 0, c = new this.tileClass(
      a,
      h !== void 0 ? P.IDLE : P.EMPTY,
      h !== void 0 ? h : "",
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions
    );
    return c.key = o, c.addEventListener(G.CHANGE, this.handleTileChange.bind(this)), c;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   */
  getTile(e, t, i, s, r) {
    const o = this.getProjection();
    if (!o || !r || Zt(o, r))
      return this.getTileInternal(
        e,
        t,
        i,
        s,
        o || r
      );
    const a = this.getTileCacheForProjection(r), l = [e, t, i];
    let h;
    const c = cf(l);
    a.containsKey(c) && (h = a.get(c));
    const u = this.getKey();
    if (h && h.key == u)
      return h;
    const d = this.getTileGridForProjection(o), f = this.getTileGridForProjection(r), g = this.getTileCoordForTileUrlFunction(
      l,
      r
    ), _ = new qa(
      o,
      d,
      r,
      f,
      l,
      g,
      this.getTilePixelRatio(s),
      this.getGutter(),
      (m, p, y, x) => this.getTileInternal(m, p, y, x, o),
      this.reprojectionErrorThreshold_,
      this.renderReprojectionEdges_,
      this.tileOptions
    );
    return _.key = u, h ? (_.interimTile = h, _.refreshInterimChain(), a.replace(c, _)) : a.set(c, _), _;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!ImageTile} Tile.
   * @protected
   */
  getTileInternal(e, t, i, s, r) {
    let o = null;
    const a = ss(e, t, i), l = this.getKey();
    if (!this.tileCache.containsKey(a))
      o = this.createTile_(e, t, i, s, r, l), this.tileCache.set(a, o);
    else if (o = this.tileCache.get(a), o.key != l) {
      const h = o;
      o = this.createTile_(e, t, i, s, r, l), h.getState() == P.IDLE ? o.interimTile = h.interimTile : o.interimTile = h, o.refreshInterimChain(), this.tileCache.replace(a, o);
    }
    return o;
  }
  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  setRenderReprojectionEdges(e) {
    if (this.renderReprojectionEdges_ != e) {
      this.renderReprojectionEdges_ = e;
      for (const t in this.tileCacheForProjection)
        this.tileCacheForProjection[t].clear();
      this.changed();
    }
  }
  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  setTileGridForProjection(e, t) {
    const i = ce(e);
    if (i) {
      const s = j(i);
      s in this.tileGridForProjection || (this.tileGridForProjection[s] = t);
    }
  }
  clear() {
    super.clear();
    for (const e in this.tileCacheForProjection)
      this.tileCacheForProjection[e].clear();
  }
}
function RC(n, e) {
  n.getImage().src = e;
}
const ph = TC;
class IC extends ph {
  /**
   * @param {Options} [options] XYZ options.
   */
  constructor(e) {
    e = e || {};
    const t = e.projection !== void 0 ? e.projection : "EPSG:3857", i = e.tileGrid !== void 0 ? e.tileGrid : _h({
      extent: No(t),
      maxResolution: e.maxResolution,
      maxZoom: e.maxZoom,
      minZoom: e.minZoom,
      tileSize: e.tileSize
    });
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      opaque: e.opaque,
      projection: t,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileGrid: i,
      tileLoadFunction: e.tileLoadFunction,
      tilePixelRatio: e.tilePixelRatio,
      tileUrlFunction: e.tileUrlFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
      transition: e.transition,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection
    }), this.gutter_ = e.gutter !== void 0 ? e.gutter : 0;
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return this.gutter_;
  }
}
const xf = IC;
class PC extends Xu {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection (of the data).
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent.
   * @param {number} targetResolution Target resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {FunctionType} getImageFunction
   *     Function returning source images (extent, resolution, pixelRatio).
   * @param {boolean} interpolate Use linear interpolation when resampling.
   */
  constructor(e, t, i, s, r, o, a) {
    let l = e.getExtent();
    l && e.canWrapX() && (l = l.slice(), l[0] = -1 / 0, l[2] = 1 / 0);
    let h = t.getExtent();
    h && t.canWrapX() && (h = h.slice(), h[0] = -1 / 0, h[2] = 1 / 0);
    const c = h ? qt(i, h) : i, u = Ot(c), d = Ys(
      e,
      t,
      u,
      s
    ), f = sf, g = new rf(
      e,
      t,
      c,
      l,
      d * f,
      s
    ), _ = g.calculateSourceExtent(), m = Jn(_) ? null : o(_, d, r), p = m ? M.IDLE : M.EMPTY, y = m ? m.getPixelRatio() : 1;
    super(i, s, y, p), this.targetProj_ = t, this.maxSourceExtent_ = l, this.triangulation_ = g, this.targetResolution_ = s, this.targetExtent_ = i, this.sourceImage_ = m, this.sourcePixelRatio_ = y, this.interpolate_ = a, this.canvas_ = null, this.sourceListenerKey_ = null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.state == M.LOADING && this.unlistenSource_(), super.disposeInternal();
  }
  /**
   * @return {HTMLCanvasElement} Image.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @return {import("../proj/Projection.js").default} Projection.
   */
  getProjection() {
    return this.targetProj_;
  }
  /**
   * @private
   */
  reproject_() {
    const e = this.sourceImage_.getState();
    if (e == M.LOADED) {
      const t = ie(this.targetExtent_) / this.targetResolution_, i = Te(this.targetExtent_) / this.targetResolution_;
      this.canvas_ = of(
        t,
        i,
        this.sourcePixelRatio_,
        Ja(this.sourceImage_.getResolution()),
        this.maxSourceExtent_,
        this.targetResolution_,
        this.targetExtent_,
        this.triangulation_,
        [
          {
            extent: this.sourceImage_.getExtent(),
            image: this.sourceImage_.getImage()
          }
        ],
        0,
        void 0,
        this.interpolate_,
        !0
      );
    }
    this.state = e, this.changed();
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == M.IDLE) {
      this.state = M.LOADING, this.changed();
      const e = this.sourceImage_.getState();
      e == M.LOADED || e == M.ERROR ? this.reproject_() : (this.sourceListenerKey_ = Z(
        this.sourceImage_,
        G.CHANGE,
        function(t) {
          const i = this.sourceImage_.getState();
          (i == M.LOADED || i == M.ERROR) && (this.unlistenSource_(), this.reproject_());
        },
        this
      ), this.sourceImage_.load());
    }
  }
  /**
   * @private
   */
  unlistenSource_() {
    he(
      /** @type {!import("../events.js").EventsKey} */
      this.sourceListenerKey_
    ), this.sourceListenerKey_ = null;
  }
}
const LC = PC, Ii = 4, pa = {
  /**
   * Triggered when an image starts loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadstart
   * @api
   */
  IMAGELOADSTART: "imageloadstart",
  /**
   * Triggered when an image finishes loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadend
   * @api
   */
  IMAGELOADEND: "imageloadend",
  /**
   * Triggered if image loading results in an error.
   * @event module:ol/source/Image.ImageSourceEvent#imageloaderror
   * @api
   */
  IMAGELOADERROR: "imageloaderror"
};
class bC extends dt {
  /**
   * @param {string} type Type.
   * @param {import("../Image.js").default} image The image.
   */
  constructor(e, t) {
    super(e), this.image = t;
  }
}
class AC extends uh {
  /**
   * @param {Options} options Single image source options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      projection: e.projection,
      state: e.state,
      interpolate: e.interpolate !== void 0 ? e.interpolate : !0
    }), this.on, this.once, this.un, this.loader = e.loader || null, this.resolutions_ = e.resolutions !== void 0 ? e.resolutions : null, this.reprojectedImage_ = null, this.reprojectedRevision_ = 0, this.image = null, this.wantedExtent_, this.wantedResolution_, this.static_ = e.loader ? e.loader.length === 0 : !1, this.wantedProjection_ = null;
  }
  /**
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {Array<number>|null} resolutions Resolutions.
   */
  setResolutions(e) {
    this.resolutions_ = e;
  }
  /**
   * @protected
   * @param {number} resolution Resolution.
   * @return {number} Resolution.
   */
  findNearestResolution(e) {
    const t = this.getResolutions();
    if (t) {
      const i = go(t, e, 0);
      e = t[i];
    }
    return e;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */
  getImage(e, t, i, s) {
    const r = this.getProjection();
    if (!r || !s || Zt(r, s))
      return r && (s = r), this.getImageInternal(e, t, i, s);
    if (this.reprojectedImage_) {
      if (this.reprojectedRevision_ == this.getRevision() && Zt(this.reprojectedImage_.getProjection(), s) && this.reprojectedImage_.getResolution() == t && Mi(this.reprojectedImage_.getExtent(), e))
        return this.reprojectedImage_;
      this.reprojectedImage_.dispose(), this.reprojectedImage_ = null;
    }
    return this.reprojectedImage_ = new LC(
      r,
      s,
      e,
      t,
      i,
      (o, a, l) => this.getImageInternal(o, a, l, r),
      this.getInterpolate()
    ), this.reprojectedRevision_ = this.getRevision(), this.reprojectedImage_;
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   * @protected
   */
  getImageInternal(e, t, i, s) {
    if (this.loader) {
      const r = Ef(e, t, i, 1), o = this.findNearestResolution(t);
      if (this.image && (this.static_ || this.wantedProjection_ === s && (this.wantedExtent_ && rt(this.wantedExtent_, r) || rt(this.image.getExtent(), r)) && (this.wantedResolution_ && Ja(this.wantedResolution_) === o || Ja(this.image.getResolution()) === o)))
        return this.image;
      this.wantedProjection_ = s, this.wantedExtent_ = r, this.wantedResolution_ = o, this.image = new Xu(
        r,
        o,
        i,
        this.loader
      ), this.image.addEventListener(
        G.CHANGE,
        this.handleImageChange.bind(this)
      );
    }
    return this.image;
  }
  /**
   * Handle image change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleImageChange(e) {
    const t = (
      /** @type {import("../Image.js").default} */
      e.target
    );
    let i;
    switch (t.getState()) {
      case M.LOADING:
        this.loading = !0, i = pa.IMAGELOADSTART;
        break;
      case M.LOADED:
        this.loading = !1, i = pa.IMAGELOADEND;
        break;
      case M.ERROR:
        this.loading = !1, i = pa.IMAGELOADERROR;
        break;
      default:
        return;
    }
    this.hasListener(i) && this.dispatchEvent(new bC(i, t));
  }
}
function FC(n, e) {
  n.getImage().src = e;
}
function Ef(n, e, t, i) {
  const s = e / t, r = Ot(n), o = xi(ie(n) / s, Ii), a = xi(Te(n) / s, Ii), l = xi((i - 1) * o / 2, Ii), h = o + 2 * l, c = xi((i - 1) * a / 2, Ii), u = a + 2 * c;
  return Ms(r, s, 0, [
    h,
    u
  ]);
}
const MC = AC;
function Xs(n, e) {
  const t = [];
  Object.keys(e).forEach(function(s) {
    e[s] !== null && e[s] !== void 0 && t.push(s + "=" + encodeURIComponent(e[s]));
  });
  const i = t.join("&");
  return n = n.replace(/[?&]$/, ""), n += n.includes("?") ? "&" : "?", n + i;
}
const ho = "1.3.0", kc = [101, 101];
function Cf(n, e, t, i, s) {
  s.WIDTH = t[0], s.HEIGHT = t[1];
  const r = i.getAxisOrientation();
  let o;
  const a = ll(s.VERSION, "1.3") >= 0;
  return s[a ? "CRS" : "SRS"] = i.getCode(), a && r.substr(0, 2) == "ne" ? o = [e[1], e[0], e[3], e[2]] : o = e, s.BBOX = o.join(","), Xs(
    /** @type {string} */
    n,
    s
  );
}
function wf(n, e, t, i, s, r, o) {
  r = Object.assign({ REQUEST: "GetMap" }, r);
  const a = e / t, l = [
    Gh(ie(n) / a, Ii),
    Gh(Te(n) / a, Ii)
  ];
  if (t != 1)
    switch (o) {
      case "geoserver":
        const c = 90 * t + 0.5 | 0;
        "FORMAT_OPTIONS" in r ? r.FORMAT_OPTIONS += ";dpi:" + c : r.FORMAT_OPTIONS = "dpi:" + c;
        break;
      case "mapserver":
        r.MAP_RESOLUTION = 90 * t;
        break;
      case "carmentaserver":
      case "qgis":
        r.DPI = 90 * t;
        break;
      default:
        throw new Error("Unknown `serverType` configured");
    }
  return Cf(s, n, l, i, r);
}
function co(n, e) {
  return Object.assign(
    {
      REQUEST: e,
      SERVICE: "WMS",
      VERSION: ho,
      FORMAT: "image/png",
      STYLES: "",
      TRANSPARENT: !0
    },
    n
  );
}
function OC(n) {
  const e = n.hidpi === void 0 ? !0 : n.hidpi, t = ce(n.projection || "EPSG:3857"), i = n.ratio || 1.5, s = n.load || Wu;
  return (r, o, a) => {
    r = Ef(r, o, a, i), a != 1 && (!e || n.serverType === void 0) && (a = 1);
    const l = wf(
      r,
      o,
      a,
      t,
      n.url,
      co(n.params, "GetMap"),
      n.serverType
    ), h = new Image();
    return n.crossOrigin !== null && (h.crossOrigin = n.crossOrigin), s(h, l).then((c) => ({ image: c, extent: r, pixelRatio: a }));
  };
}
function DC(n, e, t) {
  if (n.url === void 0)
    return;
  const i = ce(n.projection || "EPSG:3857"), s = Ms(
    e,
    t,
    0,
    kc
  ), r = {
    QUERY_LAYERS: n.params.LAYERS,
    INFO_FORMAT: "application/json"
  };
  Object.assign(
    r,
    co(n.params, "GetFeatureInfo"),
    n.params
  );
  const o = vn((e[0] - s[0]) / t, Ii), a = vn((s[3] - e[1]) / t, Ii), l = ll(r.VERSION, "1.3") >= 0;
  return r[l ? "I" : "X"] = o, r[l ? "J" : "Y"] = a, Cf(
    n.url,
    s,
    kc,
    i,
    r
  );
}
function NC(n, e) {
  if (n.url === void 0)
    return;
  const t = {
    SERVICE: "WMS",
    VERSION: ho,
    REQUEST: "GetLegendGraphic",
    FORMAT: "image/png"
  };
  if (n.params === void 0 || n.params.LAYER === void 0) {
    const i = n.params.LAYERS;
    if (!(!Array.isArray(i) || i.length === 1))
      return;
    t.LAYER = i;
  }
  if (e !== void 0) {
    const i = ce(n.projection || "EPSG:3857").getMetersPerUnit() || 1, s = 28e-5;
    t.SCALE = e * i / s;
  }
  return Object.assign(t, n.params), Xs(n.url, t);
}
class kC extends MC {
  /**
   * @param {Options} [options] ImageWMS options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      interpolate: e.interpolate,
      projection: e.projection,
      resolutions: e.resolutions
    }), this.crossOrigin_ = e.crossOrigin !== void 0 ? e.crossOrigin : null, this.url_ = e.url, this.imageLoadFunction_ = e.imageLoadFunction !== void 0 ? e.imageLoadFunction : FC, this.params_ = Object.assign({}, e.params), this.serverType_ = e.serverType, this.hidpi_ = e.hidpi !== void 0 ? e.hidpi : !0, this.renderedRevision_ = 0, this.ratio_ = e.ratio !== void 0 ? e.ratio : 1.5, this.loaderProjection_ = null;
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */
  getFeatureInfoUrl(e, t, i, s) {
    const r = ce(i), o = this.getProjection();
    o && o !== r && (t = Ys(
      o,
      r,
      e,
      t
    ), e = po(e, r, o));
    const a = {
      url: this.url_,
      params: {
        ...this.params_,
        ...s
      },
      projection: o || r
    };
    return DC(a, e, t);
  }
  /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */
  getLegendUrl(e, t) {
    return NC(
      {
        url: this.url_,
        params: {
          ...this.params_,
          ...t
        }
      },
      e
    );
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */
  getImageInternal(e, t, i, s) {
    return this.url_ === void 0 ? null : ((!this.loader || this.loaderProjection_ !== s) && (this.loaderProjection_ = s, this.loader = OC({
      crossOrigin: this.crossOrigin_,
      params: this.params_,
      projection: s,
      serverType: this.serverType_,
      hidpi: this.hidpi_,
      url: this.url_,
      ratio: this.ratio_,
      load: (r, o) => (this.image.setImage(r), this.imageLoadFunction_(this.image, o), Wu(r))
    })), super.getImageInternal(e, t, i, s));
  }
  /**
   * Return the image load function of the source.
   * @return {import("../Image.js").LoadFunction} The image load function.
   * @api
   */
  getImageLoadFunction() {
    return this.imageLoadFunction_;
  }
  /**
   * Return the URL used for this WMS source.
   * @return {string|undefined} URL.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * Set the image load function of the source.
   * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
   * @api
   */
  setImageLoadFunction(e) {
    this.imageLoadFunction_ = e, this.changed();
  }
  /**
   * Set the URL to use for requests.
   * @param {string|undefined} url URL.
   * @api
   */
  setUrl(e) {
    e != this.url_ && (this.url_ = e, this.loader = null, this.changed());
  }
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  updateParams(e) {
    Object.assign(this.params_, e), this.changed();
  }
  changed() {
    this.image = null, super.changed();
  }
}
const GC = kC;
let zC = class extends Do {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Data source url.
   * @param {import("./format/Feature.js").default<typeof import("./Feature.js").default|typeof import("./render/Feature.js").default>} format Feature format.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(e, t, i, s, r, o) {
    super(e, t, o), this.extent = null, this.format_ = s, this.features_ = null, this.loader_, this.projection = null, this.resolution, this.tileLoadFunction_ = r, this.url_ = i, this.key = i;
  }
  /**
   * Get the feature format assigned for reading this tile's features.
   * @return {import("./format/Feature.js").default} Feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * Get the features for this tile. Geometries will be in the view projection.
   * @return {Array<import("./Feature.js").FeatureLike>} Features.
   * @api
   */
  getFeatures() {
    return this.features_;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    this.state == P.IDLE && (this.setState(P.LOADING), this.tileLoadFunction_(this, this.url_), this.loader_ && this.loader_(this.extent, this.resolution, this.projection));
  }
  /**
   * Handler for successful tile load.
   * @param {Array<import("./Feature.js").default>} features The loaded features.
   * @param {import("./proj/Projection.js").default} dataProjection Data projection.
   */
  onLoad(e, t) {
    this.setFeatures(e);
  }
  /**
   * Handler for tile load errors.
   */
  onError() {
    this.setState(P.ERROR);
  }
  /**
   * Function for use in an {@link module:ol/source/VectorTile~VectorTile}'s `tileLoadFunction`.
   * Sets the features for the tile.
   * @param {Array<import("./Feature.js").FeatureLike>} features Features.
   * @api
   */
  setFeatures(e) {
    this.features_ = e, this.setState(P.LOADED);
  }
  /**
   * Set the feature loader for reading this tile's features.
   * @param {import("./featureloader.js").FeatureLoader} loader Feature loader.
   * @api
   */
  setLoader(e) {
    this.loader_ = e;
  }
};
const $C = zC, Gc = [];
class UC extends Do {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {import("./tilecoord.js").TileCoord} urlTileCoord Wrapped tile coordinate for source urls.
   * @param {function(VectorRenderTile):Array<import("./VectorTile").default>} getSourceTiles Function
   * to get source tiles for this tile.
   */
  constructor(e, t, i, s) {
    super(e, t, { transition: 0 }), this.context_ = {}, this.executorGroups = {}, this.loadingSourceTiles = 0, this.hitDetectionImageData = {}, this.replayState_ = {}, this.sourceTiles = [], this.errorTileKeys = {}, this.wantedResolution, this.getSourceTiles = s.bind(void 0, this), this.wrappedTileCoord = i;
  }
  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {CanvasRenderingContext2D} The rendering context.
   */
  getContext(e) {
    const t = j(e);
    return t in this.context_ || (this.context_[t] = Pe(1, 1, Gc)), this.context_[t];
  }
  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {boolean} Tile has a rendering context for the given layer.
   */
  hasContext(e) {
    return j(e) in this.context_;
  }
  /**
   * Get the Canvas for this tile.
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {HTMLCanvasElement} Canvas.
   */
  getImage(e) {
    return this.hasContext(e) ? this.getContext(e).canvas : null;
  }
  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {ReplayState} The replay state.
   */
  getReplayState(e) {
    const t = j(e);
    return t in this.replayState_ || (this.replayState_[t] = {
      dirty: !1,
      renderedRenderOrder: null,
      renderedResolution: NaN,
      renderedRevision: -1,
      renderedTileResolution: NaN,
      renderedTileRevision: -1,
      renderedTileZ: -1
    }), this.replayState_[t];
  }
  /**
   * Load the tile.
   */
  load() {
    this.getSourceTiles();
  }
  /**
   * Remove from the cache due to expiry
   */
  release() {
    for (const e in this.context_) {
      const t = this.context_[e];
      ir(t), Gc.push(t.canvas), delete this.context_[e];
    }
    super.release();
  }
}
const VC = UC;
class jC extends yf {
  /**
   * @param {!Options<FeatureType>} options Vector tile options.
   */
  constructor(e) {
    const t = e.projection || "EPSG:3857", i = e.extent || No(t), s = e.tileGrid || _h({
      extent: i,
      maxResolution: e.maxResolution,
      maxZoom: e.maxZoom !== void 0 ? e.maxZoom : 22,
      minZoom: e.minZoom,
      tileSize: e.tileSize || 512
    });
    super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      cacheSize: e.cacheSize,
      interpolate: !0,
      opaque: !1,
      projection: t,
      state: e.state,
      tileGrid: s,
      tileLoadFunction: e.tileLoadFunction ? e.tileLoadFunction : XC,
      tileUrlFunction: e.tileUrlFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX === void 0 ? !0 : e.wrapX,
      transition: e.transition,
      zDirection: e.zDirection === void 0 ? 1 : e.zDirection
    }), this.format_ = e.format ? e.format : null, this.sourceTileCache = new fh(this.tileCache.highWaterMark), this.overlaps_ = e.overlaps == null ? !0 : e.overlaps, this.tileClass = e.tileClass ? e.tileClass : $C, this.tileGrids_ = {};
  }
  /**
   * Get features whose bounding box intersects the provided extent. Only features for cached
   * tiles for the last rendered zoom level are available in the source. So this method is only
   * suitable for requesting tiles for extents that are currently rendered.
   *
   * Features are returned in random tile order and as they are included in the tiles. This means
   * they can be clipped, duplicated across tiles, and simplified to the render resolution.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   * @api
   */
  getFeaturesInExtent(e) {
    const t = [], i = this.tileCache;
    if (i.getCount() === 0)
      return t;
    const s = uf(i.peekFirstKey())[0], r = this.tileGrid;
    return i.forEach(function(o) {
      if (o.tileCoord[0] !== s || o.getState() !== P.LOADED)
        return;
      const a = o.getSourceTiles();
      for (let l = 0, h = a.length; l < h; ++l) {
        const c = a[l], u = c.tileCoord;
        if (ye(e, r.getTileCoordExtent(u))) {
          const d = c.getFeatures();
          if (d)
            for (let f = 0, g = d.length; f < g; ++f) {
              const _ = d[f], m = _.getGeometry();
              ye(e, m.getExtent()) && t.push(_);
            }
        }
      }
    }), t;
  }
  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  getOverlaps() {
    return this.overlaps_;
  }
  /**
   * clear {@link module:ol/TileCache~TileCache} and delete all source tiles
   * @api
   */
  clear() {
    this.tileCache.clear(), this.sourceTileCache.clear();
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(e, t) {
    const i = this.getTileCacheForProjection(e), s = Object.keys(t).reduce((r, o) => {
      const a = JE(o), l = i.peek(a);
      if (l) {
        const h = l.sourceTiles;
        for (let c = 0, u = h.length; c < u; ++c)
          r[h[c].getKey()] = !0;
      }
      return r;
    }, {});
    super.expireCache(e, t), this.sourceTileCache.expireCache(s);
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection").default} projection Projection.
   * @param {VectorRenderTile} tile Vector image tile.
   * @return {Array<import("../VectorTile").default>} Tile keys.
   */
  getSourceTiles(e, t, i) {
    if (i.getState() === P.IDLE) {
      i.setState(P.LOADING);
      const s = i.wrappedTileCoord, r = this.getTileGridForProjection(t), o = r.getTileCoordExtent(s), a = s[0], l = r.getResolution(a);
      ot(o, -l, o);
      const h = this.tileGrid, c = h.getExtent();
      c && qt(o, c, o);
      const u = h.getZForResolution(
        l,
        this.zDirection
      );
      h.forEachTileCoord(o, u, (d) => {
        const f = this.tileUrlFunction(
          d,
          e,
          t
        ), g = this.sourceTileCache.containsKey(f) ? this.sourceTileCache.get(f) : new this.tileClass(
          d,
          f ? P.IDLE : P.EMPTY,
          f,
          this.format_,
          this.tileLoadFunction
        );
        i.sourceTiles.push(g);
        const _ = g.getState();
        if (_ < P.LOADED) {
          const m = (p) => {
            this.handleTileChange(p);
            const y = g.getState();
            if (y === P.LOADED || y === P.ERROR) {
              const x = g.getKey();
              x in i.errorTileKeys ? g.getState() === P.LOADED && delete i.errorTileKeys[x] : i.loadingSourceTiles--, y === P.ERROR ? i.errorTileKeys[x] = !0 : g.removeEventListener(G.CHANGE, m), i.loadingSourceTiles === 0 && i.setState(
                Fi(i.errorTileKeys) ? P.LOADED : P.ERROR
              );
            }
          };
          g.addEventListener(G.CHANGE, m), i.loadingSourceTiles++;
        }
        _ === P.IDLE && (g.extent = h.getTileCoordExtent(d), g.projection = t, g.resolution = h.getResolution(
          d[0]
        ), this.sourceTileCache.set(f, g), g.load());
      }), i.loadingSourceTiles || i.setState(
        i.sourceTiles.some(
          (d) => d.getState() === P.ERROR
        ) ? P.ERROR : P.LOADED
      );
    }
    return i.sourceTiles;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!VectorRenderTile} Tile.
   */
  getTile(e, t, i, s, r) {
    const o = ss(e, t, i), a = this.getKey();
    let l;
    if (this.tileCache.containsKey(o) && (l = this.tileCache.get(o), l.key === a))
      return l;
    const h = [e, t, i];
    let c = this.getTileCoordForTileUrlFunction(
      h,
      r
    );
    const u = this.getTileGrid().getExtent(), d = this.getTileGridForProjection(r);
    if (c && u) {
      const _ = d.getTileCoordExtent(c);
      ot(_, -d.getResolution(e), _), ye(u, _) || (c = null);
    }
    let f = !0;
    if (c !== null) {
      const _ = this.tileGrid, m = d.getResolution(e), p = _.getZForResolution(m, 1), y = d.getTileCoordExtent(c);
      ot(y, -m, y), _.forEachTileCoord(y, p, (x) => {
        f = f && !this.tileUrlFunction(x, s, r);
      });
    }
    const g = new VC(
      h,
      f ? P.EMPTY : P.IDLE,
      c,
      this.getSourceTiles.bind(this, s, r)
    );
    return g.key = a, l ? (g.interimTile = l, g.refreshInterimChain(), this.tileCache.replace(o, g)) : this.tileCache.set(o, g), g;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(e) {
    const t = e.getCode();
    let i = this.tileGrids_[t];
    if (!i) {
      const s = this.tileGrid, r = s.getResolutions().slice(), o = r.map(function(h, c) {
        return s.getOrigin(c);
      }), a = r.map(function(h, c) {
        return s.getTileSize(c);
      }), l = hu + 1;
      for (let h = r.length; h < l; ++h)
        r.push(r[h - 1] / 2), o.push(o[h - 1]), a.push(a[h - 1]);
      i = new gh({
        extent: s.getExtent(),
        origins: o,
        resolutions: r,
        tileSizes: a
      }), this.tileGrids_[t] = i;
    }
    return i;
  }
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(e) {
    return e;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(e, t, i) {
    const s = this.getTileGridForProjection(i), r = $e(s.getTileSize(e), this.tmpSize);
    return [
      Math.round(r[0] * t),
      Math.round(r[1] * t)
    ];
  }
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  updateCacheSize(e, t) {
    super.updateCacheSize(e * 2, t), this.sourceTileCache.highWaterMark = this.getTileCacheForProjection(t).highWaterMark;
  }
}
const YC = jC;
function XC(n, e) {
  n.setLoader(
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */
    function(t, i, s) {
      nf(
        e,
        n.getFormat(),
        t,
        i,
        s,
        n.onLoad.bind(n),
        n.onError.bind(n)
      );
    }
  );
}
const BC = '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
class WC extends xf {
  /**
   * @param {Options} [options] Open Street Map options.
   */
  constructor(e) {
    e = e || {};
    let t;
    e.attributions !== void 0 ? t = e.attributions : t = [BC];
    const i = e.crossOrigin !== void 0 ? e.crossOrigin : "anonymous", s = e.url !== void 0 ? e.url : "https://tile.openstreetmap.org/{z}/{x}/{y}.png";
    super({
      attributions: t,
      attributionsCollapsible: !1,
      cacheSize: e.cacheSize,
      crossOrigin: i,
      interpolate: e.interpolate,
      maxZoom: e.maxZoom !== void 0 ? e.maxZoom : 19,
      opaque: e.opaque !== void 0 ? e.opaque : !0,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileLoadFunction: e.tileLoadFunction,
      transition: e.transition,
      url: s,
      wrapX: e.wrapX,
      zDirection: e.zDirection
    });
  }
}
const KC = WC;
class ZC extends ph {
  /**
   * @param {Options} [options] Tile WMS options.
   */
  constructor(e) {
    e = e || /** @type {Options} */
    {};
    const t = Object.assign({}, e.params), i = "TRANSPARENT" in t ? t.TRANSPARENT : !0;
    super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      opaque: !i,
      projection: e.projection,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileClass: e.tileClass,
      tileGrid: e.tileGrid,
      tileLoadFunction: e.tileLoadFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
      transition: e.transition,
      zDirection: e.zDirection
    }), this.gutter_ = e.gutter !== void 0 ? e.gutter : 0, this.params_ = t, this.v13_ = !0, this.serverType_ = e.serverType, this.hidpi_ = e.hidpi !== void 0 ? e.hidpi : !0, this.tmpExtent_ = Je(), this.updateV13_(), this.setKey(this.getKeyForParams_());
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */
  getFeatureInfoUrl(e, t, i, s) {
    const r = ce(i), o = this.getProjection() || r;
    let a = this.getTileGrid();
    a || (a = this.getTileGridForProjection(o));
    const l = po(
      e,
      r,
      o
    ), h = Ys(
      o,
      r,
      e,
      t
    ), c = a.getZForResolution(h, this.zDirection), u = a.getResolution(c), d = a.getTileCoordForCoordAndZ(l, c);
    if (a.getResolutions().length <= d[0])
      return;
    let f = a.getTileCoordExtent(d, this.tmpExtent_);
    const g = this.gutter_;
    g !== 0 && (f = ot(f, u * g, f));
    const _ = {
      QUERY_LAYERS: this.params_.LAYERS
    };
    Object.assign(
      _,
      co(this.params_, "GetFeatureInfo"),
      s
    );
    const m = Math.floor((l[0] - f[0]) / u), p = Math.floor((f[3] - l[1]) / u);
    return _[this.v13_ ? "I" : "X"] = m, _[this.v13_ ? "J" : "Y"] = p, this.getRequestUrl_(
      d,
      f,
      1,
      o || r,
      _
    );
  }
  /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */
  getLegendUrl(e, t) {
    if (this.urls[0] === void 0)
      return;
    const i = {
      SERVICE: "WMS",
      VERSION: ho,
      REQUEST: "GetLegendGraphic",
      FORMAT: "image/png"
    };
    if (t === void 0 || t.LAYER === void 0) {
      const s = this.params_.LAYERS;
      if (!(!Array.isArray(s) || s.length === 1))
        return;
      i.LAYER = s;
    }
    if (e !== void 0) {
      const s = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1, r = 28e-5;
      i.SCALE = e * s / r;
    }
    return Object.assign(i, t), Xs(
      /** @type {string} */
      this.urls[0],
      i
    );
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return this.gutter_;
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} tileExtent Tile extent.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string|undefined} Request URL.
   * @private
   */
  getRequestUrl_(e, t, i, s, r) {
    const o = this.urls;
    if (!o)
      return;
    let a;
    if (o.length == 1)
      a = o[0];
    else {
      const l = Hi(df(e), o.length);
      a = o[l];
    }
    return wf(
      t,
      (this.tileGrid || this.getTileGridForProjection(s)).getResolution(e[0]),
      i,
      s,
      a,
      r,
      this.serverType_
    );
  }
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(e) {
    return !this.hidpi_ || this.serverType_ === void 0 ? 1 : e;
  }
  /**
   * @private
   * @return {string} The key for the current params.
   */
  getKeyForParams_() {
    let e = 0;
    const t = [];
    for (const i in this.params_)
      t[e++] = i + "-" + this.params_[i];
    return t.join("/");
  }
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  updateParams(e) {
    Object.assign(this.params_, e), this.updateV13_(), this.setKey(this.getKeyForParams_());
  }
  /**
   * @private
   */
  updateV13_() {
    const e = this.params_.VERSION || ho;
    this.v13_ = ll(e, "1.3") >= 0;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
   * @param {number} pixelRatio The pixel ratio
   * @param {import("../proj/Projection.js").default} projection The projection
   * @return {string|undefined} The tile URL
   * @override
   */
  tileUrlFunction(e, t, i) {
    let s = this.getTileGrid();
    if (s || (s = this.getTileGridForProjection(i)), s.getResolutions().length <= e[0])
      return;
    t != 1 && (!this.hidpi_ || this.serverType_ === void 0) && (t = 1);
    const r = s.getResolution(e[0]);
    let o = s.getTileCoordExtent(e, this.tmpExtent_);
    const a = this.gutter_;
    a !== 0 && (o = ot(o, r * a, o));
    const l = Object.assign(
      {},
      co(this.params_, "GetMap")
    );
    return this.getRequestUrl_(
      e,
      o,
      t,
      i,
      l
    );
  }
}
const HC = ZC;
class qC extends ph {
  /**
   * @param {Options} options WMTS options.
   */
  constructor(e) {
    const t = e.requestEncoding !== void 0 ? e.requestEncoding : "KVP", i = e.tileGrid;
    let s = e.urls;
    s === void 0 && e.url !== void 0 && (s = pf(e.url)), super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      projection: e.projection,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileClass: e.tileClass,
      tileGrid: i,
      tileLoadFunction: e.tileLoadFunction,
      tilePixelRatio: e.tilePixelRatio,
      urls: s,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !1,
      transition: e.transition,
      zDirection: e.zDirection
    }), this.version_ = e.version !== void 0 ? e.version : "1.0.0", this.format_ = e.format !== void 0 ? e.format : "image/jpeg", this.dimensions_ = e.dimensions !== void 0 ? e.dimensions : {}, this.layer_ = e.layer, this.matrixSet_ = e.matrixSet, this.style_ = e.style, this.requestEncoding_ = t, this.setKey(this.getKeyForDimensions_()), s && s.length > 0 && (this.tileUrlFunction = Qa(
      s.map(this.createFromWMTSTemplate.bind(this))
    ));
  }
  /**
   * Set the URLs to use for requests.
   * URLs may contain OGC conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.
   * @param {Array<string>} urls URLs.
   */
  setUrls(e) {
    this.urls = e;
    const t = e.join(`
`);
    this.setTileUrlFunction(
      Qa(
        e.map(this.createFromWMTSTemplate.bind(this))
      ),
      t
    );
  }
  /**
   * Get the dimensions, i.e. those passed to the constructor through the
   * "dimensions" option, and possibly updated using the updateDimensions
   * method.
   * @return {!Object} Dimensions.
   * @api
   */
  getDimensions() {
    return this.dimensions_;
  }
  /**
   * Return the image format of the WMTS source.
   * @return {string} Format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * Return the layer of the WMTS source.
   * @return {string} Layer.
   * @api
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Return the matrix set of the WMTS source.
   * @return {string} MatrixSet.
   * @api
   */
  getMatrixSet() {
    return this.matrixSet_;
  }
  /**
   * Return the request encoding, either "KVP" or "REST".
   * @return {RequestEncoding} Request encoding.
   * @api
   */
  getRequestEncoding() {
    return this.requestEncoding_;
  }
  /**
   * Return the style of the WMTS source.
   * @return {string} Style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Return the version of the WMTS source.
   * @return {string} Version.
   * @api
   */
  getVersion() {
    return this.version_;
  }
  /**
   * @private
   * @return {string} The key for the current dimensions.
   */
  getKeyForDimensions_() {
    const e = this.urls ? this.urls.slice(0) : [];
    for (const t in this.dimensions_)
      e.push(t + "-" + this.dimensions_[t]);
    return e.join("/");
  }
  /**
   * Update the dimensions.
   * @param {Object} dimensions Dimensions.
   * @api
   */
  updateDimensions(e) {
    Object.assign(this.dimensions_, e), this.setKey(this.getKeyForDimensions_());
  }
  /**
   * @param {string} template Template.
   * @return {import("../Tile.js").UrlFunction} Tile URL function.
   */
  createFromWMTSTemplate(e) {
    const t = this.requestEncoding_, i = {
      layer: this.layer_,
      style: this.style_,
      tilematrixset: this.matrixSet_
    };
    t == "KVP" && Object.assign(i, {
      Service: "WMTS",
      Request: "GetTile",
      Version: this.version_,
      Format: this.format_
    }), e = t == "KVP" ? Xs(e, i) : e.replace(/\{(\w+?)\}/g, function(o, a) {
      return a.toLowerCase() in i ? i[a.toLowerCase()] : o;
    });
    const s = (
      /** @type {import("../tilegrid/WMTS.js").default} */
      this.tileGrid
    ), r = this.dimensions_;
    return (
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function(o, a, l) {
        if (!o)
          return;
        const h = {
          TileMatrix: s.getMatrixId(o[0]),
          TileCol: o[1],
          TileRow: o[2]
        };
        Object.assign(h, r);
        let c = e;
        return t == "KVP" ? c = Xs(c, h) : c = c.replace(/\{(\w+?)\}/g, function(u, d) {
          return h[d];
        }), c;
      }
    );
  }
}
const JC = qC, be = {
  ELEMENT: "element",
  MAP: "map",
  OFFSET: "offset",
  POSITION: "position",
  POSITIONING: "positioning"
};
class QC extends vt {
  /**
   * @param {Options} options Overlay options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, this.options = e, this.id = e.id, this.insertFirst = e.insertFirst !== void 0 ? e.insertFirst : !0, this.stopEvent = e.stopEvent !== void 0 ? e.stopEvent : !0, this.element = document.createElement("div"), this.element.className = e.className !== void 0 ? e.className : "ol-overlay-container " + im, this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.autoPan = e.autoPan === !0 ? {} : e.autoPan || void 0, this.rendered = {
      transform_: "",
      visible: !0
    }, this.mapPostrenderListenerKey = null, this.addChangeListener(be.ELEMENT, this.handleElementChanged), this.addChangeListener(be.MAP, this.handleMapChanged), this.addChangeListener(be.OFFSET, this.handleOffsetChanged), this.addChangeListener(be.POSITION, this.handlePositionChanged), this.addChangeListener(be.POSITIONING, this.handlePositioningChanged), e.element !== void 0 && this.setElement(e.element), this.setOffset(e.offset !== void 0 ? e.offset : [0, 0]), this.setPositioning(e.positioning || "top-left"), e.position !== void 0 && this.setPosition(e.position);
  }
  /**
   * Get the DOM element of this overlay.
   * @return {HTMLElement|undefined} The Element containing the overlay.
   * @observable
   * @api
   */
  getElement() {
    return (
      /** @type {HTMLElement|undefined} */
      this.get(be.ELEMENT)
    );
  }
  /**
   * Get the overlay identifier which is set on constructor.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id;
  }
  /**
   * Get the map associated with this overlay.
   * @return {import("./Map.js").default|null} The map that the
   * overlay is part of.
   * @observable
   * @api
   */
  getMap() {
    return (
      /** @type {import("./Map.js").default|null} */
      this.get(be.MAP) || null
    );
  }
  /**
   * Get the offset of this overlay.
   * @return {Array<number>} The offset.
   * @observable
   * @api
   */
  getOffset() {
    return (
      /** @type {Array<number>} */
      this.get(be.OFFSET)
    );
  }
  /**
   * Get the current position of this overlay.
   * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
   *     anchored at.
   * @observable
   * @api
   */
  getPosition() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(be.POSITION)
    );
  }
  /**
   * Get the current positioning of this overlay.
   * @return {Positioning} How the overlay is positioned
   *     relative to its point on the map.
   * @observable
   * @api
   */
  getPositioning() {
    return (
      /** @type {Positioning} */
      this.get(be.POSITIONING)
    );
  }
  /**
   * @protected
   */
  handleElementChanged() {
    Yu(this.element);
    const e = this.getElement();
    e && this.element.appendChild(e);
  }
  /**
   * @protected
   */
  handleMapChanged() {
    this.mapPostrenderListenerKey && (Yr(this.element), he(this.mapPostrenderListenerKey), this.mapPostrenderListenerKey = null);
    const e = this.getMap();
    if (e) {
      this.mapPostrenderListenerKey = Z(
        e,
        Pt.POSTRENDER,
        this.render,
        this
      ), this.updatePixelPosition();
      const t = this.stopEvent ? e.getOverlayContainerStopEvent() : e.getOverlayContainer();
      this.insertFirst ? t.insertBefore(this.element, t.childNodes[0] || null) : t.appendChild(this.element), this.performAutoPan();
    }
  }
  /**
   * @protected
   */
  render() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handleOffsetChanged() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handlePositionChanged() {
    this.updatePixelPosition(), this.performAutoPan();
  }
  /**
   * @protected
   */
  handlePositioningChanged() {
    this.updatePixelPosition();
  }
  /**
   * Set the DOM element to be associated with this overlay.
   * @param {HTMLElement|undefined} element The Element containing the overlay.
   * @observable
   * @api
   */
  setElement(e) {
    this.set(be.ELEMENT, e);
  }
  /**
   * Set the map to be associated with this overlay.
   * @param {import("./Map.js").default|null} map The map that the
   * overlay is part of. Pass `null` to just remove the overlay from the current map.
   * @observable
   * @api
   */
  setMap(e) {
    this.set(be.MAP, e);
  }
  /**
   * Set the offset for this overlay.
   * @param {Array<number>} offset Offset.
   * @observable
   * @api
   */
  setOffset(e) {
    this.set(be.OFFSET, e);
  }
  /**
   * Set the position for this overlay. If the position is `undefined` the
   * overlay is hidden.
   * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
   *     is anchored at.
   * @observable
   * @api
   */
  setPosition(e) {
    this.set(be.POSITION, e);
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary) using the configured autoPan parameters
   * @protected
   */
  performAutoPan() {
    this.autoPan && this.panIntoView(this.autoPan);
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary).
   * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action
   * @api
   */
  panIntoView(e) {
    const t = this.getMap();
    if (!t || !t.getTargetElement() || !this.get(be.POSITION))
      return;
    const i = this.getRect(t.getTargetElement(), t.getSize()), s = this.getElement(), r = this.getRect(s, [
      K_(s),
      Z_(s)
    ]);
    e = e || {};
    const o = e.margin === void 0 ? 20 : e.margin;
    if (!rt(i, r)) {
      const a = r[0] - i[0], l = i[2] - r[2], h = r[1] - i[1], c = i[3] - r[3], u = [0, 0];
      if (a < 0 ? u[0] = a - o : l < 0 && (u[0] = Math.abs(l) + o), h < 0 ? u[1] = h - o : c < 0 && (u[1] = Math.abs(c) + o), u[0] !== 0 || u[1] !== 0) {
        const d = (
          /** @type {import("./coordinate.js").Coordinate} */
          t.getView().getCenterInternal()
        ), f = t.getPixelFromCoordinateInternal(d);
        if (!f)
          return;
        const g = [f[0] + u[0], f[1] + u[1]], _ = e.animation || {};
        t.getView().animateInternal({
          center: t.getCoordinateFromPixelInternal(g),
          duration: _.duration,
          easing: _.easing
        });
      }
    }
  }
  /**
   * Get the extent of an element relative to the document
   * @param {HTMLElement} element The element.
   * @param {import("./size.js").Size} size The size of the element.
   * @return {import("./extent.js").Extent} The extent.
   * @protected
   */
  getRect(e, t) {
    const i = e.getBoundingClientRect(), s = i.left + window.pageXOffset, r = i.top + window.pageYOffset;
    return [s, r, s + t[0], r + t[1]];
  }
  /**
   * Set the positioning for this overlay.
   * @param {Positioning} positioning how the overlay is
   *     positioned relative to its point on the map.
   * @observable
   * @api
   */
  setPositioning(e) {
    this.set(be.POSITIONING, e);
  }
  /**
   * Modify the visibility of the element.
   * @param {boolean} visible Element visibility.
   * @protected
   */
  setVisible(e) {
    this.rendered.visible !== e && (this.element.style.display = e ? "" : "none", this.rendered.visible = e);
  }
  /**
   * Update pixel position.
   * @protected
   */
  updatePixelPosition() {
    const e = this.getMap(), t = this.getPosition();
    if (!e || !e.isRendered() || !t) {
      this.setVisible(!1);
      return;
    }
    const i = e.getPixelFromCoordinate(t), s = e.getSize();
    this.updateRenderedPosition(i, s);
  }
  /**
   * @param {import("./pixel.js").Pixel} pixel The pixel location.
   * @param {import("./size.js").Size|undefined} mapSize The map size.
   * @protected
   */
  updateRenderedPosition(e, t) {
    const i = this.element.style, s = this.getOffset(), r = this.getPositioning();
    this.setVisible(!0);
    const o = Math.round(e[0] + s[0]) + "px", a = Math.round(e[1] + s[1]) + "px";
    let l = "0%", h = "0%";
    r == "bottom-right" || r == "center-right" || r == "top-right" ? l = "-100%" : (r == "bottom-center" || r == "center-center" || r == "top-center") && (l = "-50%"), r == "bottom-left" || r == "bottom-center" || r == "bottom-right" ? h = "-100%" : (r == "center-left" || r == "center-center" || r == "center-right") && (h = "-50%");
    const c = `translate(${l}, ${h}) translate(${o}, ${a})`;
    this.rendered.transform_ != c && (this.rendered.transform_ = c, i.transform = c);
  }
  /**
   * returns the options this Overlay has been created with
   * @return {Options} overlay options
   */
  getOptions() {
    return this.options;
  }
}
const Sf = QC, zc = 0, Ps = 1, $c = [0, 0, 0, 0], On = [], ya = {
  /**
   * Triggered upon feature modification start
   * @event ModifyEvent#modifystart
   * @api
   */
  MODIFYSTART: "modifystart",
  /**
   * Triggered upon feature modification end
   * @event ModifyEvent#modifyend
   * @api
   */
  MODIFYEND: "modifyend"
};
class xa extends dt {
  /**
   * @param {ModifyEventType} type Type.
   * @param {Collection<Feature>} features
   * The features modified.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent
   * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   */
  constructor(e, t, i) {
    super(e), this.features = t, this.mapBrowserEvent = i;
  }
}
class ew extends on {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    super(
      /** @type {import("./Pointer.js").Options} */
      e
    ), this.on, this.once, this.un, this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this), this.condition_ = e.condition ? e.condition : md, this.defaultDeleteCondition_ = function(i) {
      return Sp(i) && Ip(i);
    }, this.deleteCondition_ = e.deleteCondition ? e.deleteCondition : this.defaultDeleteCondition_, this.insertVertexCondition_ = e.insertVertexCondition ? e.insertVertexCondition : qr, this.vertexFeature_ = null, this.vertexSegments_ = null, this.lastPixel_ = [0, 0], this.ignoreNextSingleClick_ = !1, this.featuresBeingModified_ = null, this.rBush_ = new Ha(), this.pixelTolerance_ = e.pixelTolerance !== void 0 ? e.pixelTolerance : 10, this.snappedToVertex_ = !1, this.changingFeature_ = !1, this.dragSegments_ = [], this.overlay_ = new ch({
      source: new dh({
        useSpatialIndex: !1,
        wrapX: !!e.wrapX
      }),
      style: e.style ? e.style : iw(),
      updateWhileAnimating: !0,
      updateWhileInteracting: !0
    }), this.SEGMENT_WRITERS_ = {
      Point: this.writePointGeometry_.bind(this),
      LineString: this.writeLineStringGeometry_.bind(this),
      LinearRing: this.writeLineStringGeometry_.bind(this),
      Polygon: this.writePolygonGeometry_.bind(this),
      MultiPoint: this.writeMultiPointGeometry_.bind(this),
      MultiLineString: this.writeMultiLineStringGeometry_.bind(this),
      MultiPolygon: this.writeMultiPolygonGeometry_.bind(this),
      Circle: this.writeCircleGeometry_.bind(this),
      GeometryCollection: this.writeGeometryCollectionGeometry_.bind(this)
    }, this.source_ = null, this.hitDetection_ = null;
    let t;
    if (e.features ? t = e.features : e.source && (this.source_ = e.source, t = new ze(this.source_.getFeatures()), this.source_.addEventListener(
      Ze.ADDFEATURE,
      this.handleSourceAdd_.bind(this)
    ), this.source_.addEventListener(
      Ze.REMOVEFEATURE,
      this.handleSourceRemove_.bind(this)
    )), !t)
      throw new Error(
        "The modify interaction requires features, a source or a layer"
      );
    e.hitDetection && (this.hitDetection_ = e.hitDetection), this.features_ = t, this.features_.forEach(this.addFeature_.bind(this)), this.features_.addEventListener(
      Fe.ADD,
      this.handleFeatureAdd_.bind(this)
    ), this.features_.addEventListener(
      Fe.REMOVE,
      this.handleFeatureRemove_.bind(this)
    ), this.lastPointerEvent_ = null, this.delta_ = [0, 0], this.snapToPointer_ = e.snapToPointer === void 0 ? !this.hitDetection_ : e.snapToPointer;
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  addFeature_(e) {
    const t = e.getGeometry();
    if (t) {
      const s = this.SEGMENT_WRITERS_[t.getType()];
      s && s(e, t);
    }
    const i = this.getMap();
    i && i.isRendered() && this.getActive() && this.handlePointerAtPixel_(this.lastPixel_, i), e.addEventListener(G.CHANGE, this.boundHandleFeatureChange_);
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
   * @param {Array<Array<SegmentData>>} segments The segments subject to modification.
   * @private
   */
  willModifyFeatures_(e, t) {
    if (!this.featuresBeingModified_) {
      this.featuresBeingModified_ = new ze();
      const i = this.featuresBeingModified_.getArray();
      for (let s = 0, r = t.length; s < r; ++s) {
        const o = t[s];
        for (let a = 0, l = o.length; a < l; ++a) {
          const h = o[a].feature;
          h && !i.includes(h) && this.featuresBeingModified_.push(h);
        }
      }
      this.featuresBeingModified_.getLength() === 0 ? this.featuresBeingModified_ = null : this.dispatchEvent(
        new xa(
          ya.MODIFYSTART,
          this.featuresBeingModified_,
          e
        )
      );
    }
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  removeFeature_(e) {
    this.removeFeatureSegmentData_(e), this.vertexFeature_ && this.features_.getLength() === 0 && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), e.removeEventListener(
      G.CHANGE,
      this.boundHandleFeatureChange_
    );
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  removeFeatureSegmentData_(e) {
    const t = this.rBush_, i = [];
    t.forEach(
      /**
       * @param {SegmentData} node RTree node.
       */
      function(s) {
        e === s.feature && i.push(s);
      }
    );
    for (let s = i.length - 1; s >= 0; --s) {
      const r = i[s];
      for (let o = this.dragSegments_.length - 1; o >= 0; --o)
        this.dragSegments_[o][0] === r && this.dragSegments_.splice(o, 1);
      t.remove(r);
    }
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(e) {
    this.vertexFeature_ && !e && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), super.setActive(e);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(e) {
    this.overlay_.setMap(e), super.setMap(e);
  }
  /**
   * Get the overlay layer that this interaction renders the modification point or vertex to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  getOverlay() {
    return this.overlay_;
  }
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceAdd_(e) {
    e.feature && this.features_.push(e.feature);
  }
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceRemove_(e) {
    e.feature && this.features_.remove(e.feature);
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  handleFeatureAdd_(e) {
    this.addFeature_(e.element);
  }
  /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */
  handleFeatureChange_(e) {
    if (!this.changingFeature_) {
      const t = (
        /** @type {Feature} */
        e.target
      );
      this.removeFeature_(t), this.addFeature_(t);
    }
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  handleFeatureRemove_(e) {
    this.removeFeature_(e.element);
  }
  /**
   * @param {Feature} feature Feature
   * @param {Point} geometry Geometry.
   * @private
   */
  writePointGeometry_(e, t) {
    const i = t.getCoordinates(), s = {
      feature: e,
      geometry: t,
      segment: [i, i]
    };
    this.rBush_.insert(t.getExtent(), s);
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */
  writeMultiPointGeometry_(e, t) {
    const i = t.getCoordinates();
    for (let s = 0, r = i.length; s < r; ++s) {
      const o = i[s], a = {
        feature: e,
        geometry: t,
        depth: [s],
        index: s,
        segment: [o, o]
      };
      this.rBush_.insert(t.getExtent(), a);
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */
  writeLineStringGeometry_(e, t) {
    const i = t.getCoordinates();
    for (let s = 0, r = i.length - 1; s < r; ++s) {
      const o = i.slice(s, s + 2), a = {
        feature: e,
        geometry: t,
        index: s,
        segment: o
      };
      this.rBush_.insert(je(o), a);
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */
  writeMultiLineStringGeometry_(e, t) {
    const i = t.getCoordinates();
    for (let s = 0, r = i.length; s < r; ++s) {
      const o = i[s];
      for (let a = 0, l = o.length - 1; a < l; ++a) {
        const h = o.slice(a, a + 2), c = {
          feature: e,
          geometry: t,
          depth: [s],
          index: a,
          segment: h
        };
        this.rBush_.insert(je(h), c);
      }
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */
  writePolygonGeometry_(e, t) {
    const i = t.getCoordinates();
    for (let s = 0, r = i.length; s < r; ++s) {
      const o = i[s];
      for (let a = 0, l = o.length - 1; a < l; ++a) {
        const h = o.slice(a, a + 2), c = {
          feature: e,
          geometry: t,
          depth: [s],
          index: a,
          segment: h
        };
        this.rBush_.insert(je(h), c);
      }
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */
  writeMultiPolygonGeometry_(e, t) {
    const i = t.getCoordinates();
    for (let s = 0, r = i.length; s < r; ++s) {
      const o = i[s];
      for (let a = 0, l = o.length; a < l; ++a) {
        const h = o[a];
        for (let c = 0, u = h.length - 1; c < u; ++c) {
          const d = h.slice(c, c + 2), f = {
            feature: e,
            geometry: t,
            depth: [a, s],
            index: c,
            segment: d
          };
          this.rBush_.insert(je(d), f);
        }
      }
    }
  }
  /**
   * We convert a circle into two segments.  The segment at index
   * {@link CIRCLE_CENTER_INDEX} is the
   * circle's center (a point).  The segment at index
   * {@link CIRCLE_CIRCUMFERENCE_INDEX} is
   * the circumference, and is not a line segment.
   *
   * @param {Feature} feature Feature.
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */
  writeCircleGeometry_(e, t) {
    const i = t.getCenter(), s = {
      feature: e,
      geometry: t,
      index: zc,
      segment: [i, i]
    }, r = {
      feature: e,
      geometry: t,
      index: Ps,
      segment: [i, i]
    }, o = [s, r];
    s.featureSegments = o, r.featureSegments = o, this.rBush_.insert(Cs(i), s);
    let a = (
      /** @type {import("../geom/Geometry.js").default} */
      t
    );
    this.rBush_.insert(a.getExtent(), r);
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */
  writeGeometryCollectionGeometry_(e, t) {
    const i = t.getGeometriesArray();
    for (let s = 0; s < i.length; ++s) {
      const r = i[s], o = this.SEGMENT_WRITERS_[r.getType()];
      o(e, r);
    }
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {Array<Feature>} features The features being modified.
   * @param {Array<import("../geom/SimpleGeometry.js").default>} geometries The geometries being modified.
   * @return {Feature} Vertex feature.
   * @private
   */
  createOrUpdateVertexFeature_(e, t, i) {
    let s = this.vertexFeature_;
    return s ? s.getGeometry().setCoordinates(e) : (s = new yt(new lt(e)), this.vertexFeature_ = s, this.overlay_.getSource().addFeature(s)), s.set("features", t), s.set("geometries", i), s;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may modify the geometry.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    if (!e.originalEvent)
      return !0;
    this.lastPointerEvent_ = e;
    let t;
    return !e.map.getView().getInteracting() && e.type == J.POINTERMOVE && !this.handlingDownUpSequence && this.handlePointerMove_(e), this.vertexFeature_ && this.deleteCondition_(e) && (e.type != J.SINGLECLICK || !this.ignoreNextSingleClick_ ? t = this.removePoint() : t = !0), e.type == J.SINGLECLICK && (this.ignoreNextSingleClick_ = !1), super.handleEvent(e) && !t;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   */
  handleDragEvent(e) {
    this.ignoreNextSingleClick_ = !1, this.willModifyFeatures_(e, this.dragSegments_);
    const t = [
      e.coordinate[0] + this.delta_[0],
      e.coordinate[1] + this.delta_[1]
    ], i = [], s = [];
    for (let r = 0, o = this.dragSegments_.length; r < o; ++r) {
      const a = this.dragSegments_[r], l = a[0], h = l.feature;
      i.includes(h) || i.push(h);
      const c = l.geometry;
      s.includes(c) || s.push(c);
      const u = l.depth;
      let d;
      const f = l.segment, g = a[1];
      for (; t.length < c.getStride(); )
        t.push(f[g][t.length]);
      switch (c.getType()) {
        case "Point":
          d = t, f[0] = t, f[1] = t;
          break;
        case "MultiPoint":
          d = c.getCoordinates(), d[l.index] = t, f[0] = t, f[1] = t;
          break;
        case "LineString":
          d = c.getCoordinates(), d[l.index + g] = t, f[g] = t;
          break;
        case "MultiLineString":
          d = c.getCoordinates(), d[u[0]][l.index + g] = t, f[g] = t;
          break;
        case "Polygon":
          d = c.getCoordinates(), d[u[0]][l.index + g] = t, f[g] = t;
          break;
        case "MultiPolygon":
          d = c.getCoordinates(), d[u[1]][u[0]][l.index + g] = t, f[g] = t;
          break;
        case "Circle":
          if (f[0] = t, f[1] = t, l.index === zc)
            this.changingFeature_ = !0, c.setCenter(t), this.changingFeature_ = !1;
          else {
            this.changingFeature_ = !0, e.map.getView().getProjection();
            let _ = Gr(
              pe(c.getCenter()),
              pe(t)
            );
            c.setRadius(_), this.changingFeature_ = !1;
          }
          break;
      }
      d && this.setGeometryCoordinates_(c, d);
    }
    this.createOrUpdateVertexFeature_(t, i, s);
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (!this.condition_(e))
      return !1;
    const t = e.coordinate;
    this.handlePointerAtPixel_(e.pixel, e.map, t), this.dragSegments_.length = 0, this.featuresBeingModified_ = null;
    const i = this.vertexFeature_;
    if (i) {
      e.map.getView().getProjection();
      const s = [], r = i.getGeometry().getCoordinates(), o = je([r]), a = this.rBush_.getInExtent(o), l = {};
      a.sort(tw);
      for (let h = 0, c = a.length; h < c; ++h) {
        const u = a[h], d = u.segment;
        let f = j(u.geometry);
        const g = u.depth;
        if (g && (f += "-" + g.join("-")), l[f] || (l[f] = new Array(2)), u.geometry.getType() === "Circle" && u.index === Ps) {
          const _ = Vc(
            t,
            u
          );
          nt(_, r) && !l[f][0] && (this.dragSegments_.push([u, 0]), l[f][0] = u);
          continue;
        }
        if (nt(d[0], r) && !l[f][0]) {
          this.dragSegments_.push([u, 0]), l[f][0] = u;
          continue;
        }
        if (nt(d[1], r) && !l[f][1]) {
          if (l[f][0] && l[f][0].index === 0) {
            let _ = u.geometry.getCoordinates();
            switch (u.geometry.getType()) {
              case "LineString":
              case "MultiLineString":
                continue;
              case "MultiPolygon":
                _ = _[g[1]];
              case "Polygon":
                if (u.index !== _[g[0]].length - 2)
                  continue;
                break;
            }
          }
          this.dragSegments_.push([u, 1]), l[f][1] = u;
          continue;
        }
        j(d) in this.vertexSegments_ && !l[f][0] && !l[f][1] && this.insertVertexCondition_(e) && s.push(u);
      }
      s.length && this.willModifyFeatures_(e, [s]);
      for (let h = s.length - 1; h >= 0; --h)
        this.insertVertex_(s[h], r);
    }
    return !!this.vertexFeature_;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    for (let t = this.dragSegments_.length - 1; t >= 0; --t) {
      const i = this.dragSegments_[t][0], s = i.geometry;
      if (s.getType() === "Circle") {
        const r = s.getCenter(), o = i.featureSegments[0], a = i.featureSegments[1];
        o.segment[0] = r, o.segment[1] = r, a.segment[0] = r, a.segment[1] = r, this.rBush_.update(Cs(r), o);
        let l = s;
        this.rBush_.update(
          l.getExtent(),
          a
        );
      } else
        this.rBush_.update(je(i.segment), i);
    }
    return this.featuresBeingModified_ && (this.dispatchEvent(
      new xa(
        ya.MODIFYEND,
        this.featuresBeingModified_,
        e
      )
    ), this.featuresBeingModified_ = null), !1;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @private
   */
  handlePointerMove_(e) {
    this.lastPixel_ = e.pixel, this.handlePointerAtPixel_(e.pixel, e.map, e.coordinate);
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../Map.js").default} map Map.
   * @param {import("../coordinate.js").Coordinate} [coordinate] The pixel Coordinate.
   * @private
   */
  handlePointerAtPixel_(e, t, i) {
    const s = i || t.getCoordinateFromPixel(e);
    t.getView().getProjection();
    const r = function(l, h) {
      return Uc(s, l) - Uc(s, h);
    };
    let o, a;
    if (this.hitDetection_) {
      const l = typeof this.hitDetection_ == "object" ? (h) => h === this.hitDetection_ : void 0;
      t.forEachFeatureAtPixel(
        e,
        (h, c, u) => {
          u && u.getType() === "Point" && (u = new lt(
            Vn(u.getCoordinates())
          ));
          const d = u || h.getGeometry();
          if (h instanceof yt && this.features_.getArray().includes(h)) {
            a = /** @type {Point} */
            d;
            const f = (
              /** @type {Point} */
              h.getGeometry().getFlatCoordinates().slice(0, 2)
            );
            o = [
              {
                feature: h,
                geometry: a,
                segment: [f, f]
              }
            ];
          }
          return !0;
        },
        { layerFilter: l }
      );
    }
    if (!o) {
      const l = Et(
        Cs(s, $c)
      ), h = t.getView().getResolution() * this.pixelTolerance_, c = yo(
        ot(l, h, $c)
      );
      o = this.rBush_.getInExtent(c);
    }
    if (o && o.length > 0) {
      const l = o.sort(r)[0], h = l.segment;
      let c = Vc(s, l);
      const u = t.getPixelFromCoordinate(c);
      let d = Gr(e, u);
      if (a || d <= this.pixelTolerance_) {
        const f = {};
        if (f[j(h)] = !0, this.snapToPointer_ || (this.delta_[0] = c[0] - s[0], this.delta_[1] = c[1] - s[1]), l.geometry.getType() === "Circle" && l.index === Ps)
          this.snappedToVertex_ = !0, this.createOrUpdateVertexFeature_(
            c,
            [l.feature],
            [l.geometry]
          );
        else {
          const g = t.getPixelFromCoordinate(h[0]), _ = t.getPixelFromCoordinate(h[1]), m = Un(u, g), p = Un(u, _);
          d = Math.sqrt(Math.min(m, p)), this.snappedToVertex_ = d <= this.pixelTolerance_, this.snappedToVertex_ && (c = m > p ? h[1] : h[0]), this.createOrUpdateVertexFeature_(
            c,
            [l.feature],
            [l.geometry]
          );
          const y = {};
          y[j(l.geometry)] = !0;
          for (let x = 1, E = o.length; x < E; ++x) {
            const C = o[x].segment;
            if (nt(h[0], C[0]) && nt(h[1], C[1]) || nt(h[0], C[1]) && nt(h[1], C[0])) {
              const w = j(o[x].geometry);
              w in y || (y[w] = !0, f[j(C)] = !0);
            } else
              break;
          }
        }
        this.vertexSegments_ = f;
        return;
      }
    }
    this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null);
  }
  /**
   * @param {SegmentData} segmentData Segment data.
   * @param {import("../coordinate.js").Coordinate} vertex Vertex.
   * @private
   */
  insertVertex_(e, t) {
    const i = e.segment, s = e.feature, r = e.geometry, o = e.depth, a = e.index;
    let l;
    for (; t.length < r.getStride(); )
      t.push(0);
    switch (r.getType()) {
      case "MultiLineString":
        l = r.getCoordinates(), l[o[0]].splice(a + 1, 0, t);
        break;
      case "Polygon":
        l = r.getCoordinates(), l[o[0]].splice(a + 1, 0, t);
        break;
      case "MultiPolygon":
        l = r.getCoordinates(), l[o[1]][o[0]].splice(a + 1, 0, t);
        break;
      case "LineString":
        l = r.getCoordinates(), l.splice(a + 1, 0, t);
        break;
      default:
        return;
    }
    this.setGeometryCoordinates_(r, l);
    const h = this.rBush_;
    h.remove(e), this.updateSegmentIndices_(r, a, o, 1);
    const c = {
      segment: [i[0], t],
      feature: s,
      geometry: r,
      depth: o,
      index: a
    };
    h.insert(je(c.segment), c), this.dragSegments_.push([c, 1]);
    const u = {
      segment: [t, i[1]],
      feature: s,
      geometry: r,
      depth: o,
      index: a + 1
    };
    h.insert(je(u.segment), u), this.dragSegments_.push([u, 0]), this.ignoreNextSingleClick_ = !0;
  }
  /**
   * Removes the vertex currently being pointed.
   * @return {boolean} True when a vertex was removed.
   * @api
   */
  removePoint() {
    if (this.lastPointerEvent_ && this.lastPointerEvent_.type != J.POINTERDRAG) {
      const e = this.lastPointerEvent_;
      this.willModifyFeatures_(e, this.dragSegments_);
      const t = this.removeVertex_();
      return this.featuresBeingModified_ && this.dispatchEvent(
        new xa(
          ya.MODIFYEND,
          this.featuresBeingModified_,
          e
        )
      ), this.featuresBeingModified_ = null, t;
    }
    return !1;
  }
  /**
   * Removes a vertex from all matching features.
   * @return {boolean} True when a vertex was removed.
   * @private
   */
  removeVertex_() {
    const e = this.dragSegments_, t = {};
    let i = !1, s, r, o, a, l, h, c, u, d, f, g;
    for (l = e.length - 1; l >= 0; --l)
      o = e[l], f = o[0], g = j(f.feature), f.depth && (g += "-" + f.depth.join("-")), g in t || (t[g] = {}), o[1] === 0 ? (t[g].right = f, t[g].index = f.index) : o[1] == 1 && (t[g].left = f, t[g].index = f.index + 1);
    for (g in t) {
      switch (d = t[g].right, c = t[g].left, h = t[g].index, u = h - 1, c !== void 0 ? f = c : f = d, u < 0 && (u = 0), a = f.geometry, r = a.getCoordinates(), s = r, i = !1, a.getType()) {
        case "MultiLineString":
          r[f.depth[0]].length > 2 && (r[f.depth[0]].splice(h, 1), i = !0);
          break;
        case "LineString":
          r.length > 2 && (r.splice(h, 1), i = !0);
          break;
        case "MultiPolygon":
          s = s[f.depth[1]];
        case "Polygon":
          s = s[f.depth[0]], s.length > 4 && (h == s.length - 1 && (h = 0), s.splice(h, 1), i = !0, h === 0 && (s.pop(), s.push(s[0]), u = s.length - 1));
          break;
      }
      if (i) {
        this.setGeometryCoordinates_(a, r);
        const _ = [];
        if (c !== void 0 && (this.rBush_.remove(c), _.push(c.segment[0])), d !== void 0 && (this.rBush_.remove(d), _.push(d.segment[1])), c !== void 0 && d !== void 0) {
          const m = {
            depth: f.depth,
            feature: f.feature,
            geometry: f.geometry,
            index: u,
            segment: _
          };
          this.rBush_.insert(
            je(m.segment),
            m
          );
        }
        this.updateSegmentIndices_(a, h, f.depth, -1), this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), e.length = 0;
      }
    }
    return i;
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {Array} coordinates Coordinates.
   * @private
   */
  setGeometryCoordinates_(e, t) {
    this.changingFeature_ = !0, e.setCoordinates(t), this.changingFeature_ = !1;
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {number} index Index.
   * @param {Array<number>|undefined} depth Depth.
   * @param {number} delta Delta (1 or -1).
   * @private
   */
  updateSegmentIndices_(e, t, i, s) {
    this.rBush_.forEachInExtent(
      e.getExtent(),
      function(r) {
        r.geometry === e && (i === void 0 || r.depth === void 0 || ri(r.depth, i)) && r.index > t && (r.index += s);
      }
    );
  }
}
function tw(n, e) {
  return n.index - e.index;
}
function Uc(n, e, t) {
  const i = e.geometry;
  if (i.getType() === "Circle") {
    let r = (
      /** @type {import("../geom/Circle.js").default} */
      i
    );
    if (e.index === Ps) {
      const o = Un(
        r.getCenter(),
        pe(n)
      ), a = Math.sqrt(o) - r.getRadius();
      return a * a;
    }
  }
  const s = pe(n);
  return On[0] = pe(e.segment[0]), On[1] = pe(e.segment[1]), Ug(s, On);
}
function Vc(n, e, t) {
  const i = e.geometry;
  if (i.getType() === "Circle" && e.index === Ps)
    return Vn(
      /** @type {import("../geom/Circle.js").default} */
      i.getClosestPoint(
        pe(n)
      )
    );
  const s = pe(n);
  return On[0] = pe(e.segment[0]), On[1] = pe(e.segment[1]), Vn(
    gu(s, On)
  );
}
function iw() {
  const n = Ju();
  return function(e, t) {
    return n.Point;
  };
}
const nw = ew, Rr = {
  /**
   * Triggered upon feature draw start
   * @event DrawEvent#drawstart
   * @api
   */
  DRAWSTART: "drawstart",
  /**
   * Triggered upon feature draw end
   * @event DrawEvent#drawend
   * @api
   */
  DRAWEND: "drawend",
  /**
   * Triggered upon feature draw abortion
   * @event DrawEvent#drawabort
   * @api
   */
  DRAWABORT: "drawabort"
};
class Ir extends dt {
  /**
   * @param {DrawEventType} type Type.
   * @param {Feature} feature The feature drawn.
   */
  constructor(e, t) {
    super(e), this.feature = t;
  }
}
function sw(n, e) {
  const t = [];
  for (let i = 0; i < e.length; ++i) {
    const r = e[i].getGeometry();
    vf(n, r, t);
  }
  return t;
}
function Pr(n, e) {
  return Ht(n[0], n[1], e[0], e[1]);
}
function Rn(n, e) {
  const t = n.length;
  return e < 0 ? n[e + t] : e >= t ? n[e - t] : n[e];
}
function Lr(n, e, t) {
  let i, s;
  e < t ? (i = e, s = t) : (i = t, s = e);
  const r = Math.ceil(i), o = Math.floor(s);
  if (r > o) {
    const l = In(n, i), h = In(n, s);
    return Pr(l, h);
  }
  let a = 0;
  if (i < r) {
    const l = In(n, i), h = Rn(n, r);
    a += Pr(l, h);
  }
  if (o < s) {
    const l = Rn(n, o), h = In(n, s);
    a += Pr(l, h);
  }
  for (let l = r; l < o - 1; ++l) {
    const h = Rn(n, l), c = Rn(n, l + 1);
    a += Pr(h, c);
  }
  return a;
}
function vf(n, e, t) {
  if (e instanceof ht) {
    br(n, e.getCoordinates(), !1, t);
    return;
  }
  if (e instanceof an) {
    const i = e.getCoordinates();
    for (let s = 0, r = i.length; s < r; ++s)
      br(n, i[s], !1, t);
    return;
  }
  if (e instanceof Ne) {
    const i = e.getCoordinates();
    for (let s = 0, r = i.length; s < r; ++s)
      br(n, i[s], !0, t);
    return;
  }
  if (e instanceof is) {
    const i = e.getCoordinates();
    for (let s = 0, r = i.length; s < r; ++s) {
      const o = i[s];
      for (let a = 0, l = o.length; a < l; ++a)
        br(n, o[a], !0, t);
    }
    return;
  }
  if (e instanceof ei) {
    const i = e.getGeometries();
    for (let s = 0; s < i.length; ++s)
      vf(n, i[s], t);
    return;
  }
}
const Ea = { index: -1, endIndex: NaN };
function rw(n, e, t, i) {
  const s = n[0], r = n[1];
  let o = 1 / 0, a = -1, l = NaN;
  for (let u = 0; u < e.targets.length; ++u) {
    const d = e.targets[u], f = d.coordinates;
    let g = 1 / 0, _;
    for (let m = 0; m < f.length - 1; ++m) {
      const p = f[m], y = f[m + 1], x = Tf(s, r, p, y);
      x.squaredDistance < g && (g = x.squaredDistance, _ = m + x.along);
    }
    g < o && (o = g, d.ring && e.targetIndex === u && (d.endIndex > d.startIndex ? _ < d.startIndex && (_ += f.length) : d.endIndex < d.startIndex && _ > d.startIndex && (_ -= f.length)), l = _, a = u);
  }
  const h = e.targets[a];
  let c = h.ring;
  if (e.targetIndex === a && c) {
    const u = In(
      h.coordinates,
      l
    ), d = t.getPixelFromCoordinate(u);
    Gr(d, e.startPx) > i && (c = !1);
  }
  if (c) {
    const u = h.coordinates, d = u.length, f = h.startIndex, g = l;
    if (f < g) {
      const _ = Lr(
        u,
        f,
        g
      );
      Lr(
        u,
        f,
        g - d
      ) < _ && (l -= d);
    } else {
      const _ = Lr(
        u,
        f,
        g
      );
      Lr(
        u,
        f,
        g + d
      ) < _ && (l += d);
    }
  }
  return Ea.index = a, Ea.endIndex = l, Ea;
}
function br(n, e, t, i) {
  const s = n[0], r = n[1];
  for (let o = 0, a = e.length - 1; o < a; ++o) {
    const l = e[o], h = e[o + 1], c = Tf(s, r, l, h);
    if (c.squaredDistance === 0) {
      const u = o + c.along;
      i.push({
        coordinates: e,
        ring: t,
        startIndex: u,
        endIndex: u
      });
      return;
    }
  }
}
const Ca = { along: 0, squaredDistance: 0 };
function Tf(n, e, t, i) {
  const s = t[0], r = t[1], o = i[0], a = i[1], l = o - s, h = a - r;
  let c = 0, u = s, d = r;
  return (l !== 0 || h !== 0) && (c = _e(((n - s) * l + (e - r) * h) / (l * l + h * h), 0, 1), u += l * c, d += h * c), Ca.along = c, Ca.squaredDistance = Zs(Ht(n, e, u, d), 10), Ca;
}
function In(n, e) {
  const t = n.length;
  let i = Math.floor(e);
  const s = e - i;
  i >= t ? i -= t : i < 0 && (i += t);
  let r = i + 1;
  r >= t && (r -= t);
  const o = n[i], a = o[0], l = o[1], h = n[r], c = h[0] - a, u = h[1] - l;
  return [a + c * s, l + u * s];
}
class ow extends on {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    const t = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    t.stopDown || (t.stopDown = Hn), super(t), this.on, this.once, this.un, this.shouldHandle_ = !1, this.downPx_ = null, this.downTimeout_, this.lastDragTime_, this.pointerType_, this.freehand_ = !1, this.source_ = e.source ? e.source : null, this.features_ = e.features ? e.features : null, this.snapTolerance_ = e.snapTolerance ? e.snapTolerance : 12, this.type_ = /** @type {import("../geom/Geometry.js").Type} */
    e.type, this.mode_ = hw(this.type_), this.stopClick_ = !!e.stopClick, this.minPoints_ = e.minPoints ? e.minPoints : this.mode_ === "Polygon" ? 3 : 2, this.maxPoints_ = this.mode_ === "Circle" ? 2 : e.maxPoints ? e.maxPoints : 1 / 0, this.finishCondition_ = e.finishCondition ? e.finishCondition : kn, this.geometryLayout_ = e.geometryLayout ? e.geometryLayout : "XY";
    let i = e.geometryFunction;
    if (!i) {
      const s = this.mode_;
      if (s === "Circle")
        i = function(r, o, a) {
          const l = o || new ey([NaN, NaN]), h = pe(r[0]), c = Un(
            h,
            pe(r[r.length - 1])
          );
          return l.setCenterAndRadius(
            h,
            Math.sqrt(c),
            this.geometryLayout_
          ), l;
        };
      else {
        let r;
        s === "Point" ? r = lt : s === "LineString" ? r = ht : s === "Polygon" && (r = Ne), i = function(o, a, l) {
          return a ? s === "Polygon" ? o[0].length ? a.setCoordinates(
            [o[0].concat([o[0][0]])],
            this.geometryLayout_
          ) : a.setCoordinates([], this.geometryLayout_) : a.setCoordinates(o, this.geometryLayout_) : a = new r(o, this.geometryLayout_), a;
        };
      }
    }
    this.geometryFunction_ = i, this.dragVertexDelay_ = e.dragVertexDelay !== void 0 ? e.dragVertexDelay : 500, this.finishCoordinate_ = null, this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchCoords_ = null, this.sketchLine_ = null, this.sketchLineCoords_ = null, this.squaredClickTolerance_ = e.clickTolerance ? e.clickTolerance * e.clickTolerance : 36, this.overlay_ = new ch({
      source: new dh({
        useSpatialIndex: !1,
        wrapX: e.wrapX ? e.wrapX : !1
      }),
      style: e.style ? e.style : aw(),
      updateWhileInteracting: !0
    }), this.geometryName_ = e.geometryName, this.condition_ = e.condition ? e.condition : Hl, this.freehandCondition_, e.freehand ? this.freehandCondition_ = qr : this.freehandCondition_ = e.freehandCondition ? e.freehandCondition : gd, this.traceCondition_, this.setTrace(e.trace || !1), this.traceState_ = { active: !1 }, this.traceSource_ = e.traceSource || e.source || null, this.addChangeListener(za.ACTIVE, this.updateState_);
  }
  /**
   * Toggle tracing mode or set a tracing condition.
   *
   * @param {boolean|import("../events/condition.js").Condition} trace A boolean to toggle tracing mode or an event
   *     condition that will be checked when a feature is clicked to determine if tracing should be active.
   */
  setTrace(e) {
    let t;
    e ? e === !0 ? t = qr : t = e : t = Rp, this.traceCondition_ = t;
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(e) {
    super.setMap(e), this.updateState_();
  }
  /**
   * Get the overlay layer that this interaction renders sketch features to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  getOverlay() {
    return this.overlay_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.
   * @param {import("../MapBrowserEvent.js").default} event Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(e) {
    e.originalEvent.type === G.CONTEXTMENU && e.originalEvent.preventDefault(), this.freehand_ = this.mode_ !== "Point" && this.freehandCondition_(e);
    let t = e.type === J.POINTERMOVE, i = !0;
    return !this.freehand_ && this.lastDragTime_ && e.type === J.POINTERDRAG && (Date.now() - this.lastDragTime_ >= this.dragVertexDelay_ ? (this.downPx_ = e.pixel, this.shouldHandle_ = !this.freehand_, t = !0) : this.lastDragTime_ = void 0, this.shouldHandle_ && this.downTimeout_ !== void 0 && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0)), this.freehand_ && e.type === J.POINTERDRAG && this.sketchFeature_ !== null ? (this.addToDrawing_(e.coordinate), i = !1) : this.freehand_ && e.type === J.POINTERDOWN ? i = !1 : t && this.getPointerCount() < 2 ? (i = e.type === J.POINTERMOVE, i && this.freehand_ ? (this.handlePointerMove_(e), this.shouldHandle_ && e.originalEvent.preventDefault()) : (e.originalEvent.pointerType === "mouse" || e.type === J.POINTERDRAG && this.downTimeout_ === void 0) && this.handlePointerMove_(e)) : e.type === J.DBLCLICK && (i = !1), super.handleEvent(e) && i;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    return this.shouldHandle_ = !this.freehand_, this.freehand_ ? (this.downPx_ = e.pixel, this.finishCoordinate_ || this.startDrawing_(e.coordinate), !0) : this.condition_(e) ? (this.lastDragTime_ = Date.now(), this.downTimeout_ = setTimeout(() => {
      this.handlePointerMove_(
        new Wt(
          J.POINTERMOVE,
          e.map,
          e.originalEvent,
          !1,
          e.frameState
        )
      );
    }, this.dragVertexDelay_), this.downPx_ = e.pixel, !0) : (this.lastDragTime_ = void 0, !1);
  }
  /**
   * @private
   */
  deactivateTrace_() {
    this.traceState_ = { active: !1 };
  }
  /**
   * Activate or deactivate trace state based on a browser event.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  toggleTraceState_(e) {
    if (!this.traceSource_ || !this.traceCondition_(e))
      return;
    if (this.traceState_.active) {
      this.deactivateTrace_();
      return;
    }
    const t = this.getMap(), i = t.getCoordinateFromPixel([
      e.pixel[0] - this.snapTolerance_,
      e.pixel[1] + this.snapTolerance_
    ]), s = t.getCoordinateFromPixel([
      e.pixel[0] + this.snapTolerance_,
      e.pixel[1] - this.snapTolerance_
    ]), r = je([i, s]), o = this.traceSource_.getFeaturesInExtent(r);
    if (o.length === 0)
      return;
    const a = sw(e.coordinate, o);
    a.length && (this.traceState_ = {
      active: !0,
      startPx: e.pixel.slice(),
      targets: a,
      targetIndex: -1
    });
  }
  /**
   * @param {TraceTarget} target The trace target.
   * @param {number} endIndex The new end index of the trace.
   * @private
   */
  addOrRemoveTracedCoordinates_(e, t) {
    const i = e.startIndex <= e.endIndex, s = e.startIndex <= t;
    i === s ? i && t > e.endIndex || !i && t < e.endIndex ? this.addTracedCoordinates_(e, e.endIndex, t) : (i && t < e.endIndex || !i && t > e.endIndex) && this.removeTracedCoordinates_(t, e.endIndex) : (this.removeTracedCoordinates_(e.startIndex, e.endIndex), this.addTracedCoordinates_(e, e.startIndex, t));
  }
  /**
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */
  removeTracedCoordinates_(e, t) {
    if (e === t)
      return;
    let i = 0;
    if (e < t) {
      const s = Math.ceil(e);
      let r = Math.floor(t);
      r === t && (r -= 1), i = r - s + 1;
    } else {
      const s = Math.floor(e);
      let r = Math.ceil(t);
      r === t && (r += 1), i = s - r + 1;
    }
    i > 0 && this.removeLastPoints_(i);
  }
  /**
   * @param {TraceTarget} target The trace target.
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */
  addTracedCoordinates_(e, t, i) {
    if (t === i)
      return;
    const s = [];
    if (t < i) {
      const r = Math.ceil(t);
      let o = Math.floor(i);
      o === i && (o -= 1);
      for (let a = r; a <= o; ++a)
        s.push(Rn(e.coordinates, a));
    } else {
      const r = Math.floor(t);
      let o = Math.ceil(i);
      o === i && (o += 1);
      for (let a = r; a >= o; --a)
        s.push(Rn(e.coordinates, a));
    }
    s.length && this.appendCoordinates(s);
  }
  /**
   * Update the trace.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  updateTrace_(e) {
    const t = this.traceState_;
    if (!t.active || t.targetIndex === -1 && Gr(t.startPx, e.pixel) < this.snapTolerance_)
      return;
    const i = rw(
      e.coordinate,
      t,
      this.getMap(),
      this.snapTolerance_
    );
    if (t.targetIndex !== i.index) {
      if (t.targetIndex !== -1) {
        const l = t.targets[t.targetIndex];
        this.removeTracedCoordinates_(l.startIndex, l.endIndex);
      }
      const a = t.targets[i.index];
      this.addTracedCoordinates_(
        a,
        a.startIndex,
        i.endIndex
      );
    } else {
      const a = t.targets[t.targetIndex];
      this.addOrRemoveTracedCoordinates_(a, i.endIndex);
    }
    t.targetIndex = i.index;
    const s = t.targets[t.targetIndex];
    s.endIndex = i.endIndex;
    const r = In(
      s.coordinates,
      s.endIndex
    ), o = this.getMap().getPixelFromCoordinate(r);
    e.coordinate = r, e.pixel = [Math.round(o[0]), Math.round(o[1])];
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    let t = !0;
    if (this.getPointerCount() === 0) {
      this.downTimeout_ && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0), this.handlePointerMove_(e);
      const i = this.traceState_.active;
      if (this.toggleTraceState_(e), this.shouldHandle_) {
        const s = !this.finishCoordinate_;
        s && this.startDrawing_(e.coordinate), !s && this.freehand_ ? this.finishDrawing() : !this.freehand_ && (!s || this.mode_ === "Point") && (this.atFinish_(e.pixel, i) ? this.finishCondition_(e) && this.finishDrawing() : this.addToDrawing_(e.coordinate)), t = !1;
      } else
        this.freehand_ && this.abortDrawing();
    }
    return !t && this.stopClick_ && e.preventDefault(), t;
  }
  /**
   * Handle move events.
   * @param {import("../MapBrowserEvent.js").default} event A move event.
   * @private
   */
  handlePointerMove_(e) {
    if (this.pointerType_ = e.originalEvent.pointerType, this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
      const t = this.downPx_, i = e.pixel, s = t[0] - i[0], r = t[1] - i[1], o = s * s + r * r;
      if (this.shouldHandle_ = this.freehand_ ? o > this.squaredClickTolerance_ : o <= this.squaredClickTolerance_, !this.shouldHandle_)
        return;
    }
    if (!this.finishCoordinate_) {
      this.createOrUpdateSketchPoint_(e.coordinate.slice());
      return;
    }
    this.updateTrace_(e), this.modifyDrawing_(e.coordinate);
  }
  /**
   * Determine if an event is within the snapping tolerance of the start coord.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).
   * @return {boolean} The event is within the snapping tolerance of the start.
   * @private
   */
  atFinish_(e, t) {
    let i = !1;
    if (this.sketchFeature_) {
      let s = !1, r = [this.finishCoordinate_];
      const o = this.mode_;
      if (o === "Point")
        i = !0;
      else if (o === "Circle")
        i = this.sketchCoords_.length === 2;
      else if (o === "LineString")
        s = !t && this.sketchCoords_.length > this.minPoints_;
      else if (o === "Polygon") {
        const a = (
          /** @type {PolyCoordType} */
          this.sketchCoords_
        );
        s = a[0].length > this.minPoints_, r = [
          a[0][0],
          a[0][a[0].length - 2]
        ], t ? r = [a[0][0]] : r = [
          a[0][0],
          a[0][a[0].length - 2]
        ];
      }
      if (s) {
        const a = this.getMap();
        for (let l = 0, h = r.length; l < h; l++) {
          const c = r[l], u = a.getPixelFromCoordinate(c), d = e[0] - u[0], f = e[1] - u[1], g = this.freehand_ ? 1 : this.snapTolerance_;
          if (i = Math.sqrt(d * d + f * f) <= g, i) {
            this.finishCoordinate_ = c;
            break;
          }
        }
      }
    }
    return i;
  }
  /**
   * @param {import("../coordinate").Coordinate} coordinates Coordinate.
   * @private
   */
  createOrUpdateSketchPoint_(e) {
    this.sketchPoint_ ? this.sketchPoint_.getGeometry().setCoordinates(e) : (this.sketchPoint_ = new yt(new lt(e)), this.updateSketchFeatures_());
  }
  /**
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @private
   */
  createOrUpdateCustomSketchLine_(e) {
    this.sketchLine_ || (this.sketchLine_ = new yt());
    const t = e.getLinearRing(0);
    let i = this.sketchLine_.getGeometry();
    i ? (i.setFlatCoordinates(
      t.getLayout(),
      t.getFlatCoordinates()
    ), i.changed()) : (i = new ht(
      t.getFlatCoordinates(),
      t.getLayout()
    ), this.sketchLine_.setGeometry(i));
  }
  /**
   * Start the drawing.
   * @param {import("../coordinate.js").Coordinate} start Start coordinate.
   * @private
   */
  startDrawing_(e) {
    const t = this.getMap().getView().getProjection(), i = $r(this.geometryLayout_);
    for (; e.length < i; )
      e.push(0);
    this.finishCoordinate_ = e, this.mode_ === "Point" ? this.sketchCoords_ = e.slice() : this.mode_ === "Polygon" ? (this.sketchCoords_ = [[e.slice(), e.slice()]], this.sketchLineCoords_ = this.sketchCoords_[0]) : this.sketchCoords_ = [e.slice(), e.slice()], this.sketchLineCoords_ && (this.sketchLine_ = new yt(new ht(this.sketchLineCoords_)));
    const s = this.geometryFunction_(
      this.sketchCoords_,
      void 0,
      t
    );
    this.sketchFeature_ = new yt(), this.geometryName_ && this.sketchFeature_.setGeometryName(this.geometryName_), this.sketchFeature_.setGeometry(s), this.updateSketchFeatures_(), this.dispatchEvent(
      new Ir(Rr.DRAWSTART, this.sketchFeature_)
    );
  }
  /**
   * Modify the drawing.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @private
   */
  modifyDrawing_(e) {
    const t = this.getMap(), i = this.sketchFeature_.getGeometry(), s = t.getView().getProjection(), r = $r(this.geometryLayout_);
    let o, a;
    for (; e.length < r; )
      e.push(0);
    this.mode_ === "Point" ? a = this.sketchCoords_ : this.mode_ === "Polygon" ? (o = /** @type {PolyCoordType} */
    this.sketchCoords_[0], a = o[o.length - 1], this.atFinish_(t.getPixelFromCoordinate(e)) && (e = this.finishCoordinate_.slice())) : (o = this.sketchCoords_, a = o[o.length - 1]), a[0] = e[0], a[1] = e[1], this.geometryFunction_(
      /** @type {!LineCoordType} */
      this.sketchCoords_,
      i,
      s
    ), this.sketchPoint_ && this.sketchPoint_.getGeometry().setCoordinates(e), i.getType() === "Polygon" && this.mode_ !== "Polygon" ? this.createOrUpdateCustomSketchLine_(
      /** @type {Polygon} */
      i
    ) : this.sketchLineCoords_ && this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_), this.updateSketchFeatures_();
  }
  /**
   * Add a new coordinate to the drawing.
   * @param {!PointCoordType} coordinate Coordinate
   * @return {Feature<import("../geom/SimpleGeometry.js").default>} The sketch feature.
   * @private
   */
  addToDrawing_(e) {
    const t = this.sketchFeature_.getGeometry(), i = this.getMap().getView().getProjection();
    let s, r;
    const o = this.mode_;
    return o === "LineString" || o === "Circle" ? (this.finishCoordinate_ = e.slice(), r = /** @type {LineCoordType} */
    this.sketchCoords_, r.length >= this.maxPoints_ && (this.freehand_ ? r.pop() : s = !0), r.push(e.slice()), this.geometryFunction_(r, t, i)) : o === "Polygon" && (r = /** @type {PolyCoordType} */
    this.sketchCoords_[0], r.length >= this.maxPoints_ && (this.freehand_ ? r.pop() : s = !0), r.push(e.slice()), s && (this.finishCoordinate_ = r[0]), this.geometryFunction_(this.sketchCoords_, t, i)), this.createOrUpdateSketchPoint_(e.slice()), this.updateSketchFeatures_(), s ? this.finishDrawing() : this.sketchFeature_;
  }
  /**
   * @param {number} n The number of points to remove.
   */
  removeLastPoints_(e) {
    if (!this.sketchFeature_)
      return;
    const t = this.sketchFeature_.getGeometry(), i = this.getMap().getView().getProjection(), s = this.mode_;
    for (let r = 0; r < e; ++r) {
      let o;
      if (s === "LineString" || s === "Circle") {
        if (o = /** @type {LineCoordType} */
        this.sketchCoords_, o.splice(-2, 1), o.length >= 2) {
          this.finishCoordinate_ = o[o.length - 2].slice();
          const a = this.finishCoordinate_.slice();
          o[o.length - 1] = a, this.createOrUpdateSketchPoint_(a);
        }
        this.geometryFunction_(o, t, i), t.getType() === "Polygon" && this.sketchLine_ && this.createOrUpdateCustomSketchLine_(
          /** @type {Polygon} */
          t
        );
      } else if (s === "Polygon") {
        o = /** @type {PolyCoordType} */
        this.sketchCoords_[0], o.splice(-2, 1);
        const a = this.sketchLine_.getGeometry();
        if (o.length >= 2) {
          const l = o[o.length - 2].slice();
          o[o.length - 1] = l, this.createOrUpdateSketchPoint_(l);
        }
        a.setCoordinates(o), this.geometryFunction_(this.sketchCoords_, t, i);
      }
      if (o.length === 1) {
        this.abortDrawing();
        break;
      }
    }
    this.updateSketchFeatures_();
  }
  /**
   * Remove last point of the feature currently being drawn. Does not do anything when
   * drawing POINT or MULTI_POINT geometries.
   * @api
   */
  removeLastPoint() {
    this.removeLastPoints_(1);
  }
  /**
   * Stop drawing and add the sketch feature to the target layer.
   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
   * dispatched before inserting the feature.
   * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The drawn feature.
   * @api
   */
  finishDrawing() {
    const e = this.abortDrawing_();
    if (!e)
      return null;
    let t = this.sketchCoords_;
    const i = e.getGeometry(), s = this.getMap().getView().getProjection();
    return this.mode_ === "LineString" ? (t.pop(), this.geometryFunction_(t, i, s)) : this.mode_ === "Polygon" && (t[0].pop(), this.geometryFunction_(t, i, s), t = i.getCoordinates()), this.type_ === "MultiPoint" ? e.setGeometry(
      new ts([
        /** @type {PointCoordType} */
        t
      ])
    ) : this.type_ === "MultiLineString" ? e.setGeometry(
      new an([
        /** @type {LineCoordType} */
        t
      ])
    ) : this.type_ === "MultiPolygon" && e.setGeometry(
      new is([
        /** @type {PolyCoordType} */
        t
      ])
    ), this.dispatchEvent(new Ir(Rr.DRAWEND, e)), this.features_ && this.features_.push(e), this.source_ && this.source_.addFeature(e), e;
  }
  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The sketch feature (or null if none).
   * @private
   */
  abortDrawing_() {
    this.finishCoordinate_ = null;
    const e = this.sketchFeature_;
    return this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchLine_ = null, this.overlay_.getSource().clear(!0), this.deactivateTrace_(), e;
  }
  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @api
   */
  abortDrawing() {
    const e = this.abortDrawing_();
    e && this.dispatchEvent(new Ir(Rr.DRAWABORT, e));
  }
  /**
   * Append coordinates to the end of the geometry that is currently being drawn.
   * This can be used when drawing LineStrings or Polygons. Coordinates will
   * either be appended to the current LineString or the outer ring of the current
   * Polygon. If no geometry is being drawn, a new one will be created.
   * @param {!LineCoordType} coordinates Linear coordinates to be appended to
   * the coordinate array.
   * @api
   */
  appendCoordinates(e) {
    const t = this.mode_, i = !this.sketchFeature_;
    i && this.startDrawing_(e[0]);
    let s;
    if (t === "LineString" || t === "Circle")
      s = /** @type {LineCoordType} */
      this.sketchCoords_;
    else if (t === "Polygon")
      s = this.sketchCoords_ && this.sketchCoords_.length ? (
        /** @type {PolyCoordType} */
        this.sketchCoords_[0]
      ) : [];
    else
      return;
    i && s.shift(), s.pop();
    for (let o = 0; o < e.length; o++)
      this.addToDrawing_(e[o]);
    const r = e[e.length - 1];
    this.sketchFeature_ = this.addToDrawing_(r), this.modifyDrawing_(r);
  }
  /**
   * Initiate draw mode by starting from an existing geometry which will
   * receive new additional points. This only works on features with
   * `LineString` geometries, where the interaction will extend lines by adding
   * points to the end of the coordinates array.
   * This will change the original feature, instead of drawing a copy.
   *
   * The function will dispatch a `drawstart` event.
   *
   * @param {!Feature<LineString>} feature Feature to be extended.
   * @api
   */
  extend(e) {
    const i = e.getGeometry();
    this.sketchFeature_ = e, this.sketchCoords_ = i.getCoordinates();
    const s = this.sketchCoords_[this.sketchCoords_.length - 1];
    this.finishCoordinate_ = s.slice(), this.sketchCoords_.push(s.slice()), this.sketchPoint_ = new yt(new lt(s)), this.updateSketchFeatures_(), this.dispatchEvent(
      new Ir(Rr.DRAWSTART, this.sketchFeature_)
    );
  }
  /**
   * Redraw the sketch features.
   * @private
   */
  updateSketchFeatures_() {
    const e = [];
    this.sketchFeature_ && e.push(this.sketchFeature_), this.sketchLine_ && e.push(this.sketchLine_), this.sketchPoint_ && e.push(this.sketchPoint_);
    const t = this.overlay_.getSource();
    t.clear(!0), t.addFeatures(e);
  }
  /**
   * @private
   */
  updateState_() {
    const e = this.getMap(), t = this.getActive();
    (!e || !t) && this.abortDrawing(), this.overlay_.setMap(t ? e : null);
  }
}
function aw() {
  const n = Ju();
  return function(e, t) {
    return n[e.getGeometry().getType()];
  };
}
function lw() {
  return function(n, e, t) {
    const i = je(
      /** @type {LineCoordType} */
      [
        n[0],
        n[n.length - 1]
      ].map(function(r) {
        return pe(r);
      })
    ), s = [
      [
        $n(i),
        qn(i),
        Js(i),
        kt(i),
        $n(i)
      ]
    ];
    return e ? e.setCoordinates(s) : e = new Ne(s), e;
  };
}
function hw(n) {
  switch (n) {
    case "Point":
    case "MultiPoint":
      return "Point";
    case "LineString":
    case "MultiLineString":
      return "LineString";
    case "Polygon":
    case "MultiPolygon":
      return "Polygon";
    case "Circle":
      return "Circle";
    default:
      throw new Error("Invalid type: " + n);
  }
}
const cw = ow, yh = {
  dataProjection: "EPSG:4326",
  // Define the source projection
  featureProjection: "EPSG:3857"
  // Define the target projection for the map
};
function jc(n, e, t, i) {
  const s = new CustomEvent(e, {
    detail: {
      originalEvent: t,
      geoJSON: i
    }
  });
  n.dispatchEvent(s);
}
function Rf(n, e, t, i = !1, s = !1) {
  const r = i ? [n.feature] : n.features;
  s && e.getSource().clear();
  const o = e.getSource().getFeatures();
  if (!e.get("multipleFeatures") && (o.length || r.length > 1))
    return console.error("Multiple features detected!");
  r.forEach((h) => {
    const c = h.getGeometry();
    if (c instanceof ht) {
      const d = _u(c, {
        radius: 6378137,
        projection: "EPSG:3857"
      });
      h.set("measure", d);
    } else if (c instanceof Ne) {
      const d = mu(c, { radius: 6378137, projection: "EPSG:3857" });
      h.set("measure", d);
    }
    const u = j(h);
    h.set("id", u), h.setId(u);
  }), !i && r.length && (e.getSource().addFeatures(r), t.map.getView().fit(e.getSource().getExtent(), { duration: 750 }));
  const a = new Lo(), l = JSON.parse(
    a.writeFeatures(r, yh)
  );
  (i || s) && jc(t, "drawend", n, l), jc(t, "addfeatures", n, l);
}
function uw(n, e, t, i = !1) {
  try {
    const s = dw(n);
    if (!s) {
      console.error("Unsupported format or invalid data");
      return;
    }
    const r = s.readFeatures(n, yh);
    Rf(
      { features: r },
      e,
      t,
      !1,
      i
    );
  } catch (s) {
    console.error("Error parsing data:", s);
  }
}
function dw(n) {
  return fw(n) ? new Lo() : gw(n) ? new dx({ extractStyles: !1 }) : _w(n) ? new Hx() : null;
}
function fw(n) {
  try {
    const e = JSON.parse(n);
    return e.type === "FeatureCollection" || e.type === "Feature";
  } catch {
    return !1;
  }
}
function gw(n) {
  return n.includes("<kml") && n.includes("</kml>");
}
function _w(n) {
  try {
    const e = JSON.parse(n);
    return e.type === "Topology" && e.objects;
  } catch {
    return !1;
  }
}
function mw(n, e, t) {
  const i = Object.assign({}, t);
  if (n.interactions[i.id])
    throw Error(`Interaction with id: ${i.id} already exists.`);
  i.modify = typeof i.modify == "boolean" ? i.modify : !0;
  const s = e.getSource();
  i.type === "Box" && (i.geometryFunction = lw(), i.type = "Circle");
  const r = new cw({
    ...i,
    source: s
  });
  i.active === !1 && r.setActive(!1), r.on("drawend", (l) => {
    e.get("isDrawingEnabled") && Rf(l, e, n, !0);
  }), n.map.addInteraction(r), n.interactions[i.id] = r;
  const o = new nw({
    source: s
  });
  o.setActive(i.modify), n.map.addInteraction(o), n.interactions[`${i.id}_modify`] = o;
  const a = () => {
    n.getLayerById(e.get("id")) || (n.removeInteraction(i.id), n.removeInteraction(`${i.id}_modify`), n.map.getLayerGroup().un("change", a));
  };
  n.map.getLayerGroup().on("change", a);
}
class If extends Ln {
  constructor() {
    super(...arguments), this.templates = {}, this._renderedTemplates = {};
  }
  /**
   * Set an alternative binding syntax. Default is {{ <value> }}
   *
   * @param {string} startStr start of binding syntax
   * @param {string} endStr end of binding syntax
   */
  setBindingSyntax(e, t) {
    this._startExpression = e, this._endExpression = t;
    const i = this.escapeRegex(this._startExpression), s = this.escapeRegex(this._endExpression);
    this._expression = new RegExp(
      `${i}\\s*([$\\w\\.,'"\\s()\\[\\]]+)\\s*${s}`,
      "g"
    );
  }
  /**
   * Check if a specific template has been provided.
   *
   * @param {string} templateName
   * @returns {boolean}
   */
  hasTemplate(e) {
    return this.templates && !!this.templates[e];
  }
  /**
   * Render a <template> by type and return content to render
   *
   * @param templateType type of template (indicated by the data-type attribute)
   * @param context the data context that should be expanded in template
   * @param slotName the slot name that will be used to host the new rendered template. set to a unique value if multiple templates of this type will be rendered. default is templateType
   */
  renderTemplate(e, t, i) {
    if (!this.hasTemplate(e))
      return null;
    i = i || e;
    const s = Pn` <slot name=${i}></slot> `, r = { [e]: { ...t } };
    if (this._renderedTemplates.hasOwnProperty(i)) {
      const { slot: a } = (
        // @ts-ignore
        this._renderedTemplates[i]
      );
      this.contains(a) && this.removeChild(a);
    }
    const o = document.createElement("div");
    return o.slot = i, o.dataset.generated = "template", this._renderTemplate(o, this.templates[e], r), this.appendChild(o), this._renderedTemplates[i] = { context: r, slot: o }, s;
  }
  getTemplates() {
    const e = {};
    for (let t = 0; t < this.children.length; t++) {
      const i = this.children[t];
      if (i.nodeName === "RENDER-TEMPLATE") {
        const s = i;
        s.dataset.type ? e[s.dataset.type] = s : e.default = s, s.templateOrder = t;
      }
    }
    return e;
  }
  _renderTemplate(e, t, i) {
    let s;
    if (t && t.childNodes.length) {
      const r = t.cloneNode(!0);
      s = this.renderNode(r, e, i);
    }
    s && e.appendChild(s);
  }
  expandExpressionsAsString(e, t) {
    return e.replace(this.expression, (i, s) => {
      const r = this.evalInContext(
        s || this.trimExpression(i),
        t
      );
      return r ? typeof r == "object" ? JSON.stringify(r) : r.toString() : "";
    });
  }
  get expression() {
    return this._expression || this.setBindingSyntax("{{", "}}"), this._expression;
  }
  escapeRegex(e) {
    return e.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  evalInContext(e, t) {
    t = { ...t };
    const i = new Function("with(this) { return " + e + ";}");
    let s;
    try {
      s = i.call(t);
    } catch {
    }
    return s;
  }
  trimExpression(e) {
    return e = e.trim(), e.startsWith(this._startExpression) && e.endsWith(this._endExpression) && (e = e.substr(
      this._startExpression.length,
      e.length - this._startExpression.length - this._endExpression.length
    ), e = e.trim()), e;
  }
  renderNode(e, t, i) {
    if (e.nodeName === "#text")
      return e.textContent = this.expandExpressionsAsString(
        e.textContent,
        i
      ), e;
    if (e.nodeName === "TEMPLATE")
      return e.$parentTemplateContext = i, e;
    for (let s = 0; s < e.childNodes.length; s++) {
      const r = e.childNodes[s];
      this.renderNode(r, t, i);
    }
    return e;
  }
  firstUpdated() {
    this.templates = this.getTemplates();
  }
}
var pw = Object.defineProperty, yw = Object.getOwnPropertyDescriptor, xw = (n, e, t, i) => {
  for (var s = i > 1 ? void 0 : i ? yw(e, t) : e, r = n.length - 1, o; r >= 0; r--)
    (o = n[r]) && (s = (i ? o(e, t, s) : o(s)) || s);
  return i && s && pw(e, t, s), s;
};
class Pf extends If {
  constructor() {
    super(), this.propertyTransform = (e, t) => e;
  }
  renderContent(e) {
    ru(
      this.hasTemplate("properties") ? Pn`${this.renderTemplate(
        "properties",
        e.getProperties(),
        // `tooltip-${this.content.id}`
        "tooltip-1"
      )}` : Pn` <style>
              ul {
                margin: 0;
                padding: 15px 15px 15px 30px;
                background: #0008;
                border-radius: 15px;
                color: white;
                max-width: 250px;
                font-size: small;
              }
              span {
                font-weight: bold;
              }
            </style>
            <ul>
              ${Object.entries(e.getProperties()).map(
        ([t, i]) => this.propertyTransform({ key: t, value: i }, e)
      ).filter((t) => t).map(
        ({ key: t, value: i }) => Pn`<li><span>${t}</span>: ${i}</li>`
      )}
            </ul>`,
      this.shadowRoot
    );
  }
}
xw([
  si()
], Pf.prototype, "propertyTransform", 2);
customElements.define("eox-map-tooltip", Pf);
class Ew {
  constructor(e, t, i) {
    var d, f;
    this.eoxMap = e, this.selectLayer = t, this.options = i, this.active = i.active || t.getVisible(), this.panIn = i.panIn || !1;
    const s = this.eoxMap.map.getOverlayById("eox-map-tooltip");
    let r;
    this.selectedFids = [], s ? (this.tooltip = s.getElement(), r = s) : (this.tooltip = this.eoxMap.querySelector("eox-map-tooltip") || ((d = i.overlay) == null ? void 0 : d.element), this.tooltip && (r = new Sf({
      element: this.tooltip,
      position: void 0,
      offset: [0, 0],
      positioning: "top-left",
      className: "eox-map-tooltip",
      id: "eox-map-tooltip",
      ...i.overlay
    }), this.eoxMap.map.addOverlay(r)));
    const o = () => {
      r && i.condition === "pointermove" && r.setPosition(void 0);
    };
    e.map.on("change:target", (g) => {
      var _, m;
      (_ = g.oldValue) == null || _.removeEventListener("pointerleave", o), (m = g.target.getTargetElement()) == null || m.addEventListener("pointerleave", o);
    }), (f = e.map.getTargetElement()) == null || f.addEventListener("pointerleave", o);
    let a;
    if (this.options.layer)
      a = this.options.layer;
    else {
      const g = this.selectLayer.get("_jsonDefinition");
      a = {
        ...g,
        style: i.style,
        properties: {
          id: this.selectLayer.get("id") + "_select"
        },
        source: {
          type: g.type
        }
      };
    }
    a.renderMode = "vector", delete a.interactions, this.selectStyleLayer = Zn(
      e,
      a
    ), this.selectStyleLayer.setSource(this.selectLayer.getSource()), this.selectStyleLayer.setMap(this.eoxMap.map);
    const l = this.selectStyleLayer.getStyleFunction();
    this.selectStyleLayer.setStyle((g, _) => this.selectedFids.length && this.selectedFids.includes(this.getId(g)) ? l(g, _) : null);
    const h = (g) => {
      this.panIn && this.eoxMap.map.getView().fit(g.getGeometry().getExtent(), { duration: 750 });
    }, c = (g) => {
      if (!this.active)
        return;
      const _ = this.eoxMap.map.getView().getZoom();
      g.dragging || !this.active || _ < this.selectLayer.getMinZoom() || _ > this.selectLayer.getMaxZoom() || this.selectLayer.getFeatures(g.pixel).then((m) => {
        const p = m.length ? m[0] : null, y = p ? [this.getId(p)] : [], x = this.selectedFids[0] !== y[0];
        if (this.selectedFids = y, x && (this.selectStyleLayer.changed(), p && h(p)), r) {
          const C = g.pixel[0] > this.eoxMap.offsetWidth / 2 ? "right" : "left", w = g.pixel[1] > this.eoxMap.offsetHeight / 2 ? "bottom" : "top";
          r.setPositioning(`${w}-${C}`), r.setPosition(p ? g.coordinate : null), p && this.tooltip.renderContent && this.tooltip.renderContent(p);
        }
        const E = new CustomEvent("select", {
          detail: {
            id: i.id,
            originalEvent: g,
            feature: p
          }
        });
        this.eoxMap.dispatchEvent(E);
      });
    };
    this.eoxMap.map.on(i.condition || "click", c), this.selectLayer.on("change:opacity", () => {
      this.selectStyleLayer.setOpacity(this.selectLayer.getOpacity());
    }), this.selectLayer.on("change:visible", () => {
      const g = this.selectLayer.getVisible();
      this.selectStyleLayer.setVisible(g), this.setActive(g);
    }), this.changeSourceListener = () => {
      this.selectStyleLayer.setSource(this.selectLayer.getSource());
    }, this.selectLayer.on("change:source", this.changeSourceListener), this.removeListener = () => {
    }, this.eoxMap.map.getLayers().on("remove", this.removeListener);
    const u = () => {
      e.getLayerById(t.get("id")) || (e.selectInteractions[i.id].remove(), e.map.getLayerGroup().un("change", u));
    };
    e.map.getLayerGroup().on("change", u);
  }
  setActive(e) {
    this.active = e;
  }
  /**
   * highlights one or more features by their IDs. Does not fire select events.
   * @param {Array<string | number>} ids
   */
  highlightById(e) {
    this.selectedFids = e, this.selectStyleLayer.changed();
  }
  remove() {
    this.selectStyleLayer.setMap(null), delete this.eoxMap.selectInteractions[this.options.id], this.selectLayer.un("change:source", this.changeSourceListener), this.eoxMap.map.getLayers().un("remove", this.removeListener);
  }
  /**
   * returns the ID of a feature.
   * @param feature
   * @returns {number | string} ID value of feature
   */
  getId(e) {
    if (this.options.idProperty)
      return e.get(this.options.idProperty);
    if (e.getId() !== void 0)
      return e.getId();
    if (e.get("id") !== void 0)
      return e.get("id");
    throw Error(
      "No feature id found. Please provide which feature property should be taken instead using idProperty."
    );
  }
}
function Cw(n, e, t) {
  if (n.interactions[t.id])
    throw Error(`Interaction with id: ${t.id} already exists.`);
  return n.selectInteractions[t.id] = new Ew(
    n,
    e,
    t
  ), n.selectInteractions[t.id];
}
const ww = {
  GeoJSON: Lo,
  MVT: Gx
}, Sw = {
  Group: en,
  Image: rC,
  Tile: cC,
  Vector: ch,
  VectorTile: _C
}, vw = {
  ImageWMS: GC,
  OSM: KC,
  Tile: mf,
  TileWMS: HC,
  Vector: dh,
  VectorTile: YC,
  WMTS: JC,
  XYZ: xf
};
function Zn(n, e, t = !0) {
  var h, c;
  e = JSON.parse(JSON.stringify(e));
  const i = {
    ...ww,
    ...window.eoxMapAdvancedOlFormats
  }, s = {
    ...Sw,
    ...window.eoxMapAdvancedOlLayers
  }, r = {
    ...vw,
    ...window.eoxMapAdvancedOlSources
  }, o = s[e.type], a = r[(h = e.source) == null ? void 0 : h.type];
  if (!o)
    throw window.eoxMapAdvancedOlLayers ? new Error(`Layer type ${e.type} not supported!`) : new Error(
      `Layer type ${e.type} not created! Forgot to import advanced layers & sources plugin from @eox/map/dist/eox-map-advanced-layers-and-sources.js?`
    );
  if (e.source && !a)
    throw window.eoxMapAdvancedOlSources ? new Error(`Source type ${e.source.type} not supported!`) : new Error(
      `Source type ${e.source.type} not created! Forgot to import advanced layers & sources plugin from @eox/map/dist/eox-map-advanced-layers-and-sources.js?`
    );
  const l = new o({
    ...e,
    ...e.source && {
      //@ts-ignore
      source: new a({
        ...e.source,
        // @ts-ignore
        ...e.source.format && {
          // @ts-ignore
          format: new i[e.source.format]()
        },
        // @ts-ignore
        ...e.source.tileGrid && {
          tileGrid: _h({
            // @ts-ignore
            ...e.source.tileGrid
          })
        }
      })
    },
    ...e.type === "Group" && {
      layers: []
    },
    ...e.properties,
    style: void 0
    // override layer style, apply style after
  });
  if (l.set("_jsonDefinition", e, !0), e.type === "Group") {
    const u = e.layers.reverse().map((d) => Zn(n, d));
    u.forEach((d) => d.set("_group", l, !0)), l.setLayers(new ze(u));
  }
  if (e.style && l.setStyle(e.style), t && ((c = e.interactions) != null && c.length))
    for (let u = 0, d = e.interactions.length; u < d; u++) {
      const f = e.interactions[u];
      Lf(n, l, f);
    }
  return Af(l, e), l;
}
function Lf(n, e, t) {
  t.type === "draw" ? mw(
    n,
    e,
    t.options
  ) : t.type === "select" && Cw(n, e, t.options);
}
function bf(n, e, t) {
  var r, o, a, l;
  const i = t.get(
    "_jsonDefinition"
  );
  if (e.type !== i.type || ((r = e.source) == null ? void 0 : r.type) !== ((o = i.source) == null ? void 0 : o.type))
    throw new Error("Layers are not compatible to be updated");
  const s = Zn(n, e, !1);
  if (JSON.stringify(e.source) !== JSON.stringify(i.source) && t.setSource(
    s.getSource()
  ), ["Vector", "VectorTile"].includes(e.type) && JSON.stringify(e.style) !== JSON.stringify(i.style) && t.setStyle(s.getStyle()), JSON.stringify(e.properties) !== JSON.stringify(i.properties) && t.setProperties(e.properties), e.visible !== i.visible && t.setVisible(e.visible), e.opacity !== i.opacity && t.setOpacity(e.opacity), JSON.stringify(e.interactions) !== JSON.stringify(i.interactions) && ((a = i.interactions) == null || a.forEach((h) => {
    const c = e.interactions.find(
      (u) => u.type === h.type
    );
    c ? c.type === "draw" ? (n.interactions[c.options.id].setActive(
      c.options.active
    ), n.interactions[`${c.options.id}_modify`].setActive(
      c.options.modify
    )) : n.selectInteractions[c.options.id].setActive(
      c.options.active
    ) : n.removeInteraction(h.options.id);
  }), (l = e.interactions) == null || l.forEach((h) => {
    i.interactions.find(
      (u) => u.type === h.type
    ) || Lf(
      n,
      t,
      h
    );
  })), e.type === "Group") {
    const h = e.layers.map((u) => {
      var d;
      return (d = u.properties) == null ? void 0 : d.id;
    }), c = t.getLayers();
    c.forEach((u) => {
      h.includes(u.get("id")) || c.remove(u);
    }), e.layers.forEach((u) => {
      const d = u.properties.id;
      if (c.getArray().map((f) => f.get("id")).includes(d))
        bf(
          n,
          u,
          n.getLayerById(d)
        );
      else {
        const f = Zn(n, u);
        c.push(f);
      }
    }), c.getArray().sort((u, d) => (
      // change this order?  the reverse order, because we want the topmost layer to be on top
      h.indexOf(u.get("id")) - h.indexOf(d.get("id"))
    )), c.changed();
  }
  return Af(t, e), t;
}
const Tw = (n, e) => e ? [...e].reverse().map((t) => Zn(n, t)) : [];
function Af(n, e) {
  n.on("change:opacity", () => {
    e.opacity = n.getOpacity();
  }), n.on("change:visible", () => {
    e.visible = n.getVisible();
  }), n.on("change:zIndex", () => {
    e.zIndex = n.getZIndex();
  }), n.on("propertychange", (t) => {
    t.key !== "map" && (e.properties[t.key] = t.target.get(t.key));
  });
}
function wa(n, e) {
  return Ff(
    n.map.getLayers().getArray()
  ).find((i) => i.get("id") === e);
}
function Ff(n) {
  const e = [];
  e.push(...n);
  let t = e.filter(
    (i) => i instanceof en
  );
  for (; t.length; ) {
    const i = [];
    for (let s = 0, r = t.length; s < r; s++) {
      const o = t[s].getLayers().getArray();
      e.push(...o), i.push(
        ...o.filter((a) => a instanceof en)
      );
    }
    t = i;
  }
  return e;
}
function Yc(n) {
  if (n) {
    const e = n;
    return !nt(e, [0, 0]) && e[0] >= -180 && e[0] <= 180 && e[1] >= -90 && e[1] <= 90 ? Wg(e) : e;
  }
  return [0, 0];
}
const Xc = [
  "fullscreenchange",
  "webkitfullscreenchange",
  "MSFullscreenChange"
], Bc = {
  /**
   * Triggered after the map entered fullscreen.
   * @event FullScreenEventType#enterfullscreen
   * @api
   */
  ENTERFULLSCREEN: "enterfullscreen",
  /**
   * Triggered after the map leave fullscreen.
   * @event FullScreenEventType#leavefullscreen
   * @api
   */
  LEAVEFULLSCREEN: "leavefullscreen"
};
class Rw extends Gt {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      target: e.target
    }), this.on, this.once, this.un, this.keys_ = e.keys !== void 0 ? e.keys : !1, this.source_ = e.source, this.isInFullscreen_ = !1, this.boundHandleMapTargetChange_ = this.handleMapTargetChange_.bind(this), this.cssClassName_ = e.className !== void 0 ? e.className : "ol-full-screen", this.documentListeners_ = [], this.activeClassName_ = e.activeClassName !== void 0 ? e.activeClassName.split(" ") : [this.cssClassName_ + "-true"], this.inactiveClassName_ = e.inactiveClassName !== void 0 ? e.inactiveClassName.split(" ") : [this.cssClassName_ + "-false"];
    const t = e.label !== void 0 ? e.label : "⤢";
    this.labelNode_ = typeof t == "string" ? document.createTextNode(t) : t;
    const i = e.labelActive !== void 0 ? e.labelActive : "×";
    this.labelActiveNode_ = typeof i == "string" ? document.createTextNode(i) : i;
    const s = e.tipLabel ? e.tipLabel : "Toggle full-screen";
    this.button_ = document.createElement("button"), this.button_.title = s, this.button_.setAttribute("type", "button"), this.button_.appendChild(this.labelNode_), this.button_.addEventListener(
      G.CLICK,
      this.handleClick_.bind(this),
      !1
    ), this.setClassName_(this.button_, this.isInFullscreen_), this.element.className = `${this.cssClassName_} ${Dt} ${rn}`, this.element.appendChild(this.button_);
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.handleFullScreen_();
  }
  /**
   * @private
   */
  handleFullScreen_() {
    const e = this.getMap();
    if (!e)
      return;
    const t = e.getOwnerDocument();
    if (Wc(t))
      if (Kc(t))
        Pw(t);
      else {
        let i;
        this.source_ ? i = typeof this.source_ == "string" ? t.getElementById(this.source_) : this.source_ : i = e.getTargetElement(), this.keys_ ? Iw(i) : Mf(i);
      }
  }
  /**
   * @private
   */
  handleFullScreenChange_() {
    const e = this.getMap();
    if (!e)
      return;
    const t = this.isInFullscreen_;
    this.isInFullscreen_ = Kc(e.getOwnerDocument()), t !== this.isInFullscreen_ && (this.setClassName_(this.button_, this.isInFullscreen_), this.isInFullscreen_ ? (Yn(this.labelActiveNode_, this.labelNode_), this.dispatchEvent(Bc.ENTERFULLSCREEN)) : (Yn(this.labelNode_, this.labelActiveNode_), this.dispatchEvent(Bc.LEAVEFULLSCREEN)), e.updateSize());
  }
  /**
   * @param {HTMLElement} element Target element
   * @param {boolean} fullscreen True if fullscreen class name should be active
   * @private
   */
  setClassName_(e, t) {
    t ? (e.classList.remove(...this.inactiveClassName_), e.classList.add(...this.activeClassName_)) : (e.classList.remove(...this.activeClassName_), e.classList.add(...this.inactiveClassName_));
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    const t = this.getMap();
    t && t.removeChangeListener(
      Ce.TARGET,
      this.boundHandleMapTargetChange_
    ), super.setMap(e), this.handleMapTargetChange_(), e && e.addChangeListener(
      Ce.TARGET,
      this.boundHandleMapTargetChange_
    );
  }
  /**
   * @private
   */
  handleMapTargetChange_() {
    const e = this.documentListeners_;
    for (let i = 0, s = e.length; i < s; ++i)
      he(e[i]);
    e.length = 0;
    const t = this.getMap();
    if (t) {
      const i = t.getOwnerDocument();
      Wc(i) ? this.element.classList.remove(ic) : this.element.classList.add(ic);
      for (let s = 0, r = Xc.length; s < r; ++s)
        e.push(
          Z(i, Xc[s], this.handleFullScreenChange_, this)
        );
      this.handleFullScreenChange_();
    }
  }
}
function Wc(n) {
  const e = n.body;
  return !!(e.webkitRequestFullscreen || e.requestFullscreen && n.fullscreenEnabled);
}
function Kc(n) {
  return !!(n.webkitIsFullScreen || n.fullscreenElement);
}
function Mf(n) {
  n.requestFullscreen ? n.requestFullscreen() : n.webkitRequestFullscreen && n.webkitRequestFullscreen();
}
function Iw(n) {
  n.webkitRequestFullscreen ? n.webkitRequestFullscreen() : Mf(n);
}
function Pw(n) {
  n.exitFullscreen ? n.exitFullscreen() : n.webkitExitFullscreen && n.webkitExitFullscreen();
}
const Lw = Rw, Sa = "projection", Zc = "coordinateFormat";
class bw extends Gt {
  /**
   * @param {Options} [options] Mouse position options.
   */
  constructor(e) {
    e = e || {};
    const t = document.createElement("div");
    t.className = e.className !== void 0 ? e.className : "ol-mouse-position", super({
      element: t,
      render: e.render,
      target: e.target
    }), this.on, this.once, this.un, this.addChangeListener(Sa, this.handleProjectionChanged_), e.coordinateFormat && this.setCoordinateFormat(e.coordinateFormat), e.projection && this.setProjection(e.projection), this.renderOnMouseOut_ = e.placeholder !== void 0, this.placeholder_ = this.renderOnMouseOut_ ? e.placeholder : "&#160;", this.renderedHTML_ = t.innerHTML, this.mapProjection_ = null, this.transform_ = null, this.wrapX_ = e.wrapX !== !1;
  }
  /**
   * @private
   */
  handleProjectionChanged_() {
    this.transform_ = null;
  }
  /**
   * Return the coordinate format type used to render the current position or
   * undefined.
   * @return {import("../coordinate.js").CoordinateFormat|undefined} The format to render the current
   *     position in.
   * @observable
   * @api
   */
  getCoordinateFormat() {
    return (
      /** @type {import("../coordinate.js").CoordinateFormat|undefined} */
      this.get(Zc)
    );
  }
  /**
   * Return the projection that is used to report the mouse position.
   * @return {import("../proj/Projection.js").default|undefined} The projection to report mouse
   *     position in.
   * @observable
   * @api
   */
  getProjection() {
    return (
      /** @type {import("../proj/Projection.js").default|undefined} */
      this.get(Sa)
    );
  }
  /**
   * @param {MouseEvent} event Browser event.
   * @protected
   */
  handleMouseMove(e) {
    const t = this.getMap();
    this.updateHTML_(t.getEventPixel(e));
  }
  /**
   * @param {Event} event Browser event.
   * @protected
   */
  handleMouseOut(e) {
    this.updateHTML_(null);
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    if (super.setMap(e), e) {
      const t = e.getViewport();
      this.listenerKeys.push(
        Z(t, Lt.POINTERMOVE, this.handleMouseMove, this)
      ), this.renderOnMouseOut_ && this.listenerKeys.push(
        Z(t, Lt.POINTEROUT, this.handleMouseOut, this)
      ), this.updateHTML_(null);
    }
  }
  /**
   * Set the coordinate format type used to render the current position.
   * @param {import("../coordinate.js").CoordinateFormat} format The format to render the current
   *     position in.
   * @observable
   * @api
   */
  setCoordinateFormat(e) {
    this.set(Zc, e);
  }
  /**
   * Set the projection that is used to report the mouse position.
   * @param {import("../proj.js").ProjectionLike} projection The projection to report mouse
   *     position in.
   * @observable
   * @api
   */
  setProjection(e) {
    this.set(Sa, ce(e));
  }
  /**
   * @param {?import("../pixel.js").Pixel} pixel Pixel.
   * @private
   */
  updateHTML_(e) {
    let t = this.placeholder_;
    if (e && this.mapProjection_) {
      if (!this.transform_) {
        const r = this.getProjection();
        r ? this.transform_ = Qs(
          this.mapProjection_,
          r
        ) : this.transform_ = dl;
      }
      const s = this.getMap().getCoordinateFromPixelInternal(e);
      if (s) {
        if (this.transform_(s, s), this.wrapX_) {
          const o = this.getProjection() || this.mapProjection_;
          mo(s, o);
        }
        const r = this.getCoordinateFormat();
        r ? t = r(s) : t = s.toString();
      }
    }
    (!this.renderedHTML_ || t !== this.renderedHTML_) && (this.element.innerHTML = t, this.renderedHTML_ = t);
  }
  /**
   * Update the projection. Rendering of the coordinates is done in
   * `handleMouseMove` and `handleMouseUp`.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    const t = e.frameState;
    t ? this.mapProjection_ != t.viewState.projection && (this.mapProjection_ = t.viewState.projection, this.transform_ = null) : this.mapProjection_ = null;
  }
}
const Aw = bw, va = 0.75, Ar = 0.1;
class Fw extends Gt {
  /**
   * @param {Options} [options] OverviewMap options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      render: e.render,
      target: e.target
    }), this.boundHandleRotationChanged_ = this.handleRotationChanged_.bind(this), this.collapsed_ = e.collapsed !== void 0 ? e.collapsed : !0, this.collapsible_ = e.collapsible !== void 0 ? e.collapsible : !0, this.collapsible_ || (this.collapsed_ = !1), this.rotateWithView_ = e.rotateWithView !== void 0 ? e.rotateWithView : !1, this.viewExtent_ = void 0;
    const t = e.className !== void 0 ? e.className : "ol-overviewmap", i = e.tipLabel !== void 0 ? e.tipLabel : "Overview map", s = e.collapseLabel !== void 0 ? e.collapseLabel : "‹";
    typeof s == "string" ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = s) : this.collapseLabel_ = s;
    const r = e.label !== void 0 ? e.label : "›";
    typeof r == "string" ? (this.label_ = document.createElement("span"), this.label_.textContent = r) : this.label_ = r;
    const o = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_, a = document.createElement("button");
    a.setAttribute("type", "button"), a.title = i, a.appendChild(o), a.addEventListener(
      G.CLICK,
      this.handleClick_.bind(this),
      !1
    ), this.ovmapDiv_ = document.createElement("div"), this.ovmapDiv_.className = "ol-overviewmap-map", this.view_ = e.view;
    const l = new xd({
      view: e.view,
      controls: new ze(),
      interactions: new ze()
    });
    this.ovmap_ = l, e.layers && e.layers.forEach(function(y) {
      l.addLayer(y);
    });
    const h = document.createElement("div");
    h.className = "ol-overviewmap-box", h.style.boxSizing = "border-box", this.boxOverlay_ = new Sf({
      position: [0, 0],
      positioning: "center-center",
      element: h
    }), this.ovmap_.addOverlay(this.boxOverlay_);
    const c = t + " " + Dt + " " + rn + (this.collapsed_ && this.collapsible_ ? " " + Xr : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), u = this.element;
    u.className = c, u.appendChild(this.ovmapDiv_), u.appendChild(a);
    const d = this, f = this.boxOverlay_, g = this.boxOverlay_.getElement(), _ = function(y) {
      return {
        clientX: y.clientX,
        clientY: y.clientY
      };
    }, m = function(y) {
      const x = (
        /** @type {?} */
        _(y)
      ), E = l.getEventCoordinateInternal(
        /** @type {MouseEvent} */
        x
      );
      f.setPosition(E);
    }, p = function(y) {
      const x = l.getEventCoordinateInternal(y);
      d.getMap().getView().setCenterInternal(x), window.removeEventListener("mousemove", m), window.removeEventListener("mouseup", p);
    };
    g.addEventListener("mousedown", function() {
      window.addEventListener("mousemove", m), window.addEventListener("mouseup", p);
    });
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    const t = this.getMap();
    if (e !== t) {
      if (t) {
        const i = t.getView();
        i && this.unbindView_(i), this.ovmap_.setTarget(null);
      }
      if (super.setMap(e), e) {
        this.ovmap_.setTarget(this.ovmapDiv_), this.listenerKeys.push(
          Z(
            e,
            Ji.PROPERTYCHANGE,
            this.handleMapPropertyChange_,
            this
          )
        );
        const i = e.getView();
        i && (this.bindView_(i), i.isDef() && (this.ovmap_.updateSize(), this.resetExtent_())), this.ovmap_.isRendered() || this.updateBoxAfterOvmapIsRendered_();
      }
    }
  }
  /**
   * Handle map property changes.  This only deals with changes to the map's view.
   * @param {import("../Object.js").ObjectEvent} event The propertychange event.
   * @private
   */
  handleMapPropertyChange_(e) {
    if (e.key === Ce.VIEW) {
      const t = (
        /** @type {import("../View.js").default} */
        e.oldValue
      );
      t && this.unbindView_(t);
      const i = this.getMap().getView();
      this.bindView_(i);
    } else
      !this.ovmap_.isRendered() && (e.key === Ce.TARGET || e.key === Ce.SIZE) && this.ovmap_.updateSize();
  }
  /**
   * Register listeners for view property changes.
   * @param {import("../View.js").default} view The view.
   * @private
   */
  bindView_(e) {
    if (!this.view_) {
      const t = new pt({
        projection: e.getProjection()
      });
      this.ovmap_.setView(t);
    }
    e.addChangeListener(
      Ke.ROTATION,
      this.boundHandleRotationChanged_
    ), this.handleRotationChanged_();
  }
  /**
   * Unregister listeners for view property changes.
   * @param {import("../View.js").default} view The view.
   * @private
   */
  unbindView_(e) {
    e.removeChangeListener(
      Ke.ROTATION,
      this.boundHandleRotationChanged_
    );
  }
  /**
   * Handle rotation changes to the main map.
   * @private
   */
  handleRotationChanged_() {
    this.rotateWithView_ && this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());
  }
  /**
   * Reset the overview map extent if the box size (width or
   * height) is less than the size of the overview map size times minRatio
   * or is greater than the size of the overview size times maxRatio.
   *
   * If the map extent was not reset, the box size can fits in the defined
   * ratio sizes. This method then checks if is contained inside the overview
   * map current extent. If not, recenter the overview map to the current
   * main map center location.
   * @private
   */
  validateExtent_() {
    const e = this.getMap(), t = this.ovmap_;
    if (!e.isRendered() || !t.isRendered())
      return;
    const i = (
      /** @type {import("../size.js").Size} */
      e.getSize()
    ), r = e.getView().calculateExtentInternal(i);
    if (this.viewExtent_ && Mi(r, this.viewExtent_))
      return;
    this.viewExtent_ = r;
    const o = (
      /** @type {import("../size.js").Size} */
      t.getSize()
    ), l = t.getView().calculateExtentInternal(o), h = t.getPixelFromCoordinateInternal(
      kt(r)
    ), c = t.getPixelFromCoordinateInternal(
      qn(r)
    ), u = Math.abs(h[0] - c[0]), d = Math.abs(h[1] - c[1]), f = o[0], g = o[1];
    u < f * Ar || d < g * Ar || u > f * va || d > g * va ? this.resetExtent_() : rt(l, r) || this.recenter_();
  }
  /**
   * Reset the overview map extent to half calculated min and max ratio times
   * the extent of the main map.
   * @private
   */
  resetExtent_() {
    const e = this.getMap(), t = this.ovmap_, i = (
      /** @type {import("../size.js").Size} */
      e.getSize()
    ), r = e.getView().calculateExtentInternal(i), o = t.getView(), a = Math.log(va / Ar) / Math.LN2, l = 1 / (Math.pow(2, a / 2) * Ar);
    Ng(r, l), o.fitInternal(jr(r));
  }
  /**
   * Set the center of the overview map to the map center without changing its
   * resolution.
   * @private
   */
  recenter_() {
    const e = this.getMap(), t = this.ovmap_, i = e.getView();
    t.getView().setCenterInternal(i.getCenterInternal());
  }
  /**
   * Update the box using the main map extent
   * @private
   */
  updateBox_() {
    const e = this.getMap(), t = this.ovmap_;
    if (!e.isRendered() || !t.isRendered())
      return;
    const i = (
      /** @type {import("../size.js").Size} */
      e.getSize()
    ), s = e.getView(), r = t.getView(), o = this.rotateWithView_ ? 0 : -s.getRotation(), a = this.boxOverlay_, l = this.boxOverlay_.getElement(), h = s.getCenterInternal(), c = s.getResolution(), u = r.getResolution(), d = i[0] * c / u, f = i[1] * c / u;
    if (a.setPosition(h), l) {
      l.style.width = d + "px", l.style.height = f + "px";
      const g = "rotate(" + o + "rad)";
      l.style.transform = g;
    }
  }
  /**
   * @private
   */
  updateBoxAfterOvmapIsRendered_() {
    this.ovmapPostrenderKey_ || (this.ovmapPostrenderKey_ = Fs(
      this.ovmap_,
      Pt.POSTRENDER,
      function(e) {
        delete this.ovmapPostrenderKey_, this.updateBox_();
      },
      this
    ));
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.handleToggle_();
  }
  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(Xr), this.collapsed_ ? Yn(this.collapseLabel_, this.label_) : Yn(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_;
    const e = this.ovmap_;
    if (!this.collapsed_) {
      if (e.isRendered()) {
        this.viewExtent_ = void 0, e.render();
        return;
      }
      e.updateSize(), this.resetExtent_(), this.updateBoxAfterOvmapIsRendered_();
    }
  }
  /**
   * Return `true` if the overview map is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }
  /**
   * Set whether the overview map should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(e) {
    this.collapsible_ !== e && (this.collapsible_ = e, this.element.classList.toggle("ol-uncollapsible"), !e && this.collapsed_ && this.handleToggle_());
  }
  /**
   * Collapse or expand the overview map according to the passed parameter. Will
   * not do anything if the overview map isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(e) {
    !this.collapsible_ || this.collapsed_ === e || this.handleToggle_();
  }
  /**
   * Determine if the overview map is collapsed.
   * @return {boolean} The overview map is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }
  /**
   * Return `true` if the overview map view can rotate, `false` otherwise.
   * @return {boolean} True if the control view can rotate.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Set whether the overview map view should rotate with the main map view.
   * @param {boolean} rotateWithView True if the control view should rotate.
   * @api
   */
  setRotateWithView(e) {
    this.rotateWithView_ !== e && (this.rotateWithView_ = e, this.getMap().getView().getRotation() !== 0 && (this.rotateWithView_ ? this.handleRotationChanged_() : this.ovmap_.getView().setRotation(0), this.viewExtent_ = void 0, this.validateExtent_(), this.updateBox_()));
  }
  /**
   * Return the overview map.
   * @return {import("../Map.js").default} Overview map.
   * @api
   */
  getOverviewMap() {
    return this.ovmap_;
  }
  /**
   * Update the overview map element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    this.validateExtent_(), this.updateBox_();
  }
}
const Mw = Fw, Ta = "units", Ow = [1, 2, 5], gs = 25.4 / 0.28;
class Dw extends Gt {
  /**
   * @param {Options} [options] Scale line options.
   */
  constructor(e) {
    e = e || {};
    const t = document.createElement("div");
    t.style.pointerEvents = "none", super({
      element: t,
      render: e.render,
      target: e.target
    }), this.on, this.once, this.un;
    const i = e.className !== void 0 ? e.className : e.bar ? "ol-scale-bar" : "ol-scale-line";
    this.innerElement_ = document.createElement("div"), this.innerElement_.className = i + "-inner", this.element.className = i + " " + Dt, this.element.appendChild(this.innerElement_), this.viewState_ = null, this.minWidth_ = e.minWidth !== void 0 ? e.minWidth : 64, this.maxWidth_ = e.maxWidth, this.renderedVisible_ = !1, this.renderedWidth_ = void 0, this.renderedHTML_ = "", this.addChangeListener(Ta, this.handleUnitsChanged_), this.setUnits(e.units || "metric"), this.scaleBar_ = e.bar || !1, this.scaleBarSteps_ = e.steps || 4, this.scaleBarText_ = e.text || !1, this.dpi_ = e.dpi || void 0;
  }
  /**
   * Return the units to use in the scale line.
   * @return {Units} The units
   * to use in the scale line.
   * @observable
   * @api
   */
  getUnits() {
    return this.get(Ta);
  }
  /**
   * @private
   */
  handleUnitsChanged_() {
    this.updateElement_();
  }
  /**
   * Set the units to use in the scale line.
   * @param {Units} units The units to use in the scale line.
   * @observable
   * @api
   */
  setUnits(e) {
    this.set(Ta, e);
  }
  /**
   * Specify the dpi of output device such as printer.
   * @param {number|undefined} dpi The dpi of output device.
   * @api
   */
  setDpi(e) {
    this.dpi_ = e;
  }
  /**
   * @private
   */
  updateElement_() {
    const e = this.viewState_;
    if (!e) {
      this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    const t = e.center, i = e.projection, s = this.getUnits(), r = s == "degrees" ? "degrees" : "m";
    let o = zr(
      i,
      e.resolution,
      t,
      r
    );
    const a = this.minWidth_ * (this.dpi_ || gs) / gs, l = this.maxWidth_ !== void 0 ? this.maxWidth_ * (this.dpi_ || gs) / gs : void 0;
    let h = a * o, c = "";
    if (s == "degrees") {
      const x = zn.degrees;
      h *= x, h < x / 60 ? (c = "″", o *= 3600) : h < x ? (c = "′", o *= 60) : c = "°";
    } else if (s == "imperial")
      h < 0.9144 ? (c = "in", o /= 0.0254) : h < 1609.344 ? (c = "ft", o /= 0.3048) : (c = "mi", o /= 1609.344);
    else if (s == "nautical")
      o /= 1852, c = "NM";
    else if (s == "metric")
      h < 1e-6 ? (c = "nm", o *= 1e9) : h < 1e-3 ? (c = "μm", o *= 1e6) : h < 1 ? (c = "mm", o *= 1e3) : h < 1e3 ? c = "m" : (c = "km", o /= 1e3);
    else if (s == "us")
      h < 0.9144 ? (c = "in", o *= 39.37) : h < 1609.344 ? (c = "ft", o /= 0.30480061) : (c = "mi", o /= 1609.3472);
    else
      throw new Error("Invalid units");
    let u = 3 * Math.floor(Math.log(a * o) / Math.log(10)), d, f, g, _, m, p;
    for (; ; ) {
      g = Math.floor(u / 3);
      const x = Math.pow(10, g);
      if (d = Ow[(u % 3 + 3) % 3] * x, f = Math.round(d / o), isNaN(f)) {
        this.element.style.display = "none", this.renderedVisible_ = !1;
        return;
      }
      if (l !== void 0 && f >= l) {
        d = _, f = m, g = p;
        break;
      } else if (f >= a)
        break;
      _ = d, m = f, p = g, ++u;
    }
    const y = this.scaleBar_ ? this.createScaleBar(f, d, c) : d.toFixed(g < 0 ? -g : 0) + " " + c;
    this.renderedHTML_ != y && (this.innerElement_.innerHTML = y, this.renderedHTML_ = y), this.renderedWidth_ != f && (this.innerElement_.style.width = f + "px", this.renderedWidth_ = f), this.renderedVisible_ || (this.element.style.display = "", this.renderedVisible_ = !0);
  }
  /**
   * @private
   * @param {number} width The current width of the scalebar.
   * @param {number} scale The current scale.
   * @param {string} suffix The suffix to append to the scale text.
   * @return {string} The stringified HTML of the scalebar.
   */
  createScaleBar(e, t, i) {
    const s = this.getScaleForResolution(), r = s < 1 ? Math.round(1 / s).toLocaleString() + " : 1" : "1 : " + Math.round(s).toLocaleString(), o = this.scaleBarSteps_, a = e / o, l = [this.createMarker("absolute")];
    for (let c = 0; c < o; ++c) {
      const u = c % 2 === 0 ? "ol-scale-singlebar-odd" : "ol-scale-singlebar-even";
      l.push(
        `<div><div class="ol-scale-singlebar ${u}" style="width: ${a}px;"></div>` + this.createMarker("relative") + // render text every second step, except when only 2 steps
        (c % 2 === 0 || o === 2 ? this.createStepText(c, e, !1, t, i) : "") + "</div>"
      );
    }
    return l.push(this.createStepText(o, e, !0, t, i)), (this.scaleBarText_ ? `<div class="ol-scale-text" style="width: ${e}px;">` + r + "</div>" : "") + l.join("");
  }
  /**
   * Creates a marker at given position
   * @param {'absolute'|'relative'} position The position, absolute or relative
   * @return {string} The stringified div containing the marker
   */
  createMarker(e) {
    return `<div class="ol-scale-step-marker" style="position: ${e}; top: ${e === "absolute" ? 3 : -10}px;"></div>`;
  }
  /**
   * Creates the label for a marker marker at given position
   * @param {number} i The iterator
   * @param {number} width The width the scalebar will currently use
   * @param {boolean} isLast Flag indicating if we add the last step text
   * @param {number} scale The current scale for the whole scalebar
   * @param {string} suffix The suffix for the scale
   * @return {string} The stringified div containing the step text
   */
  createStepText(e, t, i, s, r) {
    const a = (e === 0 ? 0 : Math.round(s / this.scaleBarSteps_ * e * 100) / 100) + (e === 0 ? "" : " " + r), l = e === 0 ? -3 : t / this.scaleBarSteps_ * -1, h = e === 0 ? 0 : t / this.scaleBarSteps_ * 2;
    return `<div class="ol-scale-step-text" style="margin-left: ${l}px;text-align: ${e === 0 ? "left" : "center"};min-width: ${h}px;left: ${i ? t + "px" : "unset"};">` + a + "</div>";
  }
  /**
   * Returns the appropriate scale for the given resolution and units.
   * @return {number} The appropriate scale.
   */
  getScaleForResolution() {
    const e = zr(
      this.viewState_.projection,
      this.viewState_.resolution,
      this.viewState_.center,
      "m"
    ), t = this.dpi_ || gs, i = 1e3 / 25.4;
    return e * i * t;
  }
  /**
   * Update the scale line element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    const t = e.frameState;
    t ? this.viewState_ = t.viewState : this.viewState_ = null, this.updateElement_();
  }
}
const Nw = Dw, _s = {
  VERTICAL: 0,
  HORIZONTAL: 1
};
class kw extends Gt {
  /**
   * @param {Options} [options] Zoom slider options.
   */
  constructor(e) {
    e = e || {}, super({
      target: e.target,
      element: document.createElement("div"),
      render: e.render
    }), this.dragListenerKeys_ = [], this.currentResolution_ = void 0, this.direction_ = _s.VERTICAL, this.dragging_, this.heightLimit_ = 0, this.widthLimit_ = 0, this.startX_, this.startY_, this.thumbSize_ = null, this.sliderInitialized_ = !1, this.duration_ = e.duration !== void 0 ? e.duration : 200;
    const t = e.className !== void 0 ? e.className : "ol-zoomslider", i = document.createElement("button");
    i.setAttribute("type", "button"), i.className = t + "-thumb " + Dt;
    const s = this.element;
    s.className = t + " " + Dt + " " + rn, s.appendChild(i), s.addEventListener(
      Lt.POINTERDOWN,
      this.handleDraggerStart_.bind(this),
      !1
    ), s.addEventListener(
      Lt.POINTERMOVE,
      this.handleDraggerDrag_.bind(this),
      !1
    ), s.addEventListener(
      Lt.POINTERUP,
      this.handleDraggerEnd_.bind(this),
      !1
    ), s.addEventListener(
      G.CLICK,
      this.handleContainerClick_.bind(this),
      !1
    ), i.addEventListener(G.CLICK, hg, !1);
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    super.setMap(e), e && e.render();
  }
  /**
   * Initializes the slider element. This will determine and set this controls
   * direction_ and also constrain the dragging of the thumb to always be within
   * the bounds of the container.
   *
   * @return {boolean} Initialization successful
   * @private
   */
  initSlider_() {
    const e = this.element;
    let t = e.offsetWidth, i = e.offsetHeight;
    if (t === 0 && i === 0)
      return this.sliderInitialized_ = !1;
    const s = getComputedStyle(e);
    t -= parseFloat(s.paddingRight) + parseFloat(s.paddingLeft), i -= parseFloat(s.paddingTop) + parseFloat(s.paddingBottom);
    const r = (
      /** @type {HTMLElement} */
      e.firstElementChild
    ), o = getComputedStyle(r), a = r.offsetWidth + parseFloat(o.marginRight) + parseFloat(o.marginLeft), l = r.offsetHeight + parseFloat(o.marginTop) + parseFloat(o.marginBottom);
    return this.thumbSize_ = [a, l], t > i ? (this.direction_ = _s.HORIZONTAL, this.widthLimit_ = t - a) : (this.direction_ = _s.VERTICAL, this.heightLimit_ = i - l), this.sliderInitialized_ = !0;
  }
  /**
   * @param {PointerEvent} event The browser event to handle.
   * @private
   */
  handleContainerClick_(e) {
    const t = this.getMap().getView(), i = this.getRelativePosition_(
      e.offsetX - this.thumbSize_[0] / 2,
      e.offsetY - this.thumbSize_[1] / 2
    ), s = this.getResolutionForPosition_(i), r = t.getConstrainedZoom(t.getZoomForResolution(s));
    t.animateInternal({
      zoom: r,
      duration: this.duration_,
      easing: nn
    });
  }
  /**
   * Handle dragger start events.
   * @param {PointerEvent} event The drag event.
   * @private
   */
  handleDraggerStart_(e) {
    if (!this.dragging_ && e.target === this.element.firstElementChild) {
      const t = (
        /** @type {HTMLElement} */
        this.element.firstElementChild
      );
      if (this.getMap().getView().beginInteraction(), this.startX_ = e.clientX - parseFloat(t.style.left), this.startY_ = e.clientY - parseFloat(t.style.top), this.dragging_ = !0, this.dragListenerKeys_.length === 0) {
        const i = this.handleDraggerDrag_, s = this.handleDraggerEnd_, r = this.getMap().getOwnerDocument();
        this.dragListenerKeys_.push(
          Z(r, Lt.POINTERMOVE, i, this),
          Z(r, Lt.POINTERUP, s, this)
        );
      }
    }
  }
  /**
   * Handle dragger drag events.
   *
   * @param {PointerEvent} event The drag event.
   * @private
   */
  handleDraggerDrag_(e) {
    if (this.dragging_) {
      const t = e.clientX - this.startX_, i = e.clientY - this.startY_, s = this.getRelativePosition_(t, i);
      this.currentResolution_ = this.getResolutionForPosition_(s), this.getMap().getView().setResolution(this.currentResolution_);
    }
  }
  /**
   * Handle dragger end events.
   * @param {PointerEvent} event The drag event.
   * @private
   */
  handleDraggerEnd_(e) {
    this.dragging_ && (this.getMap().getView().endInteraction(), this.dragging_ = !1, this.startX_ = void 0, this.startY_ = void 0, this.dragListenerKeys_.forEach(he), this.dragListenerKeys_.length = 0);
  }
  /**
   * Positions the thumb inside its container according to the given resolution.
   *
   * @param {number} res The res.
   * @private
   */
  setThumbPosition_(e) {
    const t = this.getPositionForResolution_(e), i = (
      /** @type {HTMLElement} */
      this.element.firstElementChild
    );
    this.direction_ == _s.HORIZONTAL ? i.style.left = this.widthLimit_ * t + "px" : i.style.top = this.heightLimit_ * t + "px";
  }
  /**
   * Calculates the relative position of the thumb given x and y offsets.  The
   * relative position scales from 0 to 1.  The x and y offsets are assumed to be
   * in pixel units within the dragger limits.
   *
   * @param {number} x Pixel position relative to the left of the slider.
   * @param {number} y Pixel position relative to the top of the slider.
   * @return {number} The relative position of the thumb.
   * @private
   */
  getRelativePosition_(e, t) {
    let i;
    return this.direction_ === _s.HORIZONTAL ? i = e / this.widthLimit_ : i = t / this.heightLimit_, _e(i, 0, 1);
  }
  /**
   * Calculates the corresponding resolution of the thumb given its relative
   * position (where 0 is the minimum and 1 is the maximum).
   *
   * @param {number} position The relative position of the thumb.
   * @return {number} The corresponding resolution.
   * @private
   */
  getResolutionForPosition_(e) {
    return this.getMap().getView().getResolutionForValueFunction()(1 - e);
  }
  /**
   * Determines the relative position of the slider for the given resolution.  A
   * relative position of 0 corresponds to the minimum view resolution.  A
   * relative position of 1 corresponds to the maximum view resolution.
   *
   * @param {number} res The resolution.
   * @return {number} The relative position value (between 0 and 1).
   * @private
   */
  getPositionForResolution_(e) {
    const t = this.getMap().getView().getValueForResolutionFunction();
    return _e(1 - t(e), 0, 1);
  }
  /**
   * Update the zoomslider element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    if (!e.frameState || !this.sliderInitialized_ && !this.initSlider_())
      return;
    const t = e.frameState.viewState.resolution;
    this.currentResolution_ = t, this.setThumbPosition_(t);
  }
}
const Gw = kw;
class zw extends Gt {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      target: e.target
    }), this.extent = e.extent ? e.extent : null;
    const t = e.className !== void 0 ? e.className : "ol-zoom-extent", i = e.label !== void 0 ? e.label : "E", s = e.tipLabel !== void 0 ? e.tipLabel : "Fit to extent", r = document.createElement("button");
    r.setAttribute("type", "button"), r.title = s, r.appendChild(
      typeof i == "string" ? document.createTextNode(i) : i
    ), r.addEventListener(
      G.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const o = t + " " + Dt + " " + rn, a = this.element;
    a.className = o, a.appendChild(r);
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.handleZoomToExtent();
  }
  /**
   * @protected
   */
  handleZoomToExtent() {
    const t = this.getMap().getView(), i = this.extent ? Et(this.extent, t.getProjection()) : t.getProjection().getExtent();
    t.fitInternal(jr(i));
  }
}
const $w = zw, Uw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Attribution: ld,
  Control: Gt,
  FullScreen: Lw,
  MousePosition: Aw,
  OverviewMap: Mw,
  Rotate: hd,
  ScaleLine: Nw,
  Zoom: cd,
  ZoomSlider: Gw,
  ZoomToExtent: $w,
  defaults: ud
}, Symbol.toStringTag, { value: "Module" }));
function Vw(n, e, t, i) {
  e && e[t] ? JSON.stringify(e[t]) !== JSON.stringify(i) && (n.removeControl(t), Hc(n, t, i)) : Hc(n, t, i);
}
function Hc(n, e, t) {
  const i = Object.assign({}, t);
  t && t.layers && (i.layers = Tw(n, t.layers));
  const s = new Uw[e](i);
  n.map.addControl(s), n.mapControls[e] = s;
}
var jw = Object.defineProperty, Yw = Object.getOwnPropertyDescriptor, Xw = (n, e, t, i) => {
  for (var s = i > 1 ? void 0 : i ? Yw(e, t) : e, r = n.length - 1, o; r >= 0; r--)
    (o = n[r]) && (s = (i ? o(e, t, s) : o(s)) || s);
  return i && s && jw(e, t, s), s;
};
class Of extends If {
  constructor() {
    super(...arguments), this.value = 50;
  }
  render() {
    return Pn`
      <style>
        :host {
          display: block;
        }
        /* Inspired by https://www.codehim.com/html5-css3/html-css-image-comparison-slider/ */
        .eox-map-compare {
          --thumb-bgc: #fff;
          --thumb-w: 0.2rem;

          position: relative;
        }
        .eox-map-compare::after {
          content: "";
          display: block;
          padding-bottom: 50%;
        }
        .eox-map-compare__first,
        .eox-map-compare__second {
          height: 100%;
          object-fit: cover;
          position: absolute;
          top: 0;
          width: 100%;
        }
        .eox-map-compare__first {
          clip-path: polygon(
            0% 0%,
            ${this.value}% 0%,
            ${this.value}% 100%,
            0% 100%
          );
        }
        .eox-map-compare__second {
          clip-path: polygon(
            100% 0%,
            ${this.value}% 0%,
            ${this.value}% 100%,
            100% 100%
          );
        }
        .eox-map-compare__range {
          background-color: transparent;
          box-sizing: border-box;
          font-family: inherit;
          height: 100%;
          margin: 0;
          outline: none;
          position: absolute;
          top: 0;
          width: 100%;
          pointer-events: none;
        }
        .eox-map-compare__range::-moz-range-thumb {
          background-color: var(--thumb-bgc);
          cursor: ew-resize;
          height: 100%;
          width: var(--thumb-w);
          pointer-events: all;
          box-shadow: 0 0 5px black;
          clip-path: inset(0 -5px 0 -5px);
        }
        .eox-map-compare__range::-webkit-slider-thumb {
          background-color: var(--thumb-bgc);
          cursor: ew-resize;
          height: 100%;
          width: var(--thumb-w);
          pointer-events: all;
          position: relative;
          box-shadow: 0 0 5px black;
          -webkit-clip-path: inset(0 -5px 0 -5px);
          clip-path: inset(0 -5px 0 -5px);
        }
        .eox-map-compare__range::-moz-range-track {
          background: transparent;
          background-size: 100%;
          box-sizing: border-box;
        }
        .eox-map-compare__range::-webkit-slider-runnable-track {
          background: transparent;
          background-size: 100%;
          box-sizing: border-box;
          height: 100%;
        }
        .eox-map-compare__range,
        .eox-map-compare__range::-webkit-slider-runnable-track,
        .eox-map-compare__range::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
        }
      </style>
      <div class="eox-map-compare">
        <div class="eox-map-compare__first">
          <slot name="first"></slot>
        </div>
        <div class="eox-map-compare__second">
          <slot name="second"></slot>
        </div>
        <input
          type="range"
          class="eox-map-compare__range"
          min="0"
          max="100"
          value=${this.value}
          @input=${(e) => this.value = parseInt(e.target.value)}
        />
      </div>
    `;
  }
}
Xw([
  si()
], Of.prototype, "value", 2);
customElements.define("eox-map-compare", Of);
function qc(n, e = !1) {
  e ? (n.addInteraction(
    new Jr({
      condition: fc
    })
  ), "ontouchstart" in window || navigator.maxTouchPoints > 0 ? n.addInteraction(
    new Ss({
      condition: function(i) {
        return (
          //@ts-ignore
          this.getPointerCount() === 2 || fc(i)
        );
      }
    })
  ) : n.addInteraction(new Ss())) : (n.addInteraction(new Jr()), n.addInteraction(new Ss()));
}
function Bw(n) {
  n.getInteractions().getArray().forEach((e) => {
    (e instanceof Jr || e instanceof Ss) && n.removeInteraction(e);
  });
}
var Ww = Object.defineProperty, Kw = Object.getOwnPropertyDescriptor, Tt = (n, e, t, i) => {
  for (var s = i > 1 ? void 0 : i ? Kw(e, t) : e, r = n.length - 1, o; r >= 0; r--)
    (o = n[r]) && (s = (i ? o(e, t, s) : o(s)) || s);
  return i && s && Ww(e, t, s), s;
};
let ut = class extends Ln {
  constructor() {
    super(...arguments), this.center = [0, 0], this.zoom = 0, this.map = new xd({
      controls: [],
      layers: [],
      view: new pt({
        center: [0, 0],
        zoom: 0
      })
    }), this.interactions = {}, this.selectInteractions = {}, this.mapControls = {}, this.addOrUpdateLayer = (n) => {
      var s;
      n.interactions || (n.interactions = []);
      const e = (s = n.properties) == null ? void 0 : s.id, t = e ? wa(this, e) : !1;
      let i;
      return t ? (bf(this, n, t), i = t) : (i = Zn(this, n), this.map.addLayer(i)), i;
    }, this.removeInteraction = (n) => {
      this.map.removeInteraction(this.interactions[n]), delete this.interactions[n], this.interactions[`${n}_modify`] && (this.map.removeInteraction(this.interactions[`${n}_modify`]), delete this.interactions[`${n}_modify`]);
    }, this.removeSelect = (n) => {
      this.selectInteractions[n].remove(), delete this.selectInteractions[n];
    }, this.removeControl = (n) => {
      this.map.removeControl(this.mapControls[n]), delete this.mapControls[n];
    }, this.getLayerById = (n) => wa(this, n), this.parseFeature = (n) => new Lo().writeFeaturesObject(n, yh), this.parseTextToFeature = (n, e, t = !1) => {
      uw(n, e, this, t);
    }, this.getFlatLayersArray = Ff;
  }
  set controls(n) {
    const e = this._controls, t = n;
    if (e) {
      const i = Object.keys(e), s = Object.keys(t);
      for (let r = 0, o = i.length; r < o; r++) {
        const a = i[r];
        s.includes(a) || this.removeControl(a);
      }
    }
    if (t) {
      const i = Object.keys(n);
      for (let s = 0, r = i.length; s < r; s++) {
        const o = i[s];
        Vw(this, e, o, n[o]);
      }
    }
    this._controls = t;
  }
  /**
   * Map controls, in JSON format
   */
  get controls() {
    return this._controls;
  }
  set layers(n) {
    const e = this._layers, t = JSON.parse(
      JSON.stringify(n)
    ).reverse();
    e && e.forEach((s) => {
      var r, o;
      if (!((r = s.properties) != null && r.id) || // always remove old layers without id
      !t.find(
        (a) => a.properties.id === s.properties.id
      )) {
        const a = wa(this, (o = s.properties) == null ? void 0 : o.id);
        this.map.removeLayer(a);
      }
    }), t.forEach((s) => {
      this.addOrUpdateLayer(s);
    });
    const i = t.map((s) => {
      var r;
      return (r = s.properties) == null ? void 0 : r.id;
    });
    this.map.getLayers().getArray().sort((s, r) => i.indexOf(s.get("id")) - i.indexOf(r.get("id"))), this._layers = t;
  }
  get layers() {
    return this._layers;
  }
  set preventScroll(n) {
    n ? (Bw(this.map), qc(this.map, !0)) : qc(this.map), this._preventScroll = n;
  }
  /**
   * Prevent accidental scrolling / drag-pan of the map.
   * Scrolling only enabled while pressing the platform modifier key (ctrl/cmd).
   * @type Boolean
   */
  get preventScroll() {
    return this._preventScroll;
  }
  set config(n) {
    var e;
    this._config = n, this.center = (e = n.view) == null ? void 0 : e.center, this.zoom = n == null ? void 0 : n.view.zoom, this.layers = n == null ? void 0 : n.layers, this.controls = n == null ? void 0 : n.controls, this.preventScroll === void 0 && (this.preventScroll = n == null ? void 0 : n.preventScroll);
  }
  get config() {
    return this._config;
  }
  render() {
    return Pn`
      <style>
        ${`
      :host {
        display: block;
      }
      .eox-map-tooltip {
        pointer-events: none !important;
      }
    `}
        ${Jp}
      </style>
      <div style="width: 100%; height: 100%"></div>
      <slot></slot>
    `;
  }
  /**
   * Return extent increased by the provided value.
   * @param {import("ol/extent").Extent} extent
   * @param {number} value
   * @returns {import("ol/extent").Extent}
   */
  buffer(n, e) {
    return ot(n, e);
  }
  firstUpdated() {
    if (this.sync) {
      const n = document.querySelector(this.sync);
      n && this.map.setView(n.map.getView());
    } else
      this.center && this.map.getView().setCenter(Yc(this.center)), this.zoom && this.map.getView().setZoom(this.zoom);
    this.map.setTarget(this.renderRoot.querySelector("div")), this.map.on("loadend", () => {
      this.dispatchEvent(new CustomEvent("loadend", { detail: this.map }));
    });
  }
  updated(n) {
    n.has("center") && this.map.getView().setCenter(Yc(this.center)), n.has("zoom") && this.map.getView().setZoom(this.zoom || 0);
  }
};
Tt([
  si({ attribute: !1, type: Array })
], ut.prototype, "center", 2);
Tt([
  si({ attribute: !1, type: Array })
], ut.prototype, "layers", 1);
Tt([
  si({ attribute: "prevent-scroll", type: Boolean })
], ut.prototype, "preventScroll", 1);
Tt([
  si({ attribute: !1, type: Object })
], ut.prototype, "config", 1);
Tt([
  si({ attribute: !1, type: Number })
], ut.prototype, "zoom", 2);
Tt([
  si()
], ut.prototype, "sync", 2);
Tt([
  fo()
], ut.prototype, "map", 2);
Tt([
  fo()
], ut.prototype, "interactions", 2);
Tt([
  fo()
], ut.prototype, "selectInteractions", 2);
Tt([
  fo()
], ut.prototype, "mapControls", 2);
ut = Tt([
  rg("eox-map")
], ut);
export {
  ut as EOxMap
};
